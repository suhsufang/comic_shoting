<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®‡å®™æ‰“äº‚é¬¥</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #000011 0%, #000033 50%, #000066 100%);
            display: block;
        }
        
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            display: none;
            z-index: 20;
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid #00ffff;
            border-radius: 15px;
            z-index: 30;
        }

        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border: 3px solid #00ffff;
            border-radius: 20px;
            z-index: 40;
            box-shadow: 0 0 30px #00ffff;
        }

        #weaponShop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #ffaa00;
            border-radius: 20px;
            z-index: 40;
            box-shadow: 0 0 30px #ffaa00;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
        }

        .difficulty-btn {
            background: linear-gradient(45deg, #00ff00, #00aa00);
            margin: 15px;
            padding: 20px 35px;
            font-size: 20px;
        }

        .difficulty-btn.medium {
            background: linear-gradient(45deg, #ffaa00, #ff8800);
        }

        .difficulty-btn.hard {
            background: linear-gradient(45deg, #ff3300, #aa0000);
        }
        
        .difficulty-btn.boss {
            background: linear-gradient(45deg, #8800ff, #4400aa);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px #8800ff;
        }

        .weapon-item {
            background: rgba(0, 50, 100, 0.7);
            border: 2px solid #00aaff;
            border-radius: 10px;
            margin: 10px;
            padding: 15px;
            display: inline-block;
            width: 200px;
            vertical-align: top;
        }

        .weapon-item.owned {
            border-color: #00ff00;
            background: rgba(0, 100, 50, 0.7);
        }

        .weapon-item.equipped {
            border-color: #ffff00;
            background: rgba(100, 100, 0, 0.7);
        }

        .weapon-price {
            color: #ffaa00;
            font-weight: bold;
            font-size: 18px;
        }

        .weapon-stats {
            font-size: 14px;
            color: #aaaaaa;
            margin-top: 10px;
        }

        .credits-display {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #ffaa00;
            font-size: 18px;
            text-shadow: 0 0 10px #ffaa00;
        }

        .shop-tab {
            background: linear-gradient(45deg, #333, #666);
            color: #fff;
            margin: 5px;
            padding: 10px 20px;
            border: 2px solid #666;
        }

        .shop-tab.active {
            background: linear-gradient(45deg, #ffaa00, #ff8800);
            border-color: #ffaa00;
            color: #000;
        }
        
        button {
            background: linear-gradient(45deg, #05f900, #00d5ff);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #00ffff;
        }
        
        .controls {
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }
        
        .powerup-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            color: #ffff00;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="gameUI">
            <div>ç”Ÿå‘½å€¼: <span id="health">100/100</span></div>
            <div>åˆ†æ•¸: <span id="score">0</span></div>
            <div>ç­‰ç´š: <span id="level">1</span></div>
        </div>
        
        <div id="powerup-indicator" class="powerup-indicator"></div>
        <div class="credits-display">é‡‘å¹£: <span id="credits">0</span></div>
        
        <div id="mainMenu">
            <h1 style="color: #0004ff; margin-bottom: 30px; text-shadow: 0 0 20px #002aff;">ğŸš€ å®‡å®™å¤§äº‚é¬¥ ğŸš€</h1>
            <div style="margin: 30px 0;">
                <h2 style="color: #00ffff;">é¸æ“‡é›£åº¦</h2>
                <button class="difficulty-btn" onclick="selectDifficulty('easy')">ç°¡å–®</button>
                <button class="difficulty-btn medium" onclick="selectDifficulty('medium')">æ™®é€š</button>
                <button class="difficulty-btn hard" onclick="selectDifficulty('hard')">å›°é›£</button>
                <button class="difficulty-btn boss" onclick="selectDifficulty('boss')">ğŸ”¥ é­”ç‹æŒ‘æˆ° ğŸ”¥</button>
            </div>
            <div style="margin: 30px 0;">
                <button onclick="openWeaponShop()">æ­¦å™¨å•†åº—</button>
                <button onclick="showControls()">æ“ä½œèªªæ˜</button>
            </div>
            <div style="margin: 20px 0;">
                <button onclick="saveGame()" style="background: linear-gradient(45deg, #00ff00, #00aa00);">ä¿å­˜éŠæˆ²</button>
                <button onclick="loadGame()" style="background: linear-gradient(45deg, #0088ff, #004488);">è¼‰å…¥éŠæˆ²</button>
            </div>
        </div>

        <div id="startScreen" style="display: none;">
            <h2 style="color: #00ffff; margin-bottom: 20px;">æº–å‚™é–‹å§‹</h2>
            <p>é›£åº¦: <span id="selectedDifficulty" style="color: #ffaa00;">ç°¡å–®</span></p>
            <p>è£å‚™æ­¦å™¨: <span id="equippedWeapon" style="color: #ffaa00;">åŸºç¤å°„æ‰‹</span></p>
            <p>è£å‚™å­å½ˆ: <span id="equippedBulletDisplay" style="color: #ffaa00;">æ¨™æº–å­å½ˆ</span></p>
            <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
            <button onclick="backToMainMenu()">è¿”å›ä¸»é¸å–®</button>
        </div>

        <div id="controlsScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); padding: 40px; border: 2px solid #00ffff; border-radius: 15px; z-index: 30;">
            <h2 style="color: #00ffff;">æ“ä½œèªªæ˜</h2>
            <div class="controls">
                <p>WASD æˆ– æ–¹å‘éµ - ç§»å‹•é£›èˆ¹</p>
                <p>ç©ºç™½éµ - å°„æ“Š</p>
                <p>æ¶ˆæ»…æ•µäººç²å¾—åˆ†æ•¸ã€é‡‘å¹£å’Œé“å…·ï¼</p>
                <p>å‡ç´šè§£é–æ›´å¼·å¤§çš„æ­¦å™¨</p>
            </div>
            <button onclick="backToMainMenu()">è¿”å›ä¸»é¸å–®</button>
        </div>

        <div id="weaponShop">
            <h2 style="color: #ffaa00; margin-bottom: 20px;">æ­¦å™¨å•†åº—</h2>
            <div style="margin-bottom: 20px;">
                <span style="color: #ffaa00; font-size: 20px;">é‡‘å¹£: <span id="shopCredits">0</span></span>
            </div>
            <div style="margin-bottom: 20px;">
                <button onclick="showWeapons()" id="weaponTab" class="shop-tab active">æ­¦å™¨</button>
                <button onclick="showBullets()" id="bulletTab" class="shop-tab">å­å½ˆ</button>
            </div>
            <div id="weaponList"></div>
            <div id="bulletList" style="display: none;"></div>
            <button onclick="backToMainMenu()" style="margin-top: 20px;">è¿”å›ä¸»é¸å–®</button>
        </div>
        
        <div id="gameOver">
            <h2 style="color: #ff0000;">éŠæˆ²çµæŸï¼</h2>
            <p>æœ€çµ‚åˆ†æ•¸: <span id="finalScore">0</span></p>
            <p>é”åˆ°ç­‰ç´š: <span id="finalLevel">1</span></p>
            <p style="margin: 15px 0;">
                <button onclick="saveGame()" style="background: linear-gradient(45deg, #00ff00, #00aa00);">å„²å­˜éŠæˆ²</button>
            </p>
            <button onclick="restartGame()">é‡æ–°é–‹å§‹</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // éŠæˆ²ç‹€æ…‹
        let gameState = 'menu'; // 'menu', 'start', 'playing', 'gameOver', 'victory'
        let score = 0;
        let level = 1;
        let health = 100;
        let maxHealth = 100;
        let credits = 0; // éŠæˆ²è²¨å¹£
        let keys = {};
        let lastTime = 0;
        
        // é›£åº¦è¨­å®š
        let difficulty = 'easy';
        let difficultySettings = {
            easy: {
                enemySpeedMultiplier: 1,
                enemyHealthMultiplier: 0.7,
                enemySpawnRate: 0.8,
                playerDamageMultiplier: 1.2,
                creditMultiplier: 1
            },
            medium: {
                enemySpeedMultiplier: 1.3,
                enemyHealthMultiplier: 1,
                enemySpawnRate: 1,
                playerDamageMultiplier: 1,
                creditMultiplier: 1.5
            },
            hard: {
                enemySpeedMultiplier: 1.6,
                enemyHealthMultiplier: 1.5,
                enemySpawnRate: 1.3,
                playerDamageMultiplier: 0.8,
                creditMultiplier: 2
            },
            boss: {
                enemySpeedMultiplier: 2.0,
                enemyHealthMultiplier: 2.5,
                enemySpawnRate: 0,
                playerDamageMultiplier: 0.7,
                creditMultiplier: 10.0
            }
        };
        
        // æ­¦å™¨ç³»çµ±
        let ownedWeapons = ['basic'];
        let equippedWeapon = 'basic';
        let ownedBullets = ['normal'];
        let equippedBullet = 'normal';
        
        let weapons = {
            basic: {
                name: 'åŸºç¤å°„æ‰‹',
                price: 0,
                damage: 2.5,
                fireRate: 150,
                description: 'å¼·åŒ–æ¨™æº–å°„æ“Šæ­¦å™¨',
                minLevel: 1
            },
            rapid: {
                name: 'å¿«é€Ÿå°„æ‰‹',
                price: 2000,
                damage: 2.0,
                fireRate: 80,
                description: 'è¶…é«˜å°„é€Ÿæ”»æ“Š',
                minLevel: 5
            },
            heavy: {
                name: 'é‡å‹ç ²å°',
                price: 5000,
                damage: 4.0,
                fireRate: 300,
                description: 'è¶…é«˜å‚·å®³é‡ç ²',
                minLevel: 10
            },
            spread: {
                name: 'æ•£å°„ç‚®',
                price: 8000,
                damage: 2.8,
                fireRate: 200,
                description: '3ç™¼é«˜å‚·æ•£å°„æ”»æ“Š',
                minLevel: 12
            },
            piercing: {
                name: 'ç©¿é€æ§',
                price: 12000,
                damage: 3.5,
                fireRate: 140,
                description: 'é«˜å‚·ç©¿é€æ”»æ“Š',
                minLevel: 18
            },
            elemental: {
                name: 'å…ƒç´ ä¹‹åŠ›',
                price: 20000,
                damage: 3.2,
                fireRate: 120,
                description: 'é›™ç™¼å…ƒç´ æ”»æ“Š',
                minLevel: 20
            },
            sniper: {
                name: 'å®‡å®™ç‹™æ“Šæ§',
                price: 35000,
                damage: 8.0,
                fireRate: 800,
                description: 'æ¥µé«˜å‚·å®³ç²¾æº–æ”»æ“Š',
                minLevel: 25
            },
            minigun: {
                name: 'æ—‹è½‰æ©Ÿç ²',
                price: 50000,
                damage: 2.2,
                fireRate: 40,
                description: 'æ¥µé€Ÿé€£çºŒæ”»æ“Š',
                minLevel: 30
            },
            fusion: {
                name: 'æ ¸èåˆç ²',
                price: 80000,
                damage: 6.0,
                fireRate: 180,
                description: 'æ ¸èƒ½èåˆçˆ†ç‚¸',
                minLevel: 35
            },
            antimatter: {
                name: 'åç‰©è³ªå°„ç·š',
                price: 150000,
                damage: 12.0,
                fireRate: 600,
                description: 'æœ€é«˜ç§‘æŠ€æ­¦å™¨',
                minLevel: 40
            },
            quantum: {
                name: 'é‡å­ç ´å£è€…',
                price: 300000,
                damage: 15.0,
                fireRate: 400,
                description: 'é‡å­ç©ºé–“æ­¦å™¨',
                minLevel: 45
            },
            cosmic: {
                name: 'å®‡å®™æ¯€æ»…è€…',
                price: 500000,
                damage: 20.0,
                fireRate: 300,
                description: 'çµ‚æ¥µå®‡å®™æ­¦å™¨',
                minLevel: 50
            }
        };
        
        let bulletTypes = {
            normal: {
                name: 'æ¨™æº–å­å½ˆ',
                price: 0,
                damageMultiplier: 1.5,
                speed: 10,
                color: '#ffff00',
                effect: 'normal',
                description: 'å¼·åŒ–åŸºç¤å­å½ˆ',
                minLevel: 1
            },
            explosive: {
                name: 'çˆ†ç‚¸å½ˆ',
                price: 3000,
                damageMultiplier: 2.0,
                speed: 8,
                color: '#ff4400',
                effect: 'explosive',
                description: 'æ“Šä¸­æ™‚ç”¢ç”Ÿçˆ†ç‚¸',
                minLevel: 6
            },
            ice: {
                name: 'å†°å‡å½ˆ',
                price: 5000,
                damageMultiplier: 1.8,
                speed: 9,
                color: '#00aaff',
                effect: 'ice',
                description: 'æ¸›ç·©æ•µäººé€Ÿåº¦',
                minLevel: 10
            },
            lightning: {
                name: 'é›»æ¼¿å½ˆ',
                price: 8000,
                damageMultiplier: 2.2,
                speed: 12,
                color: '#ffff00',
                effect: 'lightning',
                description: 'å¿«é€Ÿä¸”å¸¶é›»æ•ˆæœ',
                minLevel: 14
            },
            laser: {
                name: 'æ¿€å…‰æŸ',
                price: 12000,
                damageMultiplier: 2.5,
                speed: 14,
                color: '#00ff37',
                effect: 'laser',
                description: 'é«˜é€Ÿç©¿é€æ”»æ“Š',
                minLevel: 18
            },
            plasma: {
                name: 'ç­‰é›¢å­ç‚®',
                price: 20000,
                damageMultiplier: 3.0,
                speed: 11,
                color: '#aa00ff',
                effect: 'plasma',
                description: 'è¶…é«˜å‚·å®³ç­‰é›¢å­é«”',
                minLevel: 25
            },
            neutron: {
                name: 'ä¸­å­æ˜Ÿå½ˆ',
                price: 35000,
                damageMultiplier: 4.0,
                speed: 13,
                color: '#ff0080',
                effect: 'neutron',
                description: 'æ¥µé‡ä¸­å­æ˜Ÿç‰©è³ª',
                minLevel: 30
            },
            antimatter: {
                name: 'åç‰©è³ªå½ˆ',
                price: 60000,
                damageMultiplier: 5.0,
                speed: 15,
                color: '#8000ff',
                effect: 'antimatter',
                description: 'åç‰©è³ªæ¹æ»…å½ˆè—¥',
                minLevel: 35
            },
            quantum: {
                name: 'é‡å­å½ˆ',
                price: 100000,
                damageMultiplier: 6.0,
                speed: 16,
                color: '#00ffff',
                effect: 'quantum',
                description: 'é‡å­ç©ºé–“ç ´å£',
                minLevel: 40
            },
            singularity: {
                name: 'é»‘æ´å½ˆ',
                price: 200000,
                damageMultiplier: 8.0,
                speed: 12,
                color: '#4d0080',
                effect: 'singularity',
                description: 'å¾®å‹é»‘æ´å¸å–å½ˆ',
                minLevel: 45
            },
            genesis: {
                name: 'å‰µä¸–ä¹‹å½ˆ',
                price: 500000,
                damageMultiplier: 10.0,
                speed: 18,
                color: '#ffffff',
                effect: 'genesis',
                description: 'çµ‚æ¥µå‰µä¸–åŠ›é‡',
                minLevel: 50
            }
        };
        
        // ç©å®¶é£›èˆ¹
        const player = {
            x: 375,
            y: 500,
            width: 50,
            height: 50,
            speed: 5,
            fireRate: 200,
            lastFire: 0,
            powerLevel: 1
        };
        
        // éŠæˆ²ç‰©ä»¶é™£åˆ—
        let bullets = [];
        let enemies = [];
        let bosses = [];
        let bossBullets = [];
        let powerups = [];
        let particles = [];
        let stars = [];
        let bossSpawnTimer = 0;
        
        // åˆå§‹åŒ–æ˜Ÿæ˜ŸèƒŒæ™¯
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }
        }
        
        // éµç›¤äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // å°„æ“Šå‡½æ•¸
        function shoot() {
            const now = Date.now();
            if (now - player.lastFire > player.fireRate) {
                createBulletPattern();
                player.lastFire = now;
            }
        }
        
        // å‰µå»ºä¸åŒç­‰ç´šçš„å­å½ˆæ¨¡å¼
        function createBulletPattern() {
            const centerX = player.x + player.width / 2;
            const centerY = player.y;
            const currentWeapon = weapons[equippedWeapon] || weapons['basic'];
            const currentBullet = bulletTypes[equippedBullet] || bulletTypes['normal'];
            
            // æ ¹æ“šæ­¦å™¨é¡å‹å‰µå»ºå­å½ˆ
            switch (equippedWeapon) {
                case 'basic':
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
                case 'rapid':
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
                case 'heavy':
                    createBullet(centerX - 4, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
                case 'spread':
                    for (let i = 0; i < 3; i++) {
                        const angle = (i - 1) * 0.3;
                        createBullet(centerX - 2 + (i - 1) * 10, centerY, angle, currentBullet.color, 1, currentBullet.effect);
                    }
                    break;
                case 'piercing':
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, 'piercing');
                    break;
                case 'elemental':
                    const time = Date.now() * 0.01;
                    for (let i = 0; i < 2; i++) {
                        const angle = (i - 0.5) * 0.2;
                        createBullet(centerX - 2 + (i - 0.5) * 15, centerY, angle, currentBullet.color, 1, currentBullet.effect);
                    }
                    break;
                default:
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
            }
        }
        
        // 1-10ç­‰ï¼šåŸºç¤æ­¦å™¨ - æ¸›å°‘å­å½ˆæ•¸é‡å’Œç¯„åœ
        function createBasicWeapons(centerX, centerY, level) {
            const bulletCount = Math.min(Math.ceil(level / 2), 3); // æœ€å¤š3ç™¼å­å½ˆ
            const spread = 0.15; // æ¸›å°‘æ•£å°„ç¯„åœ
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = (i - (bulletCount - 1) / 2) * spread / Math.max(bulletCount - 1, 1);
                const color = `hsl(${60 + level * 5}, 100%, 50%)`;
                createBullet(centerX - 2, centerY, angle, color, 1, 'basic');
            }
        }
        
        // 11-25ç­‰ï¼šå…ƒç´ æ­¦å™¨ - æ¸›å°‘å­å½ˆæ•¸é‡
        function createElementalWeapons(centerX, centerY, level, time) {
            const elementType = Math.floor((level - 11) / 5);
            const bulletCount = Math.min(3 + Math.ceil((level - 10) / 3), 5); // æœ€å¤š5ç™¼
            
            switch (elementType) {
                case 0: // ç«å…ƒç´  (11-15ç­‰)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = (i - (bulletCount - 1) / 2) * 0.1; // æ¸›å°‘æ•£å°„
                        createBullet(centerX - 2, centerY, angle, '#ff4400', 1 + Math.floor(level / 5), 'fire');
                        if (Math.random() < 0.2 && i < 2) { // æ¸›å°‘é¡å¤–å­å½ˆ
                            createBullet(centerX + Math.sin(time + i) * 8, centerY, angle, '#ff6600', 1 + Math.floor(level / 6), 'fireball');
                        }
                    }
                    break;
                case 1: // å†°å…ƒç´  (16-20ç­‰)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = (i - (bulletCount - 1) / 2) * 0.08; // æ¸›å°‘æ•£å°„
                        createBullet(centerX - 2, centerY, angle, '#00aaff', 1 + Math.floor(level / 5), 'ice');
                    }
                    break;
                case 2: // é›·å…ƒç´  (21-25ç­‰)
                    for (let i = 0; i < Math.min(bulletCount, 3); i++) { // é™åˆ¶é›·é›»å­å½ˆæ•¸é‡
                        const angle = Math.sin(time + i) * 0.3; // æ¸›å°‘æ–æ“ºç¯„åœ
                        createBullet(centerX + Math.sin(time + i) * 10, centerY, angle, '#ffff00', 1 + Math.floor(level / 4), 'lightning');
                    }
                    break;
            }
        }
        
        // 26-50ç­‰ï¼šèƒ½é‡æ­¦å™¨
        function createEnergyWeapons(centerX, centerY, level, time) {
            const weaponType = Math.floor((level - 26) / 8);
            const intensity = level - 25;
            
            switch (weaponType) {
                case 0: // æ°´è—æ©Ÿå…‰(26-33ç­‰)
                    for (let i = 0; i < 8 + intensity; i++) {
                        const angle = (i * Math.PI / (4 + intensity)) - Math.PI/2;
                        createBullet(centerX, centerY, Math.sin(angle), '#000598', 2 + Math.floor(level / 8), 'laser');
                    }
                    break;
                case 1: // å…‰è¼æ©Ÿé—œæ§ (34-41ç­‰)
                    for (let i = 0; i < 6; i++) {
                        const radius = 30 + Math.sin(time + i) * 15;
                        const angle = (i * Math.PI / 3) + time;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * 10;
                        createBullet(x, y, 0, '#00ff37', 2 + Math.floor(level / 7), 'plasma');
                    }
                    break;
                case 2: // å®‡å®™é¢¨æš´ (42-50ç­‰)
                    for (let i = 0; i < 12 + intensity; i++) {
                        const angle = (i * Math.PI / 6) + time;
                        const distance = 20 + Math.sin(time * 2 + i) * 25;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, Math.sin(angle) * 0.3, '#00ffff', 3 + Math.floor(level / 6), 'energy');
                    }
                    break;
            }
        }
        
        // 51-75ç­‰ï¼šé­”æ³•æ­¦å™¨
        function createMagicWeapons(centerX, centerY, level, time) {
            const spellType = Math.floor((level - 51) / 8);
            
            switch (spellType) {
                case 0: // å–šæ˜Ÿè¡“ (51-58ç­‰)
                    for (let i = 0; i < 16; i++) {
                        const angle = (i * Math.PI / 8) + time;
                        const distance = 15 + Math.sin(time * 3 + i) * 20;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, Math.sin(angle), '#ffaa00', 4 + Math.floor(level / 5), 'star');
                    }
                    break;
                case 1: // æ™‚ç©ºæ‰­æ›² (59-66ç­‰)
                    for (let i = 0; i < 20; i++) {
                        const angle = time + i * 0.3;
                        const spiral = angle * 3;
                        createBullet(centerX + Math.cos(spiral) * (i * 2), centerY, Math.sin(angle), '#aa00ff', 5 + Math.floor(level / 4), 'portal');
                    }
                    break;
                case 2: // å½—æ˜Ÿé›¨ (67-75ç­‰)
                    for (let i = 0; i < 25; i++) {
                        const x = centerX + (Math.random() - 0.5) * 100;
                        const angle = (Math.random() - 0.5) * 0.8;
                        createBullet(x, centerY, angle, '#ff00ff', 6 + Math.floor(level / 3), 'comet');
                    }
                    break;
            }
        }
        
        // 76-99ç­‰ï¼šå‚³èªªæ­¦å™¨
        function createLegendaryWeapons(centerX, centerY, level, time) {
            const weaponType = Math.floor((level - 76) / 8);
            
            switch (weaponType) {
                case 0: // é¾æ¯ç ² (76-83ç­‰) - ç°¡åŒ–
                    for (let i = 0; i < 8; i++) { // å¾30æ¸›å°‘åˆ°8
                        const angle = (i - 3.5) * 0.3;
                        const hue = (time * 50 + i * 45) % 360;
                        createBullet(centerX + Math.sin(time + i) * 10, centerY, angle, `hsl(${hue}, 100%, 50%)`, 8 + Math.floor(level / 2), 'dragon');
                    }
                    break;
                case 1: // é»‘æ´ç ² (84-91ç­‰) - ç°¡åŒ–
                    for (let i = 0; i < 10; i++) { // å¾40æ¸›å°‘åˆ°10
                        const angle = (i * Math.PI / 5) + time;
                        const distance = Math.sin(time * 2 + i) * 20;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, 0, '#000033', 10 + Math.floor(level / 2), 'blackhole');
                    }
                    break;
                case 2: // å½©è™¹å°„ç·š (92-99ç­‰) - ç°¡åŒ–
                    for (let i = 0; i < 12; i++) { // å¾50æ¸›å°‘åˆ°12
                        const angle = (i - 5.5) * 0.2;
                        const hue = (time * 100 + i * 30) % 360;
                        createBullet(centerX + (i - 5.5) * 8, centerY, angle, `hsl(${hue}, 100%, 70%)`, 12 + Math.floor(level / 1.5), 'cosmic');
                    }
                    break;
            }
        }
        
        // 100ç­‰ï¼šçµ‚æ¥µæ­¦å™¨ - ç°¡åŒ–
        function createUltimateWeapon(centerX, centerY, time) {
            // çµ‚æ¥µå½©è™¹èºæ—‹ - ç°¡åŒ–
            for (let i = 0; i < 20; i++) { // å¾100æ¸›å°‘åˆ°20
                const angle = (i * Math.PI / 10) + time;
                const distance = Math.sin(time + i * 0.5) * 30;
                const hue = (time * 200 + i * 18) % 360;
                
                createBullet(
                    centerX + Math.cos(angle) * distance, 
                    centerY, 
                    Math.sin(angle) * 0.3, 
                    `hsl(${hue}, 100%, 50%)`, 
                    15,
                    'ultimate'
                );
            }
            
            // ä¸­å¿ƒè¶…ç´šå°„ç·š - ç°¡åŒ–
            for (let i = 0; i < 5; i++) { // å¾10æ¸›å°‘åˆ°5
                createBullet(centerX - 2 + i, centerY, 0, '#ffffff', 20, 'godray');
            }
        }
        
        // é¸å–®å°èˆªå‡½æ•¸
        function selectDifficulty(diff) {
            difficulty = diff;
            const difficultyNames = {
                'easy': 'ç°¡å–®',
                'medium': 'æ™®é€š', 
                'hard': 'å›°é›£',
                'boss': 'ğŸ”¥ é­”ç‹ä¹‹æˆ° ğŸ”¥'
            };
            document.getElementById('selectedDifficulty').textContent = difficultyNames[diff];
            showStartScreen();
        }

        function showStartScreen() {
            hideAllScreens();
            document.getElementById('startScreen').style.display = 'block';
            gameState = 'start';
        }

        function showControls() {
            hideAllScreens();
            document.getElementById('controlsScreen').style.display = 'block';
        }

        function openWeaponShop() {
            hideAllScreens();
            document.getElementById('weaponShop').style.display = 'block';
            updateWeaponShop();
        }

        function backToMainMenu() {
            hideAllScreens();
            document.getElementById('mainMenu').style.display = 'block';
            gameState = 'menu';
        }

        function hideAllScreens() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controlsScreen').style.display = 'none';
            document.getElementById('weaponShop').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
        }

        function showWeapons() {
            document.getElementById('weaponTab').classList.add('active');
            document.getElementById('bulletTab').classList.remove('active');
            document.getElementById('weaponList').style.display = 'block';
            document.getElementById('bulletList').style.display = 'none';
            updateWeaponShop();
        }

        function showBullets() {
            document.getElementById('weaponTab').classList.remove('active');
            document.getElementById('bulletTab').classList.add('active');
            document.getElementById('weaponList').style.display = 'none';
            document.getElementById('bulletList').style.display = 'block';
            updateBulletShop();
        }

        function updateWeaponShop() {
            const weaponList = document.getElementById('weaponList');
            const shopCredits = document.getElementById('shopCredits');
            shopCredits.textContent = credits;
            
            weaponList.innerHTML = '';
            
            Object.keys(weapons).forEach(weaponId => {
                const weapon = weapons[weaponId];
                const weaponDiv = document.createElement('div');
                weaponDiv.className = 'weapon-item';
                
                const isOwned = ownedWeapons.includes(weaponId);
                const isEquipped = equippedWeapon === weaponId;
                const canBuy = credits >= weapon.price && level >= weapon.minLevel;
                
                if (isOwned) weaponDiv.className += ' owned';
                if (isEquipped) weaponDiv.className += ' equipped';
                
                let buttonText = '';
                let buttonAction = '';
                
                if (isEquipped) {
                    buttonText = 'âœ“ å·²è£å‚™';
                    buttonAction = '';
                } else if (isOwned) {
                    buttonText = 'è£å‚™';
                    buttonAction = `onclick="equipWeapon('${weaponId}')"`;
                } else if (canBuy) {
                    buttonText = `è³¼è²· (${weapon.price}é‡‘)`;
                    buttonAction = `onclick="buyWeapon('${weaponId}')"`;
                } else if (level < weapon.minLevel) {
                    buttonText = `éœ€è¦ç­‰ç´š${weapon.minLevel}`;
                    buttonAction = '';
                } else {
                    buttonText = `é‡‘å¹£ä¸è¶³ (${weapon.price}é‡‘)`;
                    buttonAction = '';
                }
                
                weaponDiv.innerHTML = `
                    <h3 style="color: #00ffff; margin-bottom: 10px;">${weapon.name}</h3>
                    <p style="color: #ffffff; margin-bottom: 10px;">${weapon.description}</p>
                    <div class="weapon-stats">
                        <p>å‚·å®³: ${weapon.damage}x</p>
                        <p>å°„é€Ÿ: ${(1000/weapon.fireRate).toFixed(1)}/ç§’</p>
                        <p>éœ€æ±‚ç­‰ç´š: ${weapon.minLevel}</p>
                    </div>
                    <div class="weapon-price">${weapon.price === 0 ? 'å…è²»' : weapon.price + 'é‡‘å¹£'}</div>
                    <button ${buttonAction} ${!buttonAction ? 'disabled' : ''}>${buttonText}</button>
                `;
                
                weaponList.appendChild(weaponDiv);
            });
        }

        function updateBulletShop() {
            const bulletList = document.getElementById('bulletList');
            bulletList.innerHTML = '';
            
            Object.keys(bulletTypes).forEach(bulletId => {
                const bullet = bulletTypes[bulletId];
                const bulletDiv = document.createElement('div');
                bulletDiv.className = 'weapon-item';
                
                const isOwned = ownedBullets.includes(bulletId);
                const isEquipped = equippedBullet === bulletId;
                const canBuy = credits >= bullet.price && level >= bullet.minLevel;
                
                if (isOwned) bulletDiv.className += ' owned';
                if (isEquipped) bulletDiv.className += ' equipped';
                
                let buttonText = '';
                let buttonAction = '';
                
                if (isEquipped) {
                    buttonText = 'âœ“ å·²è£å‚™';
                    buttonAction = '';
                } else if (isOwned) {
                    buttonText = 'è£å‚™';
                    buttonAction = `onclick="equipBullet('${bulletId}')"`;
                } else if (canBuy) {
                    buttonText = `è³¼è²· (${bullet.price}é‡‘)`;
                    buttonAction = `onclick="buyBullet('${bulletId}')"`;
                } else if (level < bullet.minLevel) {
                    buttonText = `éœ€è¦ç­‰ç´š${bullet.minLevel}`;
                    buttonAction = '';
                } else {
                    buttonText = `é‡‘å¹£ä¸è¶³ (${bullet.price}é‡‘)`;
                    buttonAction = '';
                }
                
                bulletDiv.innerHTML = `
                    <h3 style="color: #ffff00; margin-bottom: 10px;">${bullet.name}</h3>
                    <p style="color: #ffffff; margin-bottom: 10px;">${bullet.description}</p>
                    <div class="weapon-stats">
                        <p>å‚·å®³å€ç‡: ${bullet.damageMultiplier}x</p>
                        <p>é€Ÿåº¦: ${bullet.speed}</p>
                        <p>éœ€æ±‚ç­‰ç´š: ${bullet.minLevel}</p>
                    </div>
                    <div class="weapon-price">${bullet.price === 0 ? 'å…è²»' : bullet.price + 'é‡‘å¹£'}</div>
                    <button ${buttonAction} ${!buttonAction ? 'disabled' : ''}>${buttonText}</button>
                `;
                
                bulletList.appendChild(bulletDiv);
            });
        }

        function buyWeapon(weaponId) {
            const weapon = weapons[weaponId];
            if (credits >= weapon.price && level >= weapon.minLevel) {
                credits -= weapon.price;
                ownedWeapons.push(weaponId);
                updateCreditsDisplay();
                updateWeaponShop();
                autoSaveGame(); // è‡ªå‹•ä¿å­˜
            }
        }

        function equipWeapon(weaponId) {
            if (ownedWeapons.includes(weaponId)) {
                equippedWeapon = weaponId;
                const weapon = weapons[weaponId];
                player.fireRate = weapon.fireRate;
                document.getElementById('equippedWeapon').textContent = weapon.name;
                updateWeaponShop();
                autoSaveGame(); // è‡ªå‹•ä¿å­˜
            }
        }

        function buyBullet(bulletId) {
            const bullet = bulletTypes[bulletId];
            if (credits >= bullet.price && level >= bullet.minLevel) {
                credits -= bullet.price;
                ownedBullets.push(bulletId);
                updateCreditsDisplay();
                updateBulletShop();
                autoSaveGame(); // è‡ªå‹•ä¿å­˜
            }
        }

        function equipBullet(bulletId) {
            if (ownedBullets.includes(bulletId)) {
                equippedBullet = bulletId;
                const bullet = bulletTypes[bulletId];
                document.getElementById('equippedBulletDisplay').textContent = bullet.name;
                updateBulletShop();
                autoSaveGame(); // è‡ªå‹•ä¿å­˜
            }
        }

        function updateCreditsDisplay() {
            document.getElementById('credits').textContent = credits;
            document.getElementById('shopCredits').textContent = credits;
        }

        // éŠæˆ²å­˜æª”åŠŸèƒ½
        function saveGame() {
            const saveData = {
                credits: credits,
                level: level,
                maxHealth: maxHealth,
                ownedWeapons: ownedWeapons,
                ownedBullets: ownedBullets,
                equippedWeapon: equippedWeapon,
                equippedBullet: equippedBullet,
                difficulty: difficulty,
                saveDate: new Date().toLocaleDateString('zh-TW')
            };
            
            try {
                localStorage.setItem('cosmosShootingSave', JSON.stringify(saveData));
                alert('éŠæˆ²å·²ä¿å­˜ï¼\nä¿å­˜æ™‚é–“: ' + saveData.saveDate);
            } catch (error) {
                alert('ä¿å­˜å¤±æ•—ï¼å¯èƒ½æ˜¯ç€è¦½å™¨å­˜å„²ç©ºé–“ä¸è¶³ã€‚');
            }
        }

        function loadGame() {
            try {
                const saveData = localStorage.getItem('cosmosShootingSave');
                if (!saveData) {
                    alert('æ²’æœ‰æ‰¾åˆ°å­˜æª”ï¼');
                    return;
                }
                
                const data = JSON.parse(saveData);
                
                // è¼‰å…¥å­˜æª”æ•¸æ“š
                credits = data.credits || 0;
                level = Math.max(data.level || 1, 1);
                maxHealth = data.maxHealth || 100;
                ownedWeapons = data.ownedWeapons || ['basic'];
                ownedBullets = data.ownedBullets || ['normal'];
                equippedWeapon = data.equippedWeapon || 'basic';
                equippedBullet = data.equippedBullet || 'normal';
                difficulty = data.difficulty || 'easy';
                
                // æ›´æ–°UIé¡¯ç¤º
                updateCreditsDisplay();
                updateAllDisplays();
                
                alert('éŠæˆ²è¼‰å…¥æˆåŠŸï¼\nå­˜æª”æ™‚é–“: ' + (data.saveDate || 'æœªçŸ¥'));
                
            } catch (error) {
                alert('è¼‰å…¥å¤±æ•—ï¼å­˜æª”å¯èƒ½å·²æå£ã€‚');
            }
        }

        // è‡ªå‹•ä¿å­˜ï¼ˆéœé»˜ä¿å­˜ï¼Œä¸é¡¯ç¤ºæç¤ºï¼‰
        function autoSaveGame() {
            const saveData = {
                credits: credits,
                level: level,
                maxHealth: maxHealth,
                ownedWeapons: ownedWeapons,
                ownedBullets: ownedBullets,
                equippedWeapon: equippedWeapon,
                equippedBullet: equippedBullet,
                difficulty: difficulty,
                saveDate: new Date().toLocaleDateString('zh-TW')
            };
            
            try {
                localStorage.setItem('cosmosShootingSave', JSON.stringify(saveData));
            } catch (error) {
                console.log('è‡ªå‹•ä¿å­˜å¤±æ•—:', error);
            }
        }

        function updateAllDisplays() {
            // æ›´æ–°é›£åº¦é¡¯ç¤º
            const difficultyNames = {
                'easy': 'ç°¡å–®',
                'medium': 'æ™®é€š', 
                'hard': 'å›°é›£',
                'boss': 'ğŸ”¥ é­”ç‹æŒ‘æˆ° ğŸ”¥'
            };
            document.getElementById('selectedDifficulty').textContent = difficultyNames[difficulty];
            
            // æ›´æ–°æ­¦å™¨é¡¯ç¤º
            const weapon = weapons[equippedWeapon];
            if (weapon) {
                document.getElementById('equippedWeapon').textContent = weapon.name;
            }
            
            // æ›´æ–°å­å½ˆé¡¯ç¤º
            const bullet = bulletTypes[equippedBullet];
            if (bullet) {
                document.getElementById('equippedBulletDisplay').textContent = bullet.name;
            }
            
            // æ›´æ–°å•†åº—é¡¯ç¤º
            if (document.getElementById('weaponList').style.display !== 'none') {
                updateWeaponShop();
            } else {
                updateBulletShop();
            }
        }

        // å‰µå»ºå­å½ˆ
        function createBullet(x, y, angle, color, damage, effect = 'normal') {
            const currentWeapon = weapons[equippedWeapon] || weapons['basic'];
            const currentBullet = bulletTypes[equippedBullet] || bulletTypes['normal'];
            const dynamicDiff = getDynamicDifficulty();
            const finalDamage = damage * currentWeapon.damage * currentBullet.damageMultiplier * dynamicDiff.playerDamageMultiplier;
            
            bullets.push({
                x: x,
                y: y,
                width: effect === 'piercing' ? 6 : 4,
                height: effect === 'piercing' ? 12 : 10,
                speed: currentBullet ? currentBullet.speed : 8,
                damage: finalDamage,
                angle: angle,
                color: color,
                effect: effect,
                trail: [],
                pierced: 0 // ç”¨æ–¼ç©¿é€å­å½ˆè¨ˆæ•¸
            });
        }
        
        // Bossç³»çµ± - æ“´å±•BOSSé¡å‹
        function spawnBoss() {
            // é­”ç‹æŒ‘æˆ°æ¨¡å¼å…è¨±å¤šå€‹Bossï¼Œä¸€èˆ¬æ¨¡å¼åªå…è¨±ä¸€å€‹
            if (difficulty !== 'boss' && bosses.length > 0) return;
            
            // æ ¹æ“šç­‰ç´šè§£é–ä¸åŒçš„BOSSé¡å‹
            let availableBossTypes = ['laser', 'missile', 'shield'];
            
            if (level >= 5) availableBossTypes.push('teleport', 'berserker');
            if (level >= 10) availableBossTypes.push('fortress', 'phantom');
            if (level >= 15) availableBossTypes.push('dreadnought', 'voidlord');
            if (level >= 20) availableBossTypes.push('omega', 'nemesis');
            if (level >= 25) availableBossTypes.push('apocalypse', 'titan');
            if (level >= 30) availableBossTypes.push('leviathan', 'phoenix');
            if (level >= 35) availableBossTypes.push('emperor', 'worldeater');
            if (level >= 40) availableBossTypes.push('cosmos', 'infinity');
            
            const bossType = availableBossTypes[Math.floor(Math.random() * availableBossTypes.length)];
            const dynamicDiff = getDynamicDifficulty(); // ä½¿ç”¨å‹•æ…‹é›£åº¦
            
            // é­”ç‹æŒ‘æˆ°æ¨¡å¼å¢å¼·Bosså±¬æ€§
            const bossMultiplier = difficulty === 'boss' ? 2.5 : 1;
            
            let boss = {
                x: Math.random() * (canvas.width - 200) + 100,
                y: -150,
                width: 150,
                height: 100,
                type: bossType,
                health: Math.ceil(50 * dynamicDiff.enemyHealthMultiplier * (1 + level * 0.1) * bossMultiplier),
                maxHealth: Math.ceil(50 * dynamicDiff.enemyHealthMultiplier * (1 + level * 0.1) * bossMultiplier),
                speed: 2 * dynamicDiff.enemySpeedMultiplier,
                fireRate: difficulty === 'boss' ? 800 : 1000, // é­”ç‹æŒ‘æˆ°æ¨¡å¼æ›´å¿«æ”»æ“Šé€Ÿåº¦
                lastFire: 0,
                moveTimer: 0,
                credits: 300,
                points: 2000,
                pattern: 0
            };
            
            switch (bossType) {
                case 'laser':
                    boss.color = '#ff00ff';
                    boss.name = 'æ¿€å…‰å·¨ç¸';
                    boss.fireRate = 800;
                    break;
                case 'missile':
                    boss.color = '#ff4400';
                    boss.name = 'é£›å½ˆè¦å¡';
                    boss.fireRate = 1200;
                    break;
                case 'shield':
                    boss.color = '#0088ff';
                    boss.name = 'è­·ç›¾å®ˆè¡›';
                    boss.health *= 1.5;
                    boss.maxHealth *= 1.5;
                    boss.shield = 50;
                    boss.maxShield = 50;
                    break;
                case 'teleport':
                    boss.color = '#aa00ff';
                    boss.name = 'æ™‚ç©ºæ¼«éŠè€…';
                    boss.teleportTimer = 0;
                    boss.fireRate = 600;
                    break;
                case 'berserker':
                    boss.color = '#cc0000';
                    boss.name = 'ç‹‚æš´çµæ‰‹';
                    boss.health *= 1.3;
                    boss.maxHealth *= 1.3;
                    boss.enrageThreshold = boss.maxHealth * 0.3;
                    boss.isEnraged = false;
                    boss.fireRate = 800;
                    break;
                case 'fortress':
                    boss.color = '#666666';
                    boss.name = 'éµå£è¦å¡';
                    boss.width = 200;
                    boss.height = 120;
                    boss.health *= 2;
                    boss.maxHealth *= 2;
                    boss.armor = Math.ceil(20 * dynamicDiff.enemyHealthMultiplier);
                    boss.turrets = 4;
                    boss.fireRate = 400;
                    break;
                case 'phantom':
                    boss.color = '#440088';
                    boss.name = 'å¹»å½±ä¸»å®—';
                    boss.phaseTimer = 0;
                    boss.isPhased = false;
                    boss.phaseDuration = 3000;
                    boss.fireRate = 500;
                    break;
                case 'dreadnought':
                    boss.color = '#ff4400';
                    boss.name = 'ç„¡ç•æˆ°è‰¦';
                    boss.width = 180;
                    boss.height = 100;
                    boss.health *= 2.5;
                    boss.maxHealth *= 2.5;
                    boss.canShootMissiles = true;
                    boss.missileTimer = 0;
                    boss.fireRate = 600;
                    break;
                case 'voidlord':
                    boss.color = '#330066';
                    boss.name = 'è™›ç©ºé ˜ä¸»';
                    boss.health *= 1.8;
                    boss.maxHealth *= 1.8;
                    boss.voidBeamTimer = 0;
                    boss.summonTimer = 0;
                    boss.fireRate = 700;
                    break;
                case 'omega':
                    boss.color = '#ffaa00';
                    boss.name = 'çµ‚æ¥µæ©Ÿç”²';
                    boss.width = 220;
                    boss.height = 140;
                    boss.health *= 3;
                    boss.maxHealth *= 3;
                    boss.shield = Math.ceil(30 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.weaponSystems = ['laser', 'missile', 'beam'];
                    boss.systemCooldowns = {laser: 0, missile: 0, beam: 0};
                    boss.fireRate = 300;
                    break;
                case 'nemesis':
                    boss.color = '#ff0088';
                    boss.name = 'è‡´å‘½å¤©æ•µ';
                    boss.width = 160;
                    boss.height = 100;
                    boss.health *= 2.2;
                    boss.maxHealth *= 2.2;
                    boss.shield = Math.ceil(25 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.abilities = ['teleport', 'multishot', 'shield_regen', 'time_slow'];
                    boss.abilityTimer = 0;
                    boss.fireRate = 400;
                    break;
                case 'apocalypse':
                    boss.color = '#660000';
                    boss.name = 'æœ«æ—¥å¯©åˆ¤';
                    boss.width = 300;
                    boss.height = 180;
                    boss.health *= 4;
                    boss.maxHealth *= 4;
                    boss.shield = Math.ceil(50 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.phases = ['normal', 'rage', 'final'];
                    boss.currentPhase = 0;
                    boss.fireRate = 250;
                    break;
                case 'titan':
                    boss.color = '#cc6600';
                    boss.name = 'æ³°å¦å·¨ç¸';
                    boss.width = 250;
                    boss.height = 200;
                    boss.health *= 5;
                    boss.maxHealth *= 5;
                    boss.armor = Math.ceil(40 * dynamicDiff.enemyHealthMultiplier);
                    boss.groundSlam = true;
                    boss.slamTimer = 0;
                    boss.fireRate = 1000;
                    break;
                case 'leviathan':
                    boss.color = '#004488';
                    boss.name = 'æ·±æ·µåˆ©ç¶­å¦';
                    boss.width = 320;
                    boss.height = 150;
                    boss.health *= 6;
                    boss.maxHealth *= 6;
                    boss.tentacles = 6;
                    boss.tentacleAttack = true;
                    boss.whirlpool = true;
                    boss.fireRate = 400;
                    break;
                case 'phoenix':
                    boss.color = '#ff6600';
                    boss.name = 'ä¸æ­»ç«é³³';
                    boss.width = 180;
                    boss.height = 120;
                    boss.health *= 3;
                    boss.maxHealth *= 3;
                    boss.canRevive = true;
                    boss.reviveTimer = 0;
                    boss.fireTrail = true;
                    boss.burnAura = true;
                    boss.fireRate = 500;
                    break;
                case 'emperor':
                    boss.color = '#aa0088';
                    boss.name = 'æ˜ŸåŸŸçš‡å¸';
                    boss.width = 280;
                    boss.height = 200;
                    boss.health *= 7;
                    boss.maxHealth *= 7;
                    boss.shield = Math.ceil(100 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.commandAura = true;
                    boss.royalGuard = true;
                    boss.fireRate = 200;
                    break;
                case 'worldeater':
                    boss.color = '#220022';
                    boss.name = 'ä¸–ç•Œåå™¬è€…';
                    boss.width = 400;
                    boss.height = 250;
                    boss.health *= 10;
                    boss.maxHealth *= 10;
                    boss.devourAttack = true;
                    boss.realityWarp = true;
                    boss.darkMatter = true;
                    boss.fireRate = 300;
                    break;
                case 'cosmos':
                    boss.color = '#8800ff';
                    boss.name = 'å®‡å®™æ„å¿—';
                    boss.width = 350;
                    boss.height = 300;
                    boss.health *= 12;
                    boss.maxHealth *= 12;
                    boss.shield = Math.ceil(200 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.cosmicPower = true;
                    boss.starforge = true;
                    boss.timeControl = true;
                    boss.fireRate = 150;
                    break;
                case 'infinity':
                    boss.color = '#ffffff';
                    boss.name = 'ç„¡é™å­˜åœ¨';
                    boss.width = 500;
                    boss.height = 400;
                    boss.health *= 20;
                    boss.maxHealth *= 20;
                    boss.shield = Math.ceil(500 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.infiniteRegeneration = true;
                    boss.omnipresence = true;
                    boss.realityControl = true;
                    boss.fireRate = 100;
                    break;
            }
            
            bosses.push(boss);
        }
        
        // æ•µäººå°„æ“Šç³»çµ±
        function enemyFire(enemy) {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const enemyCenterX = enemy.x + enemy.width / 2;
            const enemyCenterY = enemy.y + enemy.height / 2;
            
            // æª¢æŸ¥å°„ç¨‹
            if (enemy.range) {
                const distance = Math.sqrt(Math.pow(playerCenterX - enemyCenterX, 2) + Math.pow(playerCenterY - enemyCenterY, 2));
                if (distance > enemy.range) return;
            }
            
            switch (enemy.type) {
                case 'sniper':
                    // ç‹™æ“Šæ‰‹ - ç²¾æº–å°„æ“Š
                    const sniperAngle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX);
                    createEnemyBullet(enemyCenterX, enemyCenterY + 20, sniperAngle, '#00ff88', 'sniper');
                    break;
                    
                case 'destroyer':
                    // æ¯€æ»…è€… - å¤šç™¼æ•£å°„
                    for (let i = 0; i < enemy.multiShot; i++) {
                        const angle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX) + (i - 1) * 0.3;
                        createEnemyBullet(enemyCenterX + (i - 1) * 15, enemyCenterY + 30, angle, '#ff4400', 'destroyer');
                    }
                    break;
                    
                case 'nemesis':
                    // å¤©æ•µ - è¿½è¹¤å½ˆ
                    const nemesisAngle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX);
                    createEnemyBullet(enemyCenterX, enemyCenterY + 30, nemesisAngle, '#ff0088', 'homing');
                    break;
                    
                case 'reaper':
                    // æ­»ç¥ - é®åˆ€æ”»æ“Š
                    if (enemy.scytheAttack) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX) + (i - 1) * 0.5;
                            createEnemyBullet(enemyCenterX, enemyCenterY + 20, angle, '#000000', 'scythe');
                        }
                    }
                    break;
                    
                case 'overlord':
                    // çµ±æ²»è€… - èƒ½é‡çƒ
                    const overlordAngle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX);
                    createEnemyBullet(enemyCenterX, enemyCenterY + 30, overlordAngle, '#6600cc', 'energy');
                    break;
            }
        }
        
        // å‰µå»ºæ•µäººå­å½ˆ
        function createEnemyBullet(x, y, angle, color, type) {
            const bullet = {
                x: x - 3,
                y: y,
                width: 6,
                height: 8,
                speed: type === 'sniper' ? 6 : type === 'scythe' ? 5 : 4,
                angle: angle,
                color: color,
                type: type,
                damage: type === 'sniper' ? 20 : type === 'destroyer' ? 15 : type === 'scythe' ? 18 : 12,
                isEnemyBullet: true
            };
            
            if (type === 'homing') {
                bullet.homingStrength = 0.05;
                bullet.speed = 3;
            }
            
            bossBullets.push(bullet); // ä½¿ç”¨ç¾æœ‰çš„bossBulletsé™£åˆ—
        }

        // Bosså°„æ“Šç³»çµ±
        function bossFire(boss) {
            const now = Date.now();
            if (now - boss.lastFire < boss.fireRate) return;
            
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const bossCenterX = boss.x + boss.width / 2;
            const bossCenterY = boss.y + boss.height / 2;
            
            switch (boss.type) {
                case 'laser':
                    // æ¿€å…‰æƒå°„
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        const spread = (i - 2) * 0.3;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle + spread, '#ff00ff', 'laser');
                    }
                    break;
                case 'missile':
                    // è¿½è¹¤é£›å½ˆ
                    const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                    for (let i = 0; i < 3; i++) {
                        createBossBullet(bossCenterX + (i - 1) * 30, bossCenterY + 50, angle, '#ff4400', 'missile');
                    }
                    break;
                case 'shield':
                    // ç’°å½¢æ”»æ“Š
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4) + (now * 0.005);
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, '#0088ff', 'ring');
                    }
                    break;
                case 'teleport':
                    // éš¨æ©Ÿå°„æ“Š
                    for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        createBossBullet(bossCenterX + Math.random() * 60 - 30, bossCenterY + 50, angle, '#aa00ff', 'chaos');
                    }
                    break;
                case 'berserker':
                    // ç‹‚æš´æ”»æ“Š - ç‹‚æš´ç‹€æ…‹ä¸‹æ”»æ“Šæ›´å¼·
                    const shotCount = boss.isEnraged ? 12 : 6;
                    const spread = boss.isEnraged ? 0.4 : 0.2;
                    for (let i = 0; i < shotCount; i++) {
                        const baseAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        const angle = baseAngle + (i - shotCount/2) * spread;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, boss.isEnraged ? '#ff6666' : '#cc0000', 'berserker');
                    }
                    break;
                case 'fortress':
                    // å¤šç‚®å°æ”»æ“Š
                    for (let i = 0; i < boss.turrets; i++) {
                        const turretX = bossCenterX + (i - boss.turrets/2 + 0.5) * 50;
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - turretX);
                        createBossBullet(turretX, bossCenterY + 60, angle, '#888888', 'turret');
                    }
                    break;
                case 'phantom':
                    // å¹»å½±æ”»æ“Š - åªæœ‰éç›¸ä½ç‹€æ…‹ä¸‹æ‰æ”»æ“Š
                    if (!boss.isPhased) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#880088', 'phantom');
                        }
                    }
                    break;
                case 'dreadnought':
                    // ç„¡ç•æˆ°è‰¦ - ä¸»ç‚®å’Œå°å½ˆ
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (i - 2) * 0.15;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff6600', 'cannon');
                    }
                    // å°å½ˆæ”»æ“Š
                    if (boss.canShootMissiles) {
                        boss.missileTimer += now - boss.lastFire;
                        if (boss.missileTimer > 2000) {
                            for (let i = 0; i < 3; i++) {
                                createBossBullet(bossCenterX + (i - 1) * 60, bossCenterY + 30, 0, '#ff4400', 'missile');
                            }
                            boss.missileTimer = 0;
                        }
                    }
                    break;
                case 'voidlord':
                    // è™›ç©ºé ˜ä¸» - è™›ç©ºå…‰æŸå’Œæ™®é€šæ”»æ“Š
                    boss.voidBeamTimer += now - boss.lastFire;
                    if (boss.voidBeamTimer > 4000) {
                        // è™›ç©ºå…‰æŸ
                        const beamAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        for (let i = 0; i < 12; i++) {
                            createBossBullet(bossCenterX, bossCenterY + 50, beamAngle + (i - 6) * 0.05, '#330066', 'voidbeam');
                        }
                        boss.voidBeamTimer = 0;
                    } else {
                        // æ™®é€šæ”»æ“Š
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3) + (now * 0.003);
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#6600cc', 'void');
                        }
                    }
                    break;
                case 'omega':
                    // çµ‚æ¥µæ©Ÿç”² - å¤šç¨®æ­¦å™¨ç³»çµ±
                    boss.weaponSystems.forEach(system => {
                        boss.systemCooldowns[system] += now - boss.lastFire;
                    });
                    
                    if (boss.systemCooldowns.laser > 1000) {
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI / 5) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY + 70, angle, '#ffff00', 'omegalaser');
                        }
                        boss.systemCooldowns.laser = 0;
                    }
                    
                    if (boss.systemCooldowns.missile > 1500) {
                        for (let i = 0; i < 6; i++) {
                            createBossBullet(bossCenterX + (i - 2.5) * 30, bossCenterY + 50, 0, '#ff6600', 'omegamissile');
                        }
                        boss.systemCooldowns.missile = 0;
                    }
                    
                    if (boss.systemCooldowns.beam > 3000) {
                        const beamAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        for (let i = 0; i < 20; i++) {
                            createBossBullet(bossCenterX, bossCenterY + 70, beamAngle + (i - 10) * 0.03, '#ffaa00', 'omegabeam');
                        }
                        boss.systemCooldowns.beam = 0;
                    }
                    break;
                case 'nemesis':
                    // è‡´å‘½å¤©æ•µ - éš¨æ©Ÿèƒ½åŠ›æ”»æ“Š
                    const randomPattern = Math.floor(Math.random() * 4);
                    
                    switch (randomPattern) {
                        case 0:
                            // è¿½è¹¤å½ˆé›¨
                            for (let i = 0; i < 8; i++) {
                                const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (Math.random() - 0.5) * 0.8;
                                createBossBullet(bossCenterX + (Math.random() - 0.5) * 80, bossCenterY + 50, angle, '#ff0088', 'nemesishoming');
                            }
                            break;
                        case 1:
                            // å…¨æ–¹ä½æ”»æ“Š
                            for (let i = 0; i < 16; i++) {
                                const angle = (i * Math.PI / 8);
                                createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff0088', 'nemesisring');
                            }
                            break;
                        case 2:
                            // é›†ä¸­æ”»æ“Š
                            const targetAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                            for (let i = 0; i < 12; i++) {
                                createBossBullet(bossCenterX, bossCenterY + 50, targetAngle + (i - 5.5) * 0.1, '#ff0088', 'nemesisbeam');
                            }
                            break;
                        case 3:
                            // æ™‚é–“ç·©æ…¢æ”»æ“Š
                            for (let i = 0; i < 6; i++) {
                                const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (i - 2.5) * 0.3;
                                createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff0088', 'timeslow');
                            }
                            break;
                    }
                    break;
                case 'apocalypse':
                    // æœ«æ—¥å¯©åˆ¤ - æ ¹æ“šéšæ®µä¸åŒæ”»æ“Š
                    const healthPercent = boss.health / boss.maxHealth;
                    
                    if (healthPercent > 0.66) {
                        // ç¬¬ä¸€éšæ®µ
                        for (let i = 0; i < 20; i++) {
                            const angle = (i * Math.PI / 10) + (now * 0.005);
                            createBossBullet(bossCenterX, bossCenterY + 90, angle, '#660000', 'apocalypse1');
                        }
                    } else if (healthPercent > 0.33) {
                        // ç¬¬äºŒéšæ®µ
                        boss.currentPhase = 1;
                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            createBossBullet(bossCenterX + (Math.random() - 0.5) * 200, bossCenterY + 90, angle, '#990000', 'apocalypse2');
                        }
                    } else {
                        // æœ€çµ‚éšæ®µ
                        boss.currentPhase = 2;
                        for (let i = 0; i < 24; i++) {
                            const angle = (i * Math.PI / 12) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY + 90, angle, '#cc0000', 'apocalypsefinal');
                        }
                    }
                    break;
                case 'titan':
                    // æ³°å¦å·¨ç¸ - é‡å‹æ”»æ“Š
                    for (let i = 0; i < 8; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (i - 3.5) * 0.2;
                        createBossBullet(bossCenterX, bossCenterY + 100, angle, '#cc6600', 'titan');
                    }
                    
                    // åœ°é¢éœ‡æ“Š
                    if (boss.groundSlam) {
                        boss.slamTimer += now - boss.lastFire;
                        if (boss.slamTimer > 5000) {
                            // éœ‡æ³¢æ”»æ“Š
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
                                createBossBullet(bossCenterX + Math.cos(angle) * 60, bossCenterY + Math.sin(angle) * 60, angle + Math.PI, '#cc6600', 'shockwave');
                            }
                            boss.slamTimer = 0;
                        }
                    }
                    break;
                case 'leviathan':
                    // æ·±æ·µåˆ©ç¶­å¦ - è§¸æ‰‹æ”»æ“Š
                    for (let i = 0; i < boss.tentacles; i++) {
                        const tentacleAngle = (i * Math.PI * 2 / boss.tentacles) + (now * 0.01);
                        const tentacleX = bossCenterX + Math.cos(tentacleAngle) * 100;
                        const tentacleY = bossCenterY + Math.sin(tentacleAngle) * 50;
                        
                        const angle = Math.atan2(playerCenterY - tentacleY, playerCenterX - tentacleX);
                        createBossBullet(tentacleX, tentacleY, angle, '#004488', 'tentacle');
                    }
                    
                    // æ¼©æ¸¦æ”»æ“Š
                    if (boss.whirlpool && Math.random() < 0.3) {
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * Math.PI / 6) + (now * 0.02);
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#0066aa', 'whirlpool');
                        }
                    }
                    break;
                case 'phoenix':
                    // ä¸æ­»ç«é³³ - ç«ç„°æ”»æ“Š
                    for (let i = 0; i < 10; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (Math.random() - 0.5) * 1.0;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff6600', 'firebird');
                    }
                    
                    // ç«ç„°è»Œè·¡
                    if (boss.fireTrail) {
                        for (let i = 0; i < 5; i++) {
                            createBossBullet(bossCenterX + (Math.random() - 0.5) * boss.width, bossCenterY + boss.height, Math.PI/2, '#ff4400', 'firetrail');
                        }
                    }
                    break;
                case 'emperor':
                    // æ˜ŸåŸŸçš‡å¸ - çš‡å®¶æ”»æ“Š
                    for (let i = 0; i < 16; i++) {
                        const angle = (i * Math.PI / 8) + (now * 0.005);
                        const radius = 80 + Math.sin(now * 0.01) * 20;
                        createBossBullet(bossCenterX + Math.cos(angle) * radius, bossCenterY + Math.sin(angle) * radius, angle + Math.PI, '#aa0088', 'royal');
                    }
                    
                    // çš‡å®¶è­·è¡›å¬å–š
                    if (boss.royalGuard && Math.random() < 0.1) {
                        for (let i = 0; i < 2; i++) {
                            const summon = {
                                x: bossCenterX + (i - 0.5) * 200,
                                y: bossCenterY + 100,
                                width: 40,
                                height: 40,
                                speed: 2,
                                health: 10,
                                maxHealth: 10,
                                color: '#cc66aa',
                                points: 200,
                                credits: 25,
                                type: 'royalguard'
                            };
                            enemies.push(summon);
                        }
                    }
                    break;
                case 'worldeater':
                    // ä¸–ç•Œåå™¬è€… - æ¯€æ»…æ”»æ“Š
                    for (let i = 0; i < 32; i++) {
                        const angle = (i * Math.PI / 16) + (now * 0.003);
                        createBossBullet(bossCenterX, bossCenterY + 125, angle, '#220022', 'devour');
                    }
                    
                    // ç¾å¯¦æ‰­æ›²
                    if (boss.realityWarp && Math.random() < 0.2) {
                        for (let i = 0; i < 8; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            createBossBullet(Math.random() * canvas.width, bossCenterY + 50, angle, '#440044', 'warp');
                        }
                    }
                    break;
                case 'cosmos':
                    // å®‡å®™æ„å¿— - å®‡å®™ç´šæ”»æ“Š
                    for (let i = 0; i < 40; i++) {
                        const angle = (i * Math.PI / 20) + (now * 0.008);
                        const radius = 120 + Math.cos(now * 0.02 + i) * 40;
                        createBossBullet(bossCenterX + Math.cos(angle) * radius, bossCenterY + Math.sin(angle) * radius, angle + Math.PI, '#8800ff', 'cosmic');
                    }
                    
                    // æ˜Ÿè¾°å‰µé€ 
                    if (boss.starforge && Math.random() < 0.15) {
                        for (let i = 0; i < 6; i++) {
                            createBossBullet(bossCenterX + (Math.random() - 0.5) * 300, bossCenterY + (Math.random() - 0.5) * 200, Math.random() * Math.PI * 2, '#ffaa88', 'star');
                        }
                    }
                    break;
                case 'infinity':
                    // ç„¡é™å­˜åœ¨ - çµ‚æ¥µæ”»æ“Š
                    for (let i = 0; i < 64; i++) {
                        const angle = (i * Math.PI / 32) + (now * 0.01);
                        const wave = Math.sin(now * 0.03 + i * 0.5);
                        const radius = 150 + wave * 60;
                        createBossBullet(bossCenterX + Math.cos(angle) * radius, bossCenterY + Math.sin(angle) * radius, angle + Math.PI + wave, '#ffffff', 'infinity');
                    }
                    
                    // ç¾å¯¦æ§åˆ¶
                    if (boss.realityControl && Math.random() < 0.1) {
                        for (let i = 0; i < 12; i++) {
                            const x = Math.random() * canvas.width;
                            const y = Math.random() * canvas.height * 0.7;
                            const angle = Math.atan2(playerCenterY - y, playerCenterX - x);
                            createBossBullet(x, y, angle, '#ccccff', 'reality');
                        }
                    }
                    break;
            }
            
            boss.lastFire = now;
        }
        
        // å‰µå»ºBosså­å½ˆ
        function createBossBullet(x, y, angle, color, type) {
            bossBullets.push({
                x: x,
                y: y,
                width: 8,
                height: 8,
                speed: type === 'missile' ? 4 : 3,
                angle: angle,
                color: color,
                type: type,
                damage: 15
            });
        }
        
        // å‹•æ…‹é›£åº¦ç³»çµ± - æ ¹æ“šæ­¦å™¨ç­‰ç´šå’ŒéŠæˆ²ç­‰ç´šèª¿æ•´
        function getDynamicDifficulty() {
            const baseDiff = difficultySettings[difficulty];
            const weaponTier = getWeaponTier(equippedWeapon);
            const levelMultiplier = 1 + (level * 0.02); // æ¯ç´šå¢åŠ 2%é›£åº¦
            const weaponMultiplier = 1 + (weaponTier * 0.1); // æ¯æ­¦å™¨éšç´šå¢åŠ 10%é›£åº¦
            
            return {
                enemySpeedMultiplier: baseDiff.enemySpeedMultiplier * levelMultiplier * weaponMultiplier,
                enemyHealthMultiplier: baseDiff.enemyHealthMultiplier * levelMultiplier * weaponMultiplier,
                enemySpawnRate: baseDiff.enemySpawnRate * (1 + level * 0.03), // ç”Ÿæˆç‡å¢åŠ æ›´æ˜é¡¯
                playerDamageMultiplier: baseDiff.playerDamageMultiplier,
                creditMultiplier: baseDiff.creditMultiplier
            };
        }
        
        // ç²å–æ­¦å™¨éšç´š
        function getWeaponTier(weaponId) {
            const weaponTiers = {
                'basic': 0,
                'rapid': 1,
                'heavy': 2,
                'spread': 3,
                'piercing': 4,
                'elemental': 5
            };
            return weaponTiers[weaponId] || 0;
        }

        // ç”Ÿæˆæ•µäºº - æ“´å±•ç‰ˆæœ¬
        function spawnEnemy() {
            // æ ¹æ“šç­‰ç´šè§£é–ä¸åŒæ•µäººé¡å‹
            let availableTypes = ['basic', 'fast', 'heavy'];
            
            if (level >= 3) availableTypes.push('Thornspine');
            if (level >= 5) availableTypes.push('bomber', 'assassin');
            if (level >= 8) availableTypes.push('tank', 'sniper');
            if (level >= 12) availableTypes.push('phantom', 'berserker');
            if (level >= 16) availableTypes.push('destroyer', 'voidwalker');
            if (level >= 20) availableTypes.push('nemesis', 'guardian');
            if (level >= 25) availableTypes.push('reaper', 'titan');
            if (level >= 30) availableTypes.push('overlord', 'phoenix');
            
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const dynamicDiff = getDynamicDifficulty();
            
            let enemy = {
                x: Math.random() * (canvas.width - 40),
                y: -40,
                type: type
            };
            
            switch (type) {
                case 'basic':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.speed = (2 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(2 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff4444';
                    enemy.points = 100;
                    enemy.credits = 15;
                    break;
                case 'fast':
                    enemy.width = 30;
                    enemy.height = 30;
                    enemy.speed = (4 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(1 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#44ff44';
                    enemy.points = 150;
                    enemy.credits = 20;
                    break;
                case 'heavy':
                    enemy.width = 60;
                    enemy.height = 60;
                    enemy.speed = (1 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(5 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#4444ff';
                    enemy.points = 300;
                    enemy.credits = 35;
                    break;
                case 'Thornspine':
                    enemy.width = 80;
                    enemy.height = 80;
                    enemy.speed = (1.5 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(8 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ffffff';
                    enemy.points = 500;
                    enemy.credits = 60;
                    break;
                case 'bomber':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.speed = (1.8 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(4 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff8800';
                    enemy.points = 250;
                    enemy.credits = 35;
                    enemy.explodeOnDeath = true;
                    enemy.explosionRadius = 60;
                    break;
                case 'assassin':
                    enemy.width = 25;
                    enemy.height = 25;
                    enemy.speed = (6 + level * 0.3) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(1.5 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#8800ff';
                    enemy.points = 200;
                    enemy.credits = 30;
                    enemy.zigzagPattern = true;
                    enemy.moveTimer = 0;
                    break;
                case 'tank':
                    enemy.width = 70;
                    enemy.height = 70;
                    enemy.speed = (1 + level * 0.08) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(15 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#666666';
                    enemy.points = 400;
                    enemy.credits = 50;
                    enemy.armor = Math.ceil(3 * dynamicDiff.enemyHealthMultiplier);
                    break;
                case 'sniper':
                    enemy.width = 45;
                    enemy.height = 45;
                    enemy.speed = (2.5 + level * 0.15) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(6 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#00ff88';
                    enemy.points = 350;
                    enemy.credits = 45;
                    enemy.canShoot = true;
                    enemy.fireRate = 2000;
                    enemy.lastFire = 0;
                    enemy.range = 400;
                    break;
                case 'phantom':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.speed = (3 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(7 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#aa00aa';
                    enemy.points = 450;
                    enemy.credits = 55;
                    enemy.phaseTimer = 0;
                    enemy.isPhased = false;
                    enemy.phaseDuration = 2000;
                    break;
                case 'berserker':
                    enemy.width = 55;
                    enemy.height = 55;
                    enemy.speed = (2.5 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(12 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff0000';
                    enemy.points = 500;
                    enemy.credits = 65;
                    enemy.enrageThreshold = Math.ceil(4 * dynamicDiff.enemyHealthMultiplier);
                    enemy.isEnraged = false;
                    break;
                case 'destroyer':
                    enemy.width = 90;
                    enemy.height = 70;
                    enemy.speed = (1.5 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(20 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff4400';
                    enemy.points = 700;
                    enemy.credits = 85;
                    enemy.canShoot = true;
                    enemy.fireRate = 1500;
                    enemy.lastFire = 0;
                    enemy.multiShot = 3;
                    break;
                case 'voidwalker':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.speed = (3.5 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(10 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#330066';
                    enemy.points = 600;
                    enemy.credits = 75;
                    enemy.teleportTimer = 0;
                    enemy.canTeleport = true;
                    enemy.teleportCooldown = 3000;
                    break;
                case 'nemesis':
                    enemy.width = 85;
                    enemy.height = 65;
                    enemy.speed = (2.8 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(25 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff0088';
                    enemy.points = 1000;
                    enemy.credits = 120;
                    enemy.shield = Math.ceil(8 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxShield = enemy.shield;
                    enemy.canShoot = true;
                    enemy.fireRate = 1200;
                    enemy.lastFire = 0;
                    break;
                case 'guardian':
                    enemy.width = 100;
                    enemy.height = 80;
                    enemy.speed = (1.2 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(35 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#00aaff';
                    enemy.points = 1200;
                    enemy.credits = 150;
                    enemy.shield = Math.ceil(15 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxShield = enemy.shield;
                    enemy.shieldRegen = 0.5;
                    enemy.healingAura = true;
                    enemy.auraRadius = 100;
                    break;
                case 'reaper':
                    enemy.width = 60;
                    enemy.height = 80;
                    enemy.speed = (4 + level * 0.25) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(18 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#000000';
                    enemy.points = 1500;
                    enemy.credits = 180;
                    enemy.canShoot = true;
                    enemy.fireRate = 800;
                    enemy.lastFire = 0;
                    enemy.scytheAttack = true;
                    enemy.drainLife = true;
                    break;
                case 'titan':
                    enemy.width = 150;
                    enemy.height = 120;
                    enemy.speed = (0.8 + level * 0.05) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(60 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#cc6600';
                    enemy.points = 2000;
                    enemy.credits = 250;
                    enemy.armor = Math.ceil(10 * dynamicDiff.enemyHealthMultiplier);
                    enemy.canShoot = true;
                    enemy.fireRate = 2000;
                    enemy.lastFire = 0;
                    enemy.groundSlam = true;
                    break;
                case 'overlord':
                    enemy.width = 120;
                    enemy.height = 90;
                    enemy.speed = (2 + level * 0.15) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(40 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#6600cc';
                    enemy.points = 2500;
                    enemy.credits = 300;
                    enemy.canSummon = true;
                    enemy.summonTimer = 0;
                    enemy.summonCooldown = 5000;
                    enemy.canShoot = true;
                    enemy.fireRate = 1000;
                    enemy.lastFire = 0;
                    break;
                case 'phoenix':
                    enemy.width = 75;
                    enemy.height = 75;
                    enemy.speed = (3.5 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(30 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff6600';
                    enemy.points = 3000;
                    enemy.credits = 400;
                    enemy.canRevive = true;
                    enemy.reviveTimer = 0;
                    enemy.reviveHealth = Math.ceil(15 * dynamicDiff.enemyHealthMultiplier);
                    enemy.fireTrail = true;
                    enemy.burnDamage = true;
                    break;
            }
            
            enemies.push(enemy);
        }
        
        // ç”Ÿæˆé“å…·
        function spawnPowerup(x, y, isBoss = false) {
            let dropChance = 0.6;
            if (difficulty === 'boss') {
                dropChance = isBoss ? 1.0 : 0.9;
            }
            
            if (Math.random() < dropChance) { // å¢åŠ é“å…·æ‰è½æ©Ÿç‡åˆ°60%
                const types = ['health', 'maxhealth']; // åªä¿ç•™è£œè¡€å’Œå¢åŠ è¡€é‡ä¸Šé™
                const weights = [0.8, 0.2]; // è£œè¡€80%æ©Ÿç‡ï¼Œå¢åŠ è¡€é‡ä¸Šé™20%æ©Ÿç‡
                
                // æ ¹æ“šæ¬Šé‡é¸æ“‡é“å…·é¡å‹
                let selectedType;
                if (difficulty === 'boss') {
                    selectedType = Math.random() < 0.9 ? 'health' : 'maxhealth';
                } else {
                    selectedType = Math.random() < 0.8 ? 'health' : 'maxhealth';
                }
                
                let dropCount = 1;
                if (difficulty === 'boss' && isBoss) {
                    dropCount = Math.floor(Math.random() * 3) + 2;
                }
                
                for (let i = 0; i < dropCount; i++) {
                    powerups.push({
                        x: x + (Math.random() - 0.5) * 60,
                        y: y + (Math.random() - 0.5) * 40,
                        width: 25,
                        height: 25,
                        type: selectedType,
                        speed: 2 + Math.random(),
                        rotation: 0
                    });
                }
            }
        }
        
        // å‰µå»ºç²’å­æ•ˆæœ
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // çˆ†ç‚¸æ•ˆæœ
        function createExplosion(x, y) {
            // å°é™„è¿‘æ•µäººé€ æˆå‚·å®³
            enemies.forEach((enemy, index) => {
                const dx = (enemy.x + enemy.width/2) - x;
                const dy = (enemy.y + enemy.height/2) - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) { // çˆ†ç‚¸ç¯„åœ
                    const damage = Math.max(1, Math.ceil((80 - distance) / 10));
                    enemy.health -= damage;
                    createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff4400', 3);
                    
                    if (enemy.health <= 0) {
                        score += enemy.points;
                        const dynamicDiff = getDynamicDifficulty();
                        const creditReward = Math.ceil(enemy.credits * dynamicDiff.creditMultiplier);
                        credits += creditReward;
                        updateCreditsDisplay();
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ffff00', 8);
                        spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        enemies.splice(index, 1);
                    }
                }
            });
            
            // å°ç©å®¶é€ æˆå‚·å®³
            const playerDx = (player.x + player.width/2) - x;
            const playerDy = (player.y + player.height/2) - y;
            const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
            
            if (playerDistance < 60) {
                const damage = Math.max(5, Math.ceil((60 - playerDistance) / 6));
                health -= damage;
                createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 8);
            }
            
            // çˆ†ç‚¸è¦–è¦ºæ•ˆæœ
            createParticles(x, y, '#ff6600', 20);
            createParticles(x, y, '#ffaa00', 15);
            createParticles(x, y, '#ff0000', 10);
        }
        
        // æ›´æ–°éŠæˆ²ç‹€æ…‹
        function update(deltaTime) {
            if (gameState !== 'playing') return;
            
            // é•·æŒ‰å°„æ“Š
            if (keys['Space']) {
                shoot();
            }
            
            // æ›´æ–°ç©å®¶ä½ç½®
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.x = Math.max(0, player.x - player.speed);
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                player.x = Math.min(canvas.width - player.width, player.x + player.speed);
            }
            if (keys['ArrowUp'] || keys['KeyW']) {
                player.y = Math.max(0, player.y - player.speed);
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                player.y = Math.min(canvas.height - player.height, player.y + player.speed);
            }
            
            // æª¢æŸ¥å‹åˆ©æ¢ä»¶
            if (player.powerLevel >= 100) {
                gameState = 'victory';
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalLevel').textContent = level;
                document.getElementById('gameOver').querySelector('h2').textContent = 'ğŸ† æ­å–œé€šé—œï¼ ğŸ†';
                document.getElementById('gameOver').querySelector('h2').style.color = '#00ff00';
                document.getElementById('gameOver').style.display = 'block';
                return;
            }
            
            // æ›´æ–°æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            
            // æ›´æ–°å­å½ˆ
            bullets = bullets.filter(bullet => {
                // æ›´æ–°è»Œè·¡
                bullet.trail.push({x: bullet.x, y: bullet.y});
                if (bullet.trail.length > 5) {
                    bullet.trail.shift();
                }
                
                if (bullet.angle) {
                    bullet.x += Math.sin(bullet.angle) * bullet.speed;
                    bullet.y -= Math.cos(bullet.angle) * bullet.speed;
                } else {
                    bullet.y -= bullet.speed;
                }
                return bullet.y > -50;
            });

            // æ›´æ–°Boss
            bosses.forEach(boss => {
                boss.moveTimer += deltaTime;
                
                // Bossç§»å‹•é‚è¼¯
                if (boss.y < 50) {
                    boss.y += boss.speed;
                } else {
                    // åˆ°é”ä½ç½®å¾Œé–‹å§‹æ©«å‘ç§»å‹•
                    boss.x += Math.sin(boss.moveTimer * 0.002) * boss.speed;
                    boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
                    
                    // ç‰¹æ®Šç§»å‹•æ¨¡å¼
                    if (boss.type === 'teleport') {
                        boss.teleportTimer += deltaTime;
                        if (boss.teleportTimer > 3000) { // æ¯3ç§’ç¬ç§»
                            boss.x = Math.random() * (canvas.width - boss.width);
                            boss.y = Math.random() * 100 + 50;
                            boss.teleportTimer = 0;
                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, boss.color, 10);
                        }
                    }
                }
                
                // Bosså°„æ“Š
                bossFire(boss);
            });

            // æ›´æ–°Bosså­å½ˆ
            bossBullets = bossBullets.filter(bullet => {
                if (bullet.type === 'missile') {
                    // è¿½è¹¤é£›å½ˆ
                    const dx = (player.x + player.width/2) - bullet.x;
                    const dy = (player.y + player.height/2) - bullet.y;
                    const angle = Math.atan2(dy, dx);
                    bullet.x += Math.cos(angle) * bullet.speed;
                    bullet.y += Math.sin(angle) * bullet.speed;
                } else {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                }
                return bullet.x > -50 && bullet.x < canvas.width + 50 && 
                       bullet.y > -50 && bullet.y < canvas.height + 50;
            });
            
            // æ›´æ–°æ•µäººå’Œç‰¹æ®Šèƒ½åŠ›
            enemies.forEach((enemy, enemyIndex) => {
                // åŸºæœ¬ç§»å‹•
                enemy.y += enemy.speed;
                
                // ç‰¹æ®Šèƒ½åŠ›è™•ç†
                switch (enemy.type) {
                    case 'assassin':
                        // åˆºå®¢ - Zå­—å‹ç§»å‹•
                        if (enemy.zigzagPattern) {
                            enemy.moveTimer += deltaTime;
                            enemy.x += Math.sin(enemy.moveTimer * 0.005) * 3;
                            enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
                        }
                        break;
                        
                    case 'phantom':
                        // å¹»å½± - å®šæœŸé€²å…¥ç›¸ä½ç‹€æ…‹
                        enemy.phaseTimer += deltaTime;
                        if (enemy.phaseTimer > enemy.phaseDuration) {
                            enemy.isPhased = !enemy.isPhased;
                            enemy.phaseTimer = 0;
                            if (enemy.isPhased) {
                                createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#aa00aa', 8);
                            }
                        }
                        break;
                        
                    case 'berserker':
                        // ç‹‚æˆ°å£« - ä½è¡€é‡æ™‚ç‹‚æš´
                        if (enemy.health <= enemy.enrageThreshold && !enemy.isEnraged) {
                            enemy.isEnraged = true;
                            enemy.speed *= 1.5;
                            enemy.color = '#ff6666';
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff0000', 15);
                        }
                        break;
                        
                    case 'voidwalker':
                        // è™›ç©ºè¡Œè€… - å®šæœŸç¬ç§»
                        enemy.teleportTimer += deltaTime;
                        if (enemy.teleportTimer > enemy.teleportCooldown && enemy.canTeleport) {
                            const newX = Math.random() * (canvas.width - enemy.width);
                            const newY = Math.max(enemy.y - 80, 50);
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#330066', 10);
                            enemy.x = newX;
                            enemy.y = newY;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#330066', 10);
                            enemy.teleportTimer = 0;
                        }
                        break;
                        
                    case 'guardian':
                        // å®ˆè­·è€… - è­·ç›¾å›å¾©å’Œæ²»ç™‚å…‰ç’°
                        if (enemy.shield < enemy.maxShield) {
                            enemy.shield = Math.min(enemy.maxShield, enemy.shield + enemy.shieldRegen);
                        }
                        
                        // æ²»ç™‚é™„è¿‘æ•µäºº
                        if (enemy.healingAura) {
                            enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy) {
                                    const dx = (otherEnemy.x + otherEnemy.width/2) - (enemy.x + enemy.width/2);
                                    const dy = (otherEnemy.y + otherEnemy.height/2) - (enemy.y + enemy.height/2);
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < enemy.auraRadius && otherEnemy.health < otherEnemy.maxHealth) {
                                        otherEnemy.health = Math.min(otherEnemy.maxHealth, otherEnemy.health + 0.2);
                                        if (Math.random() < 0.1) {
                                            createParticles(otherEnemy.x + otherEnemy.width/2, otherEnemy.y + otherEnemy.height/2, '#00aaff', 2);
                                        }
                                    }
                                }
                            });
                        }
                        break;
                        
                    case 'overlord':
                        // çµ±æ²»è€… - å®šæœŸå¬å–šå°æ€ª
                        enemy.summonTimer += deltaTime;
                        if (enemy.summonTimer > enemy.summonCooldown && enemies.length < 15) {
                            for (let i = 0; i < 2; i++) {
                                const summon = {
                                    x: enemy.x + Math.random() * enemy.width,
                                    y: enemy.y + enemy.height + 10,
                                    width: 20,
                                    height: 20,
                                    speed: 3,
                                    health: 1,
                                    maxHealth: 1,
                                    color: '#9966cc',
                                    points: 50,
                                    credits: 5,
                                    type: 'summoned'
                                };
                                enemies.push(summon);
                            }
                            enemy.summonTimer = 0;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#6600cc', 12);
                        }
                        break;
                        
                    case 'phoenix':
                        // é³³å‡° - æ­»äº¡æ™‚å¾©æ´»
                        if (enemy.health <= 0 && enemy.canRevive && enemy.reviveTimer === 0) {
                            enemy.health = enemy.reviveHealth;
                            enemy.canRevive = false; // åªèƒ½å¾©æ´»ä¸€æ¬¡
                            enemy.color = '#ffaa66';
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff6600', 20);
                        }
                        
                        // ç«ç„°è»Œè·¡
                        if (enemy.fireTrail && Math.random() < 0.3) {
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height, '#ff4400', 2);
                        }
                        break;
                        
                    case 'reaper':
                        // æ­»ç¥ - å¸è¡€æ”»æ“Š
                        if (enemy.drainLife && Math.random() < 0.01) {
                            const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                            const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 150) {
                                health -= 1;
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + 0.5);
                                createParticles((enemy.x + player.x)/2 + 25, (enemy.y + player.y)/2 + 25, '#990000', 3);
                            }
                        }
                        break;
                        
                    case 'titan':
                        // æ³°å¦ - åœ°é¢éœ‡æ“Š
                        if (enemy.groundSlam && enemy.y > canvas.height * 0.3 && Math.random() < 0.005) {
                            // éœ‡æ³¢æ”»æ“Š
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                createParticles(enemy.x + enemy.width/2 + Math.cos(angle) * 50, 
                                              enemy.y + enemy.height/2 + Math.sin(angle) * 50, '#cc6600', 2);
                            }
                            
                            // å°ç©å®¶é€ æˆç¯„åœå‚·å®³
                            const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                            const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 120) {
                                health -= Math.max(1, Math.ceil((120 - distance) / 20));
                                createParticles(player.x + player.width/2, player.y + player.height/2, '#ff6600', 5);
                            }
                        }
                        break;
                }
                
                // å¯å°„æ“Šæ•µäººçš„æ”»æ“Šé‚è¼¯
                if (enemy.canShoot && enemy.fireRate) {
                    const now = Date.now();
                    if (now - enemy.lastFire > enemy.fireRate && enemy.y > 0 && enemy.y < canvas.height - 100) {
                        enemyFire(enemy);
                        enemy.lastFire = now;
                    }
                }
            });
            enemies = enemies.filter(enemy => enemy.y < canvas.height + 50);
            
            // æ›´æ–°é“å…·
            powerups.forEach(powerup => {
                powerup.y += powerup.speed;
                powerup.rotation += 0.1;
            });
            powerups = powerups.filter(powerup => powerup.y < canvas.height + 50);
            
            // æ›´æ–°ç²’å­
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                return particle.life > 0;
            });
            
            // ç¢°æ’æª¢æ¸¬ - å­å½ˆèˆ‡æ•µäºº
            bullets.forEach((bullet, bulletIndex) => {
                let bulletHit = false;
                
                // èˆ‡æ™®é€šæ•µäººçš„ç¢°æ’
                enemies.forEach((enemy, enemyIndex) => {
                    if (!bulletHit && bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        let damage = bullet.damage;
                        let damageBlocked = false;
                        
                        // è™•ç†ç‰¹æ®Šé˜²è­·
                        if (enemy.type === 'phantom' && enemy.isPhased) {
                            // ç›¸ä½ç‹€æ…‹ä¸‹å…ç–«å‚·å®³
                            damage = 0;
                            damageBlocked = true;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#aa00aa', 3);
                        } else if (enemy.shield > 0) {
                            // è­·ç›¾ç³»çµ±
                            const shieldDamage = Math.min(damage, enemy.shield);
                            enemy.shield -= shieldDamage;
                            damage -= shieldDamage;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#00aaff', 2);
                        } else if (enemy.armor && enemy.armor > 0) {
                            // è­·ç”²ç³»çµ±
                            const armorReduction = Math.min(damage, enemy.armor);
                            enemy.armor -= armorReduction;
                            damage = Math.max(0, damage - armorReduction);
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#888888', 2);
                        }
                        
                        if (!damageBlocked) {
                            enemy.health -= damage;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 3);
                        }
                        
                        if (bullet.effect !== 'piercing') {
                            bulletHit = true;
                        } else {
                            bullet.pierced++;
                            if (bullet.pierced >= 3) bulletHit = true; // ç©¿é€æœ€å¤š3å€‹æ•µäºº
                        }
                        
                        if (enemy.health <= 0) {
                            // çˆ†ç‚¸æ•µäººæ­»äº¡æ™‚çˆ†ç‚¸
                            if (enemy.explodeOnDeath) {
                                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            }
                            
                            score += enemy.points;
                            const dynamicDiff = getDynamicDifficulty();
                            const creditReward = Math.ceil(enemy.credits * dynamicDiff.creditMultiplier);
                            credits += creditReward;
                            updateCreditsDisplay();
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ffff00', 8);
                            spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(enemyIndex, 1);
                        }
                    }
                });
                
                // è™•ç†æ•µäººå‚·å®³ï¼ˆç°¡åŒ–ç‰ˆæœ¬ï¼‰
                
                // èˆ‡Bossçš„ç¢°æ’
                bosses.forEach((boss, bossIndex) => {
                    if (!bulletHit && bullet.x < boss.x + boss.width &&
                        bullet.x + bullet.width > boss.x &&
                        bullet.y < boss.y + boss.height &&
                        bullet.y + bullet.height > boss.y) {
                        
                        let damage = bullet.damage;
                        
                        // è­·ç›¾Bossçš„è­·ç›¾æ©Ÿåˆ¶
                        if (boss.type === 'shield' && boss.shield > 0) {
                            boss.shield -= damage;
                            if (boss.shield < 0) {
                                boss.health += boss.shield; // å‰©é¤˜å‚·å®³æ‰“åˆ°è¡€é‡
                                boss.shield = 0;
                            }
                        } else {
                            boss.health -= damage;
                        }
                        
                        if (bullet.effect !== 'piercing') {
                            bulletHit = true;
                        }
                        
                        createParticles(boss.x + boss.width/2, boss.y + boss.height/2, boss.color, 5);
                        
                        if (boss.health <= 0) {
                            score += boss.points;
                            const creditReward = Math.ceil(boss.credits * difficultySettings[difficulty].creditMultiplier);
                            credits += creditReward;
                            updateCreditsDisplay();
                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, '#ffff00', 15);
                            spawnPowerup(boss.x + boss.width/2, boss.y + boss.height/2, true);
                            bosses.splice(bossIndex, 1);
                        }
                    }
                });
                
                if (bulletHit) {
                    bullets.splice(bulletIndex, 1);
                }
            });
            
            // ç¢°æ’æª¢æ¸¬ - ç©å®¶èˆ‡æ•µäºº
            enemies.forEach((enemy, enemyIndex) => {
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    health -= 20;
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 5);
                    enemies.splice(enemyIndex, 1);
                    
                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                        autoSaveGame(); // éŠæˆ²çµæŸæ™‚è‡ªå‹•ä¿å­˜
                    }
                }
            });

            // ç¢°æ’æª¢æ¸¬ - ç©å®¶èˆ‡Bosså­å½ˆ
            bossBullets.forEach((bullet, bulletIndex) => {
                if (player.x < bullet.x + bullet.width &&
                    player.x + player.width > bullet.x &&
                    player.y < bullet.y + bullet.height &&
                    player.y + bullet.height > bullet.y) {
                    
                    health -= bullet.damage;
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 8);
                    bossBullets.splice(bulletIndex, 1);
                    
                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                        autoSaveGame(); // éŠæˆ²çµæŸæ™‚è‡ªå‹•ä¿å­˜
                    }
                }
            });

            // ç¢°æ’æª¢æ¸¬ - ç©å®¶èˆ‡Boss
            bosses.forEach((boss, bossIndex) => {
                if (player.x < boss.x + boss.width &&
                    player.x + player.width > boss.x &&
                    player.y < boss.y + boss.height &&
                    player.y + player.height > boss.y) {
                    
                    health -= 35; // Bossç¢°æ’å‚·å®³
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 10);
                    
                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                        autoSaveGame(); // éŠæˆ²çµæŸæ™‚è‡ªå‹•ä¿å­˜
                    }
                }
            });
            
            // ç¢°æ’æª¢æ¸¬ - ç©å®¶èˆ‡é“å…·
            powerups.forEach((powerup, powerupIndex) => {
                if (player.x < powerup.x + powerup.width &&
                    player.x + player.width > powerup.x &&
                    player.y < powerup.y + powerup.height &&
                    player.y + player.height > powerup.y) {
                    
                    switch (powerup.type) {
                        case 'health':
                            health = Math.min(maxHealth, health + 25);
                            break;
                        case 'maxhealth':
                            maxHealth += 20; // å¢åŠ æœ€å¤§è¡€é‡
                            health = Math.min(maxHealth, health + 15); // åŒæ™‚å›å¾©ä¸€äº›è¡€é‡
                            break;
                    }
                    
                    createParticles(powerup.x + powerup.width/2, powerup.y + powerup.height/2, '#00c3f4', 5);
                    powerups.splice(powerupIndex, 1);
                }
            });
            
            // ç”Ÿæˆæ•µäºº - æ ¹æ“šé›£åº¦æ¨¡å¼èª¿æ•´
            const dynamicDiff = getDynamicDifficulty();
            
            if (difficulty === 'boss') {
                // é­”ç‹æŒ‘æˆ°æ¨¡å¼ - åªç”ŸæˆBOSS
                bossSpawnTimer += deltaTime;
                const bossSpawnInterval = Math.max(3000, 8000 - level * 100); // æ›´çŸ­çš„BOSSç”Ÿæˆé–“éš”
                const maxBosses = Math.min(3, 1 + Math.floor(level / 10)); // åŒæ™‚å¯å­˜åœ¨çš„BOSSæ•¸é‡
                
                if (bossSpawnTimer > bossSpawnInterval && bosses.length < maxBosses) {
                    spawnBoss();
                    bossSpawnTimer = 0;
                }
            } else {
                // ä¸€èˆ¬æ¨¡å¼ - ç”Ÿæˆæ™®é€šæ•µäººå’ŒBOSS
                const baseSpawnRate = 0.015 + level * 0.003;
                const adjustedSpawnRate = baseSpawnRate * dynamicDiff.enemySpawnRate;
                const maxEnemies = Math.min(15, 8 + Math.floor(level / 2)); // æ ¹æ“šç­‰ç´šé™åˆ¶æ•µäººæ•¸é‡
                
                if (Math.random() < adjustedSpawnRate && enemies.length < maxEnemies) {
                    spawnEnemy();
                }

                // Bossç”Ÿæˆé‚è¼¯ - æé«˜ç”Ÿæˆé »ç‡
                bossSpawnTimer += deltaTime;
                const bossSpawnInterval = Math.max(20000, 40000 - level * 1000); // ç­‰ç´šè¶Šé«˜ï¼Œé–“éš”è¶ŠçŸ­
                if (bossSpawnTimer > bossSpawnInterval && bosses.length === 0) {
                    const bossChance = Math.min(0.8, 0.2 + (level * 0.04)); // æœ€é«˜80%æ©Ÿç‡
                    if (Math.random() < bossChance) {
                        spawnBoss();
                        bossSpawnTimer = 0;
                    }
                }
            }
            
            // å‡ç´šç³»çµ± - å¹³è¡¡å‡ç´šæ©Ÿåˆ¶
            const scoreRequiredPerLevel = Math.max(200, 400 - level * 2); // æ—©æœŸå‡ç´šæ›´å®¹æ˜“ï¼Œå¾ŒæœŸæ›´é›£
            const newLevel = Math.floor(score / scoreRequiredPerLevel) + 1;
            if (newLevel > level) {
                level = newLevel;
                player.powerLevel = level; // è®“ç©å®¶æ­¦å™¨ç­‰ç´šè·Ÿè‘—éŠæˆ²ç­‰ç´šæå‡
                health = Math.min(maxHealth, health + 25 + Math.floor(level / 5) * 5); // å‡ç´šå›è¡€éš¨ç­‰ç´šå¢åŠ 
                // å®šæœŸæå‡å°„é€Ÿå’Œæœ€å¤§è¡€é‡
                if (level % 5 === 0) {
                    player.fireRate = Math.max(60, player.fireRate - 15); // æå‡å°„é€Ÿ
                }
                if (level % 10 === 0) {
                    maxHealth += 20; // å¢åŠ è¡€é‡ä¸Šé™
                    health = Math.min(maxHealth, health + 50); // é¡å¤–å›è¡€
                }
                updatePowerupIndicator(); // æ›´æ–°æ­¦å™¨é¡¯ç¤º
                autoSaveGame(); // å‡ç´šæ™‚è‡ªå‹•ä¿å­˜
            }
            
            // æ›´æ–°UI
            document.getElementById('health').textContent = `${health}/${maxHealth}`;
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
        }
        
        function updatePowerupIndicator() {
            const indicator = document.getElementById('powerup-indicator');
            let weaponType = '';
            
            if (player.powerLevel <= 10) {
                weaponType = 'åŸºç¤æ­¦å™¨';
            } else if (player.powerLevel <= 25) {
                const elementTypes = ['ç«å…ƒç´ ', 'å†°å…ƒç´ ', 'é›·å…ƒç´ '];
                const typeIndex = Math.floor((player.powerLevel - 11) / 5);
                weaponType = elementTypes[typeIndex] || 'å…ƒç´ æ­¦å™¨';
            } else if (player.powerLevel <= 50) {
                const energyTypes = ['æ°´è—æ©Ÿå…‰', 'å…‰è¼æ©Ÿé—œæ§', 'å®‡å®™é¢¨æš´'];
                const typeIndex = Math.floor((player.powerLevel - 26) / 8);
                weaponType = energyTypes[typeIndex] || 'èƒ½é‡æ­¦å™¨';
            } else if (player.powerLevel <= 75) {
                const magicTypes = ['å–šæ˜Ÿè¡“', 'æ™‚ç©ºä¸»è»¸ ', 'å½—æ˜Ÿé›¨'];
                const typeIndex = Math.floor((player.powerLevel - 51) / 8);
                weaponType = magicTypes[typeIndex] || 'é­”æ³•æ­¦å™¨';
            } else if (player.powerLevel <= 99) {
                const legendaryTypes = ['å½©è™¹å°„ç·š'];
                const typeIndex = Math.floor((player.powerLevel - 76) / 8);
                weaponType = legendaryTypes[typeIndex] || 'å‚³èªªæ­¦å™¨';
            } else if (player.powerLevel === 100) {
                weaponType = 'ğŸŒŸ çµ‚æ¥µæ­¦å™¨ ğŸŒŸ';
            }
            
            let modeText = difficulty === 'boss' ? 'ğŸ”¥ é­”ç‹æŒ‘æˆ° ğŸ”¥' : difficulty;
            let bossCountText = difficulty === 'boss' ? ` | BOSSæ•¸é‡: ${bosses.length}` : '';
            let text = `æ­¦å™¨ç­‰ç´š: ${player.powerLevel}/100 | ${weaponType} | å°„é€Ÿ: ${(1000/player.fireRate).toFixed(1)}/ç§’ | é›£åº¦: ${modeText}${bossCountText}`;
            indicator.textContent = text;
        }
        
        // ç¹ªè£½éŠæˆ²
        function draw() {
            // æ¸…ç©ºç•«å¸ƒ
            if (difficulty === 'boss') {
                // é­”ç‹æŒ‘æˆ°æ¨¡å¼ - é»‘æš—ç´…è‰²èƒŒæ™¯
                const pulse = Math.sin(Date.now() * 0.003) * 0.05 + 0.1;
                ctx.fillStyle = `rgba(20, 0, 0, ${pulse})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                // ä¸€èˆ¬æ¨¡å¼ - æ·±è—è‰²èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // ç¹ªè£½æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                if (difficulty === 'boss') {
                    // é­”ç‹æŒ‘æˆ°æ¨¡å¼ - ç´…è‰²æ˜Ÿæ˜Ÿ
                    ctx.fillStyle = `rgba(255, 100, 100, ${star.brightness})`;
                } else {
                    // ä¸€èˆ¬æ¨¡å¼ - ç™½è‰²æ˜Ÿæ˜Ÿ
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                }
                ctx.fillRect(star.x, star.y, 2, 2);
            });
            
            if (gameState !== 'playing') return;
            
            // ç¹ªè£½ç©å®¶
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // ç¹ªè£½ç©å®¶ç´°ç¯€
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-5, -player.height/2, 10, 20);
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(-15, player.height/2 - 10, 8, 8);
            ctx.fillRect(7, player.height/2 - 10, 8, 8);
            ctx.restore();
            
            // ç¹ªè£½å­å½ˆ
            bullets.forEach(bullet => {
                // ç¹ªè£½è»Œè·¡
                if (bullet.trail.length > 1 && bullet.effect !== 'normal') {
                    ctx.strokeStyle = bullet.color + '40';
                    ctx.lineWidth = bullet.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(bullet.trail[0].x + bullet.width/2, bullet.trail[0].y + bullet.height/2);
                    for (let i = 1; i < bullet.trail.length; i++) {
                        ctx.lineTo(bullet.trail[i].x + bullet.width/2, bullet.trail[i].y + bullet.height/2);
                    }
                    ctx.stroke();
                }
                
                // æ ¹æ“šç‰¹æ•ˆé¡å‹ç¹ªè£½ä¸åŒæ•ˆæœ
                switch (bullet.effect) {
                    case 'basic':
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                        
                    case 'fire':
                    case 'fireball':
                        // ç«ç„°ç‰¹æ•ˆ
                        ctx.fillStyle = '#ff3300';
                        ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // ç«èŠ±ç²’å­
                        if (Math.random() < 0.3) {
                            createParticles(bullet.x + bullet.width/2, bullet.y + bullet.height, '#ff6600', 1);
                        }
                        break;
                        
                    case 'ice':
                        // å†°å…ƒç´ ç‰¹æ•ˆ
                        ctx.shadowColor = '#00aaff';
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // å†°æ™¶æ•ˆæœ
                        ctx.strokeStyle = '#aaffff80';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        break;
                        
                    case 'lightning':
                        // é›·é›»ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // é›»æµæ•ˆæœ
                        if (Math.random() < 0.5) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(bullet.x, bullet.y);
                            ctx.lineTo(bullet.x + Math.random() * 10 - 5, bullet.y + bullet.height + 5);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'laser':
                        // æ¿€å…‰ç‰¹æ•ˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'plasma':
                        // é›»æ¼¿ç‰¹æ•ˆ
                        const time = Date.now() * 0.01;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // é›»æ¼¿ç’°
                        ctx.strokeStyle = bullet.color + '80';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                               8 + Math.sin(time + bullet.x) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'neutron':
                        // ä¸­å­æ˜Ÿç‰¹æ•ˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'antimatter':
                        // åç‰©è³ªç‰¹æ•ˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // ç©ºé–“æ‰­æ›²æ•ˆæœ
                        ctx.strokeStyle = bullet.color;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'quantum':
                        // é‡å­ç‰¹æ•ˆ
                        const quantumPhase = Math.sin(Date.now() * 0.05);
                        ctx.globalAlpha = 0.7 + quantumPhase * 0.3;
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 25;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.globalAlpha = 1.0;
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'singularity':
                        // é»‘æ´ç‰¹æ•ˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 30;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å¸å–æ•ˆæœ
                        for (let i = 0; i < 3; i++) {
                            const radius = 15 + i * 5;
                            ctx.strokeStyle = `rgba(77, 0, 128, ${0.3 - i * 0.1})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'genesis':
                        // å‰µä¸–ä¹‹å½ˆç‰¹æ•ˆ
                        const genesisColors = ['#ffffff', '#ffff00', '#00ffff', '#ff00ff'];
                        const colorIndex = Math.floor(Date.now() * 0.01) % genesisColors.length;
                        ctx.shadowColor = genesisColors[colorIndex];
                        ctx.shadowBlur = 35;
                        ctx.fillStyle = genesisColors[colorIndex];
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å‰µä¸–å…‰ç’°
                        for (let i = 0; i < 4; i++) {
                            const radius = 12 + i * 4 + Math.sin(Date.now() * 0.03 + i) * 2;
                            ctx.strokeStyle = `${genesisColors[i]}80`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'energy':
                        // èƒ½é‡ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // èƒ½é‡å…‰ç’°
                        for (let i = 0; i < 3; i++) {
                            ctx.fillStyle = bullet.color + (60 - i * 20).toString(16);
                            ctx.fillRect(bullet.x - i, bullet.y - i, bullet.width + i*2, bullet.height + i*2);
                        }
                        break;
                        
                    case 'star':
                        // æ˜Ÿçˆ†ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // æ˜Ÿå…‰æ•ˆæœ
                        ctx.strokeStyle = bullet.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(bullet.x + bullet.width/2, bullet.y - 5);
                        ctx.lineTo(bullet.x + bullet.width/2, bullet.y + bullet.height + 5);
                        ctx.moveTo(bullet.x - 5, bullet.y + bullet.height/2);
                        ctx.lineTo(bullet.x + bullet.width + 5, bullet.y + bullet.height/2);
                        ctx.stroke();
                        break;
                        
                    case 'portal':
                        // æ™‚ç©ºæ‰­æ›²ç‰¹æ•ˆ
                        const portalTime = Date.now() * 0.02;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // æ‰­æ›²ç’°
                        for (let i = 0; i < 3; i++) {
                            ctx.strokeStyle = bullet.color + (80 - i * 30).toString(16);
                            ctx.lineWidth = 2 - i * 0.5;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                                   5 + i * 3 + Math.sin(portalTime + i) * 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'comet':
                        // å½—æ˜Ÿç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å½—æ˜Ÿå°¾å·´
                        const gradient = ctx.createLinearGradient(bullet.x, bullet.y, bullet.x, bullet.y + 20);
                        gradient.addColorStop(0, bullet.color);
                        gradient.addColorStop(1, bullet.color + '00');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(bullet.x - 1, bullet.y + bullet.height, bullet.width + 2, 15);
                        break;
                        
                    case 'dragon':
                        // é¾æ¯ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // é¾ç«ç²’å­
                        if (Math.random() < 0.4) {
                            createParticles(bullet.x + bullet.width/2, bullet.y + bullet.height, bullet.color, 2);
                        }
                        break;
                        
                    case 'blackhole':
                        // é»‘æ´ç‰¹æ•ˆ
                        const blackholeTime = Date.now() * 0.01;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // é‡åŠ›æ³¢æ•ˆæœ
                        for (let i = 0; i < 5; i++) {
                            ctx.strokeStyle = `rgba(100, 100, 255, ${(5-i)*0.1})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                                   i * 4 + Math.sin(blackholeTime + i) * 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'cosmic':
                        // å®‡å®™å°„ç·šç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 20;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'godray':
                        // ç¥å…‰å°„ç·šç‰¹æ•ˆ
                        const godrayTime = Date.now() * 0.03;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // ç¥è–å…‰ç’°
                        ctx.strokeStyle = '#ffffff80';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                               15 + Math.sin(godrayTime) * 5, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'rainbow':
                        // å½©è™¹ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å½©è™¹å…‰æšˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'ultimate':
                        // çµ‚æ¥µç‰¹æ•ˆ
                        const pulseTime = Date.now() * 0.02;
                        const pulse = Math.sin(pulseTime) * 0.5 + 1;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // è„ˆå‹•å…‰ç’°
                        ctx.strokeStyle = '#ffffff80';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 10 * pulse, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    default:
                        // æ™®é€šå­å½ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å­å½ˆå…‰æšˆæ•ˆæœ
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        break;
                }
            });
            
            // ç¹ªè£½æ•µäºº
            enemies.forEach(enemy => {
                // ç‰¹æ®Šæ•µäººè¦–è¦ºæ•ˆæœ
                switch (enemy.type) {
                    case 'phantom':
                        if (enemy.isPhased) {
                            // ç›¸ä½ç‹€æ…‹ - åŠé€æ˜å’Œé–ƒçˆ
                            ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                            ctx.shadowColor = enemy.color;
                            ctx.shadowBlur = 10;
                        }
                        break;
                    case 'berserker':
                        if (enemy.isEnraged) {
                            // ç‹‚æš´ç‹€æ…‹ - ç´…è‰²å…‰æšˆ
                            ctx.shadowColor = '#ff0000';
                            ctx.shadowBlur = 15 + Math.sin(Date.now() * 0.02) * 5;
                        }
                        break;
                    case 'voidwalker':
                        // è™›ç©ºè¡Œè€… - ç´«è‰²æ‰­æ›²æ•ˆæœ
                        ctx.shadowColor = '#330066';
                        ctx.shadowBlur = 8;
                        break;
                    case 'guardian':
                        // å®ˆè­·è€… - è—è‰²è­·ç›¾å…‰ç’°
                        if (enemy.shield > 0) {
                            ctx.strokeStyle = '#00aaff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(enemy.x - 3, enemy.y - 3, enemy.width + 6, enemy.height + 6);
                        }
                        if (enemy.healingAura) {
                            ctx.strokeStyle = '#00ffaa';
                            ctx.lineWidth = 1;
                            const radius = enemy.auraRadius * (0.8 + Math.sin(Date.now() * 0.005) * 0.2);
                            ctx.beginPath();
                            ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'reaper':
                        // æ­»ç¥ - é»‘æš—æ°£æ¯
                        ctx.shadowColor = '#000000';
                        ctx.shadowBlur = 12;
                        if (enemy.drainLife) {
                            // å¸è¡€æ•ˆæœ
                            const pulse = Math.sin(Date.now() * 0.01);
                            ctx.fillStyle = `rgba(153, 0, 0, ${0.3 + pulse * 0.2})`;
                            ctx.fillRect(enemy.x - 5, enemy.y - 5, enemy.width + 10, enemy.height + 10);
                        }
                        break;
                    case 'phoenix':
                        // é³³å‡° - ç«ç„°å…‰ç’°
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 15;
                        if (enemy.fireTrail) {
                            const flameRadius = 20 + Math.sin(Date.now() * 0.02) * 5;
                            ctx.strokeStyle = '#ff4400';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, flameRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'titan':
                        // æ³°å¦ - éœ‡å‹•æ•ˆæœ
                        const shake = Math.sin(Date.now() * 0.05) * 2;
                        ctx.translate(shake, shake);
                        ctx.shadowColor = '#cc6600';
                        ctx.shadowBlur = 10;
                        break;
                    case 'overlord':
                        // çµ±æ²»è€… - å¨åš´å…‰ç’°
                        ctx.shadowColor = '#6600cc';
                        ctx.shadowBlur = 12;
                        const crownEffect = Math.sin(Date.now() * 0.008) * 3;
                        ctx.fillStyle = '#9966cc';
                        ctx.fillRect(enemy.x + enemy.width/2 - 5, enemy.y - 10 + crownEffect, 10, 8);
                        break;
                    case 'nemesis':
                        // å¤©æ•µ - å¤šé‡è­·ç›¾æ•ˆæœ
                        if (enemy.shield > 0) {
                            for (let i = 0; i < 3; i++) {
                                ctx.strokeStyle = `rgba(255, 0, 136, ${0.6 - i * 0.2})`;
                                ctx.lineWidth = 2;
                                const radius = 5 + i * 8 + Math.sin(Date.now() * 0.01 + i) * 3;
                                ctx.beginPath();
                                ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, radius, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        break;
                    case 'bomber':
                        // çˆ†ç‚¸æ•µäºº - é–ƒçˆè­¦å‘Š
                        if (enemy.health <= enemy.maxHealth * 0.3) {
                            const flash = Math.sin(Date.now() * 0.02) > 0 ? 1 : 0.3;
                            ctx.globalAlpha = flash;
                            ctx.shadowColor = '#ff8800';
                            ctx.shadowBlur = 8;
                        }
                        break;
                    case 'assassin':
                        // åˆºå®¢ - æ®˜å½±æ•ˆæœ
                        for (let i = 0; i < 3; i++) {
                            ctx.globalAlpha = 0.2 - i * 0.05;
                            ctx.fillStyle = enemy.color;
                            ctx.fillRect(enemy.x - i * 5, enemy.y, enemy.width, enemy.height);
                        }
                        ctx.globalAlpha = 1.0;
                        break;
                }
                
                // ç¹ªè£½æ•µäººæœ¬é«”
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // é‡ç½®ç‰¹æ•ˆ
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
                ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®è®Šæ›
                
                // ç¹ªè£½è­·ç”²æŒ‡ç¤ºå™¨
                if (enemy.armor && enemy.armor > 0) {
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(enemy.x + 2, enemy.y + 2, Math.min(enemy.width - 4, enemy.armor * 2), 3);
                }
                
                // ç¹ªè£½ç”Ÿå‘½å€¼æ¢åœ¨æ•µäººå·¦å´
                const healthPercent = enemy.health / enemy.maxHealth;
                const healthBarX = enemy.x - 7;
                const healthBarY = enemy.y;
                const healthBarWidth = 5;
                const healthBarHeight = enemy.height;
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.fillRect(healthBarX, healthBarY + healthBarHeight * (1 - healthPercent), 
                           healthBarWidth, healthBarHeight * healthPercent);
                           
                // ç°¡åŒ–çš„è¡€é‡æ¢é¡¯ç¤º
            });

            // ç¹ªè£½Boss
            bosses.forEach(boss => {
                // Bossç‰¹æ®Šè¦–è¦ºæ•ˆæœ
                switch (boss.type) {
                    case 'berserker':
                        // ç‹‚æˆ°å£«Boss - ç´…è‰²æˆ°é¬¥å…‰ç’°
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 20 + Math.sin(Date.now() * 0.01) * 10;
                        break;
                    case 'shield':
                        // è­·ç›¾Boss - è—è‰²è­·ç›¾å…‰ç’°
                        ctx.shadowColor = '#0088ff';
                        ctx.shadowBlur = 15;
                        if (boss.shield > 0) {
                            const shieldRadius = Math.max(boss.width, boss.height) / 2 + 10;
                            ctx.strokeStyle = '#0088ff';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, shieldRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'laser':
                        // é›·å°„Boss - ç´«è‰²èƒ½é‡å ´
                        ctx.shadowColor = '#8800ff';
                        ctx.shadowBlur = 12;
                        const energyPulse = Math.sin(Date.now() * 0.02);
                        ctx.strokeStyle = `rgba(136, 0, 255, ${0.5 + energyPulse * 0.3})`;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(boss.x - 2, boss.y - 2, boss.width + 4, boss.height + 4);
                        break;
                    case 'missile':
                        // é£›å½ˆBoss - æ©™è‰²çˆ†ç‚¸æ°£æ¯
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 18;
                        // é£›å½ˆç™¼å°„å™¨æ•ˆæœ
                        const missileGlow = Math.sin(Date.now() * 0.015) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 102, 0, ${missileGlow * 0.3})`;
                        ctx.fillRect(boss.x - 5, boss.y - 5, boss.width + 10, boss.height + 10);
                        break;
                    case 'teleport':
                        // å‚³é€Boss - ç´«è‰²å‚³é€èƒ½é‡
                        ctx.shadowColor = '#cc00ff';
                        ctx.shadowBlur = 15;
                        if (boss.isTeleporting) {
                            ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.03) * 0.3;
                            for (let i = 0; i < 5; i++) {
                                const offset = i * 3;
                                ctx.strokeStyle = `rgba(204, 0, 255, ${0.8 - i * 0.15})`;
                                ctx.lineWidth = 2;
                                ctx.strokeRect(boss.x - offset, boss.y - offset, boss.width + offset * 2, boss.height + offset * 2);
                            }
                        }
                        break;
                    case 'split':
                        // åˆ†è£‚Boss - ç¶ è‰²åˆ†è£‚èƒ½é‡
                        ctx.shadowColor = '#00ff44';
                        ctx.shadowBlur = 10;
                        if (boss.canSplit) {
                            const splitEffect = Math.sin(Date.now() * 0.025);
                            ctx.strokeStyle = `rgba(0, 255, 68, ${0.6 + splitEffect * 0.4})`;
                            ctx.lineWidth = 1;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(boss.x, boss.y, boss.width, boss.height);
                            ctx.setLineDash([]);
                        }
                        break;
                    case 'heal':
                        // æ²»ç™‚Boss - ç¶ è‰²æ²»ç™‚å…‰ç’°
                        ctx.shadowColor = '#00aa44';
                        ctx.shadowBlur = 12;
                        const healPulse = Math.sin(Date.now() * 0.01);
                        const healRadius = 40 + healPulse * 10;
                        ctx.strokeStyle = `rgba(0, 170, 68, ${0.4 + healPulse * 0.2})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, healRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'armor':
                        // è£ç”²Boss - é‡‘å±¬å…‰æ¾¤
                        ctx.shadowColor = '#888888';
                        ctx.shadowBlur = 8;
                        if (boss.armor > 0) {
                            ctx.fillStyle = 'rgba(136, 136, 136, 0.3)';
                            ctx.fillRect(boss.x - 2, boss.y - 2, boss.width + 4, boss.height + 4);
                        }
                        break;
                    case 'speed':
                        // é€Ÿåº¦Boss - é’è‰²é€Ÿåº¦è»Œè·¡
                        ctx.shadowColor = '#00aaaa';
                        ctx.shadowBlur = 10;
                        for (let i = 0; i < 4; i++) {
                            ctx.globalAlpha = 0.3 - i * 0.07;
                            ctx.fillStyle = boss.color;
                            ctx.fillRect(boss.x - i * 8, boss.y, boss.width, boss.height);
                        }
                        ctx.globalAlpha = 1.0;
                        break;
                    case 'minion':
                        // å¬å–šBoss - æš—ç´«è‰²å¬å–šæ³•é™£
                        ctx.shadowColor = '#440088';
                        ctx.shadowBlur = 15;
                        const summonEffect = Math.sin(Date.now() * 0.008);
                        ctx.strokeStyle = `rgba(68, 0, 136, ${0.5 + summonEffect * 0.3})`;
                        ctx.lineWidth = 2;
                        const radius = Math.max(boss.width, boss.height) / 2 + 15;
                        ctx.beginPath();
                        ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        // æ³•é™£å…§åœˆ
                        ctx.beginPath();
                        ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'plasma':
                        // ç­‰é›¢å­Boss - é›»è—è‰²ç­‰é›¢å­æ•ˆæœ
                        ctx.shadowColor = '#0099ff';
                        ctx.shadowBlur = 25;
                        const plasmaEffect = Math.sin(Date.now() * 0.03);
                        ctx.fillStyle = `rgba(0, 153, 255, ${0.2 + plasmaEffect * 0.15})`;
                        for (let i = 0; i < 3; i++) {
                            const offset = i * 4 + plasmaEffect * 2;
                            ctx.fillRect(boss.x - offset, boss.y - offset, boss.width + offset * 2, boss.height + offset * 2);
                        }
                        break;
                    case 'nightmare':
                        // å¤¢é­˜Boss - é»‘æš—æ‰­æ›²æ•ˆæœ
                        ctx.shadowColor = '#330000';
                        ctx.shadowBlur = 30;
                        const nightmareWave = Math.sin(Date.now() * 0.005);
                        ctx.fillStyle = `rgba(51, 0, 0, ${0.4 + nightmareWave * 0.2})`;
                        for (let i = 0; i < 5; i++) {
                            const waveOffset = Math.sin(Date.now() * 0.02 + i) * 5;
                            ctx.fillRect(boss.x - 10 + waveOffset, boss.y - 10, boss.width + 20, boss.height + 20);
                        }
                        break;
                    case 'infinity':
                        // ç„¡é™Boss - å½©è™¹ç„¡é™ç¬¦è™Ÿæ•ˆæœ
                        ctx.shadowColor = '#ffffff';
                        ctx.shadowBlur = 20;
                        const infinityColors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
                        const colorIndex = Math.floor(Date.now() * 0.01) % infinityColors.length;
                        ctx.strokeStyle = infinityColors[colorIndex];
                        ctx.lineWidth = 4;
                        // ç„¡é™ç¬¦è™Ÿæ•ˆæœ
                        const centerX = boss.x + boss.width / 2;
                        const centerY = boss.y + boss.height / 2;
                        ctx.beginPath();
                        for (let t = 0; t < Math.PI * 2; t += 0.1) {
                            const x = centerX + 30 * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                            const y = centerY + 15 * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                            if (t === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        break;
                }
                
                // Bossæœ¬é«”
                ctx.fillStyle = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                
                // Bossé‚Šæ¡†
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(boss.x, boss.y, boss.width, boss.height);
                
                // é‡ç½®ç‰¹æ•ˆ
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Bossè¡€é‡æ¢
                const healthPercent = boss.health / boss.maxHealth;
                const healthBarWidth = boss.width;
                const healthBarHeight = 8;
                const healthBarX = boss.x;
                const healthBarY = boss.y - 15;
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);
                
                // è­·ç›¾æ¢ï¼ˆå¦‚æœæœ‰ï¼‰
                if (boss.type === 'shield' && boss.maxShield) {
                    const shieldPercent = boss.shield / boss.maxShield;
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.8)';
                    ctx.fillRect(healthBarX, healthBarY - 10, healthBarWidth, 4);
                    
                    ctx.fillStyle = 'rgba(0, 200, 255, 0.9)';
                    ctx.fillRect(healthBarX, healthBarY - 10, healthBarWidth * shieldPercent, 4);
                }
                
                // Bossåç¨±
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(boss.name || 'Boss', boss.x + boss.width/2, boss.y - 25);
            });

            // ç¹ªè£½Bosså­å½ˆå’Œæ•µäººå­å½ˆ
            bossBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                // ç‰¹æ®Šæ•ˆæœ
                switch (bullet.type) {
                    case 'missile':
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        break;
                    case 'laser':
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 10;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                    case 'homing':
                        // è¿½è¹¤å½ˆç‰¹æ•ˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 8;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // è¿½è¹¤è»Œè·¡
                        ctx.strokeStyle = bullet.color + '60';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                }
            });
            
            // ç¹ªè£½é“å…·
            powerups.forEach(powerup => {
                ctx.save();
                ctx.translate(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                ctx.rotate(powerup.rotation);
                
                switch (powerup.type) {
                    case 'health':
                        ctx.fillStyle = '#ff4444';
                        break;
                    case 'maxhealth':
                        // æœ€å¤§è¡€é‡é“å…· - é‡‘è‰²
                        ctx.fillStyle = '#ffaa00';
                        // æ·»åŠ å…‰ç’°æ•ˆæœ
                        ctx.shadowColor = '#ffaa00';
                        ctx.shadowBlur = 10;
                        break;
                }
                
                ctx.fillRect(-powerup.width/2, -powerup.height/2, powerup.width, powerup.height);
                
                // ç‚ºç‰¹æ®Šé“å…·æ·»åŠ é¡å¤–è¦–è¦ºæ•ˆæœ
                if (powerup.type === 'maxhealth') {
                    // é‡‘è‰²åå­—
                    ctx.strokeStyle = '#ffdd00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-powerup.width/2, 0);
                    ctx.lineTo(powerup.width/2, 0);
                    ctx.moveTo(0, -powerup.height/2);
                    ctx.lineTo(0, powerup.height/2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
            
            // ç¹ªè£½ç²’å­
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `${particle.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            });
        }
        
        // éŠæˆ²ä¸»å¾ªç’°
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // é–‹å§‹éŠæˆ²
        function startGame() {
            gameState = 'playing';
            score = 0;
            level = 1;
            health = 100;
            maxHealth = 100;
            player.x = 375;
            player.y = 500;
            player.powerLevel = 1;
            player.fireRate = weapons[equippedWeapon].fireRate;
            bullets = [];
            enemies = [];
            bosses = [];
            bossBullets = [];
            powerups = [];
            particles = [];
            bossSpawnTimer = 0;
            
            hideAllScreens();
            updatePowerupIndicator();
            updateCreditsDisplay();
        }
        
        // é‡æ–°é–‹å§‹éŠæˆ²
        function restartGame() {
            backToMainMenu();
        }
        
        // è‡ªå‹•è¼‰å…¥å­˜æª”ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        function autoLoadGame() {
            try {
                const saveData = localStorage.getItem('cosmosShootingSave');
                if (saveData) {
                    const data = JSON.parse(saveData);
                    
                    // éœé»˜è¼‰å…¥å­˜æª”æ•¸æ“š
                    credits = data.credits || 0;
                    level = Math.max(data.level || 1, 1);
                    maxHealth = data.maxHealth || 100;
                    ownedWeapons = data.ownedWeapons || ['basic'];
                    ownedBullets = data.ownedBullets || ['normal'];
                    equippedWeapon = data.equippedWeapon || 'basic';
                    equippedBullet = data.equippedBullet || 'normal';
                    difficulty = data.difficulty || 'easy';
                    
                    // æ›´æ–°UIé¡¯ç¤º
                    updateCreditsDisplay();
                    updateAllDisplays();
                }
            } catch (error) {
                console.log('è‡ªå‹•è¼‰å…¥å­˜æª”å¤±æ•—:', error);
            }
        }

        // åˆå§‹åŒ–
        initStars();
        updatePowerupIndicator();
        updateCreditsDisplay();
        autoLoadGame(); // è‡ªå‹•è¼‰å…¥å­˜æª”
        showWeapons(); // é è¨­é¡¯ç¤ºæ­¦å™¨é é¢
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>