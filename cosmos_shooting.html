<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®‡å®™å°„æ“ŠéŠæˆ²</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #000011 0%, #000033 50%, #000066 100%);
            display: block;
        }
        
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            display: none;
            z-index: 20;
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid #00ffff;
            border-radius: 15px;
            z-index: 30;
        }
        
        button {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #00ffff;
        }
        
        .controls {
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }
        
        .powerup-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            color: #ffff00;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="gameUI">
            <div>ç”Ÿå‘½å€¼: <span id="health">100/100</span></div>
            <div>åˆ†æ•¸: <span id="score">0</span></div>
            <div>ç­‰ç´š: <span id="level">1</span></div>
        </div>
        
        <div id="powerup-indicator" class="powerup-indicator"></div>
        
        <div id="startScreen">
            <h1 style="color: #00ffff; margin-bottom: 30px; text-shadow: 0 0 20px #00ffff;">ğŸš€ å®‡å®™å°„æ“ŠéŠæˆ² ğŸš€</h1>
            <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
            <div class="controls">
                <p>æ“ä½œèªªæ˜ï¼š</p>
                <p>WASD æˆ– æ–¹å‘éµ - ç§»å‹•é£›èˆ¹</p>
                <p>ç©ºç™½éµ - å°„æ“Š</p>
                <p>æ¶ˆæ»…æ•µäººç²å¾—åˆ†æ•¸å’Œé“å…·ï¼</p>
            </div>
        </div>
        
        <div id="gameOver">
            <h2 style="color: #ff0000;">éŠæˆ²çµæŸï¼</h2>
            <p>æœ€çµ‚åˆ†æ•¸: <span id="finalScore">0</span></p>
            <p>é”åˆ°ç­‰ç´š: <span id="finalLevel">1</span></p>
            <button onclick="restartGame()">é‡æ–°é–‹å§‹</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // éŠæˆ²ç‹€æ…‹
        let gameState = 'start'; // 'start', 'playing', 'gameOver', 'victory'
        let score = 0;
        let level = 1;
        let health = 100;
        let maxHealth = 100; // æ–°å¢æœ€å¤§è¡€é‡è®Šæ•¸
        let keys = {};
        let lastTime = 0;
        
        // ç©å®¶é£›èˆ¹
        const player = {
            x: 375,
            y: 500,
            width: 50,
            height: 50,
            speed: 5,
            fireRate: 200,
            lastFire: 0,
            powerLevel: 1
        };
        
        // éŠæˆ²ç‰©ä»¶é™£åˆ—
        let bullets = [];
        let enemies = [];
        let powerups = [];
        let particles = [];
        let stars = [];
        
        // åˆå§‹åŒ–æ˜Ÿæ˜ŸèƒŒæ™¯
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }
        }
        
        // éµç›¤äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // å°„æ“Šå‡½æ•¸
        function shoot() {
            const now = Date.now();
            if (now - player.lastFire > player.fireRate) {
                createBulletPattern();
                player.lastFire = now;
            }
        }
        
        // å‰µå»ºä¸åŒç­‰ç´šçš„å­å½ˆæ¨¡å¼
        function createBulletPattern() {
            const centerX = player.x + player.width / 2;
            const centerY = player.y;
            const time = Date.now() * 0.01;
            
            // æ ¹æ“šç­‰ç´šç¯„åœæ±ºå®šæ­¦å™¨æ¨¡å¼
            if (player.powerLevel <= 10) {
                // 1-10ç­‰ï¼šåŸºç¤æ­¦å™¨
                createBasicWeapons(centerX, centerY, player.powerLevel);
            } else if (player.powerLevel <= 25) {
                // 11-25ç­‰ï¼šå…ƒç´ æ­¦å™¨
                createElementalWeapons(centerX, centerY, player.powerLevel, time);
            } else if (player.powerLevel <= 50) {
                // 26-50ç­‰ï¼šèƒ½é‡æ­¦å™¨
                createEnergyWeapons(centerX, centerY, player.powerLevel, time);
            } else if (player.powerLevel <= 75) {
                // 51-75ç­‰ï¼šé­”æ³•æ­¦å™¨
                createMagicWeapons(centerX, centerY, player.powerLevel, time);
            } else if (player.powerLevel <= 99) {
                // 76-99ç­‰ï¼šå‚³èªªæ­¦å™¨
                createLegendaryWeapons(centerX, centerY, player.powerLevel, time);
            } else if (player.powerLevel === 100) {
                // 100ç­‰ï¼šçµ‚æ¥µæ­¦å™¨
                createUltimateWeapon(centerX, centerY, time);
            }
        }
        
        // 1-10ç­‰ï¼šåŸºç¤æ­¦å™¨
        function createBasicWeapons(centerX, centerY, level) {
            const bulletCount = Math.min(level, 10);
            const spread = 0.3;
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = (i - (bulletCount - 1) / 2) * spread / bulletCount;
                const color = `hsl(${60 + level * 5}, 100%, 50%)`;
                createBullet(centerX - 2, centerY, angle, color, 1, 'basic');
            }
        }
        
        // 11-25ç­‰ï¼šå…ƒç´ æ­¦å™¨
        function createElementalWeapons(centerX, centerY, level, time) {
            const elementType = Math.floor((level - 11) / 5);
            const bulletCount = 5 + (level - 10);
            
            switch (elementType) {
                case 0: // ç«å…ƒç´  (11-15ç­‰)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = (i - (bulletCount - 1) / 2) * 0.2;
                        createBullet(centerX - 2, centerY, angle, '#ff4400', 1 + Math.floor(level / 5), 'fire');
                        if (Math.random() < 0.3) {
                            createBullet(centerX + Math.sin(time + i) * 15, centerY, angle, '#ff6600', 1 + Math.floor(level / 6), 'fireball');
                        }
                    }
                    break;
                case 1: // å†°å…ƒç´  (16-20ç­‰)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = (i - (bulletCount - 1) / 2) * 0.15;
                        createBullet(centerX - 2, centerY, angle, '#00aaff', 1 + Math.floor(level / 5), 'ice');
                    }
                    break;
                case 2: // é›·å…ƒç´  (21-25ç­‰)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = Math.sin(time + i) * 0.5;
                        createBullet(centerX + Math.sin(time + i) * 20, centerY, angle, '#ffff00', 1 + Math.floor(level / 4), 'lightning');
                    }
                    break;
            }
        }
        
        // 26-50ç­‰ï¼šèƒ½é‡æ­¦å™¨
        function createEnergyWeapons(centerX, centerY, level, time) {
            const weaponType = Math.floor((level - 26) / 8);
            const intensity = level - 25;
            
            switch (weaponType) {
                case 0: // æ¿€å…‰é™£åˆ— (26-33ç­‰)
                    for (let i = 0; i < 8 + intensity; i++) {
                        const angle = (i * Math.PI / (4 + intensity)) - Math.PI/2;
                        createBullet(centerX, centerY, Math.sin(angle), '#ff0066', 2 + Math.floor(level / 8), 'laser');
                    }
                    break;
                case 1: // é›»æ¼¿ç‚® (34-41ç­‰)
                    for (let i = 0; i < 6; i++) {
                        const radius = 30 + Math.sin(time + i) * 15;
                        const angle = (i * Math.PI / 3) + time;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * 10;
                        createBullet(x, y, 0, '#6600ff', 2 + Math.floor(level / 7), 'plasma');
                    }
                    break;
                case 2: // èƒ½é‡é¢¨æš´ (42-50ç­‰)
                    for (let i = 0; i < 12 + intensity; i++) {
                        const angle = (i * Math.PI / 6) + time;
                        const distance = 20 + Math.sin(time * 2 + i) * 25;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, Math.sin(angle) * 0.3, '#00ffff', 3 + Math.floor(level / 6), 'energy');
                    }
                    break;
            }
        }
        
        // 51-75ç­‰ï¼šé­”æ³•æ­¦å™¨
        function createMagicWeapons(centerX, centerY, level, time) {
            const spellType = Math.floor((level - 51) / 8);
            
            switch (spellType) {
                case 0: // æ˜Ÿçˆ†è¡“ (51-58ç­‰)
                    for (let i = 0; i < 16; i++) {
                        const angle = (i * Math.PI / 8) + time;
                        const distance = 15 + Math.sin(time * 3 + i) * 20;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, Math.sin(angle), '#ffaa00', 4 + Math.floor(level / 5), 'star');
                    }
                    break;
                case 1: // æ™‚ç©ºæ‰­æ›² (59-66ç­‰)
                    for (let i = 0; i < 20; i++) {
                        const angle = time + i * 0.3;
                        const spiral = angle * 3;
                        createBullet(centerX + Math.cos(spiral) * (i * 2), centerY, Math.sin(angle), '#aa00ff', 5 + Math.floor(level / 4), 'portal');
                    }
                    break;
                case 2: // å½—æ˜Ÿé›¨ (67-75ç­‰)
                    for (let i = 0; i < 25; i++) {
                        const x = centerX + (Math.random() - 0.5) * 100;
                        const angle = (Math.random() - 0.5) * 0.8;
                        createBullet(x, centerY, angle, '#ff00ff', 6 + Math.floor(level / 3), 'comet');
                    }
                    break;
            }
        }
        
        // 76-99ç­‰ï¼šå‚³èªªæ­¦å™¨
        function createLegendaryWeapons(centerX, centerY, level, time) {
            const weaponType = Math.floor((level - 76) / 8);
            
            switch (weaponType) {
                case 0: // é¾æ¯ç ² (76-83ç­‰) - ç°¡åŒ–
                    for (let i = 0; i < 8; i++) { // å¾30æ¸›å°‘åˆ°8
                        const angle = (i - 3.5) * 0.3;
                        const hue = (time * 50 + i * 45) % 360;
                        createBullet(centerX + Math.sin(time + i) * 10, centerY, angle, `hsl(${hue}, 100%, 50%)`, 8 + Math.floor(level / 2), 'dragon');
                    }
                    break;
                case 1: // é»‘æ´ç ² (84-91ç­‰) - ç°¡åŒ–
                    for (let i = 0; i < 10; i++) { // å¾40æ¸›å°‘åˆ°10
                        const angle = (i * Math.PI / 5) + time;
                        const distance = Math.sin(time * 2 + i) * 20;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, 0, '#000033', 10 + Math.floor(level / 2), 'blackhole');
                    }
                    break;
                case 2: // å®‡å®™å°„ç·š (92-99ç­‰) - ç°¡åŒ–
                    for (let i = 0; i < 12; i++) { // å¾50æ¸›å°‘åˆ°12
                        const angle = (i - 5.5) * 0.2;
                        const hue = (time * 100 + i * 30) % 360;
                        createBullet(centerX + (i - 5.5) * 8, centerY, angle, `hsl(${hue}, 100%, 70%)`, 12 + Math.floor(level / 1.5), 'cosmic');
                    }
                    break;
            }
        }
        
        // 100ç­‰ï¼šçµ‚æ¥µæ­¦å™¨ - ç°¡åŒ–
        function createUltimateWeapon(centerX, centerY, time) {
            // çµ‚æ¥µå½©è™¹èºæ—‹ - ç°¡åŒ–
            for (let i = 0; i < 20; i++) { // å¾100æ¸›å°‘åˆ°20
                const angle = (i * Math.PI / 10) + time;
                const distance = Math.sin(time + i * 0.5) * 30;
                const hue = (time * 200 + i * 18) % 360;
                
                createBullet(
                    centerX + Math.cos(angle) * distance, 
                    centerY, 
                    Math.sin(angle) * 0.3, 
                    `hsl(${hue}, 100%, 50%)`, 
                    15,
                    'ultimate'
                );
            }
            
            // ä¸­å¿ƒè¶…ç´šå°„ç·š - ç°¡åŒ–
            for (let i = 0; i < 5; i++) { // å¾10æ¸›å°‘åˆ°5
                createBullet(centerX - 2 + i, centerY, 0, '#ffffff', 20, 'godray');
            }
        }
        
        // å‰µå»ºå­å½ˆ
        function createBullet(x, y, angle, color, damage, effect = 'normal') {
            bullets.push({
                x: x,
                y: y,
                width: effect === 'ultimate' ? 8 : 4,
                height: effect === 'ultimate' ? 15 : 10,
                speed: effect === 'ultimate' ? 12 : 8,
                damage: damage,
                angle: angle,
                color: color,
                effect: effect,
                trail: []
            });
        }
        
        // ç”Ÿæˆæ•µäºº
        function spawnEnemy() {
            const types = ['basic', 'fast', 'heavy'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let enemy = {
                x: Math.random() * (canvas.width - 40),
                y: -40,
                type: type
            };
            
            switch (type) {
                case 'basic':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.speed = 2 + level * 0.5;
                    enemy.health = 1; // ç´…è‰²æ€ªç‰©æ”¹ç‚º1ä¸‹æ­»ï¼Œé™ä½é›£åº¦
                    enemy.maxHealth = 1;
                    enemy.color = '#ff4444';
                    enemy.points = 100;
                    break;
                case 'fast':
                    enemy.width = 30;
                    enemy.height = 30;
                    enemy.speed = 4 + level * 0.7;
                    enemy.health = 1; // ç¶ è‰²æ€ªç‰©ä¿æŒ1ä¸‹æ­»
                    enemy.maxHealth = 1;
                    enemy.color = '#44ff44';
                    enemy.points = 150;
                    break;
                case 'heavy':
                    enemy.width = 60;
                    enemy.height = 60;
                    enemy.speed = 1 + level * 0.3;
                    enemy.health = 2; // è—è‰²æ€ªç‰©å¾5ä¸‹æ­»æ”¹ç‚º2ä¸‹æ­»
                    enemy.maxHealth = 2;
                    enemy.color = '#4444ff';
                    enemy.points = 300;
                    break;
            }
            
            enemies.push(enemy);
        }
        
        // ç”Ÿæˆé“å…·
        function spawnPowerup(x, y) {
            if (Math.random() < 0.6) { // å¢åŠ é“å…·æ‰è½æ©Ÿç‡å¾40%åˆ°60%
                const types = ['health', 'maxhealth']; // åªä¿ç•™è£œè¡€å’Œå¢åŠ è¡€é‡ä¸Šé™
                const weights = [0.7, 0.3]; // è£œè¡€70%æ©Ÿç‡ï¼Œå¢åŠ è¡€é‡ä¸Šé™30%æ©Ÿç‡
                
                // æ ¹æ“šæ¬Šé‡é¸æ“‡é“å…·é¡å‹
                const rand = Math.random();
                let selectedType = rand <= 0.7 ? 'health' : 'maxhealth';
                
                powerups.push({
                    x: x,
                    y: y,
                    width: 25,
                    height: 25,
                    type: selectedType,
                    speed: 2,
                    rotation: 0
                });
            }
        }
        
        // å‰µå»ºç²’å­æ•ˆæœ
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // æ›´æ–°éŠæˆ²ç‹€æ…‹
        function update(deltaTime) {
            if (gameState !== 'playing') return;
            
            // é•·æŒ‰å°„æ“Š
            if (keys['Space']) {
                shoot();
            }
            
            // æ›´æ–°ç©å®¶ä½ç½®
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.x = Math.max(0, player.x - player.speed);
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                player.x = Math.min(canvas.width - player.width, player.x + player.speed);
            }
            if (keys['ArrowUp'] || keys['KeyW']) {
                player.y = Math.max(0, player.y - player.speed);
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                player.y = Math.min(canvas.height - player.height, player.y + player.speed);
            }
            
            // æª¢æŸ¥å‹åˆ©æ¢ä»¶
            if (player.powerLevel >= 100) {
                gameState = 'victory';
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalLevel').textContent = level;
                document.getElementById('gameOver').querySelector('h2').textContent = 'ğŸ† æ­å–œé€šé—œï¼ ğŸ†';
                document.getElementById('gameOver').querySelector('h2').style.color = '#00ff00';
                document.getElementById('gameOver').style.display = 'block';
                return;
            }
            
            // æ›´æ–°æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            
            // æ›´æ–°å­å½ˆ
            bullets = bullets.filter(bullet => {
                // æ›´æ–°è»Œè·¡
                bullet.trail.push({x: bullet.x, y: bullet.y});
                if (bullet.trail.length > 5) {
                    bullet.trail.shift();
                }
                
                if (bullet.angle) {
                    bullet.x += Math.sin(bullet.angle) * bullet.speed;
                    bullet.y -= Math.cos(bullet.angle) * bullet.speed;
                } else {
                    bullet.y -= bullet.speed;
                }
                return bullet.y > -50;
            });
            
            // æ›´æ–°æ•µäºº
            enemies.forEach(enemy => {
                enemy.y += enemy.speed;
            });
            enemies = enemies.filter(enemy => enemy.y < canvas.height + 50);
            
            // æ›´æ–°é“å…·
            powerups.forEach(powerup => {
                powerup.y += powerup.speed;
                powerup.rotation += 0.1;
            });
            powerups = powerups.filter(powerup => powerup.y < canvas.height + 50);
            
            // æ›´æ–°ç²’å­
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                return particle.life > 0;
            });
            
            // ç¢°æ’æª¢æ¸¬ - å­å½ˆèˆ‡æ•µäºº
            bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        enemy.health -= bullet.damage;
                        bullets.splice(bulletIndex, 1);
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 3);
                        
                        if (enemy.health <= 0) {
                            score += enemy.points;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ffff00', 8);
                            spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(enemyIndex, 1);
                        }
                    }
                });
            });
            
            // ç¢°æ’æª¢æ¸¬ - ç©å®¶èˆ‡æ•µäºº
            enemies.forEach((enemy, enemyIndex) => {
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    health -= 15; // é™ä½å‚·å®³å¾25åˆ°15
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 5);
                    enemies.splice(enemyIndex, 1);
                    
                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                    }
                }
            });
            
            // ç¢°æ’æª¢æ¸¬ - ç©å®¶èˆ‡é“å…·
            powerups.forEach((powerup, powerupIndex) => {
                if (player.x < powerup.x + powerup.width &&
                    player.x + player.width > powerup.x &&
                    player.y < powerup.y + powerup.height &&
                    player.y + player.height > powerup.y) {
                    
                    switch (powerup.type) {
                        case 'health':
                            health = Math.min(maxHealth, health + 25);
                            break;
                        case 'maxhealth':
                            maxHealth += 25; // å¢åŠ æœ€å¤§è¡€é‡
                            health = Math.min(maxHealth, health + 15); // åŒæ™‚å›å¾©ä¸€äº›è¡€é‡
                            break;
                    }
                    
                    createParticles(powerup.x + powerup.width/2, powerup.y + powerup.height/2, '#00ff00', 5);
                    powerups.splice(powerupIndex, 1);
                }
            });
            
            // ç”Ÿæˆæ•µäºº - é™ä½æ•µäººç”Ÿæˆé »ç‡
            if (Math.random() < 0.015 + level * 0.003) { // å¾0.02é™ä½åˆ°0.015
                spawnEnemy();
            }
            
            // å‡ç´šç³»çµ± - å¤§å¹…é™ä½å‡ç´šæ‰€éœ€åˆ†æ•¸
            const newLevel = Math.floor(score / 300) + 1; // å¾1000æ”¹ç‚º300åˆ†å‡ä¸€ç´š
            if (newLevel > level) {
                level = newLevel;
                player.powerLevel = level; // è®“ç©å®¶æ­¦å™¨ç­‰ç´šè·Ÿè‘—éŠæˆ²ç­‰ç´šæå‡
                health = Math.min(maxHealth, health + 30); // å‡ç´šå›è¡€å¢åŠ åˆ°30
                // æ¯5ç´šæå‡å°„é€Ÿ
                if (level % 5 === 0) {
                    player.fireRate = Math.max(50, player.fireRate - 20); // æå‡å°„é€Ÿ
                }
                updatePowerupIndicator(); // æ›´æ–°æ­¦å™¨é¡¯ç¤º
            }
            
            // æ›´æ–°UI
            document.getElementById('health').textContent = `${health}/${maxHealth}`;
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
        }
        
        function updatePowerupIndicator() {
            const indicator = document.getElementById('powerup-indicator');
            let weaponType = '';
            
            if (player.powerLevel <= 10) {
                weaponType = 'åŸºç¤æ­¦å™¨';
            } else if (player.powerLevel <= 25) {
                const elementTypes = ['ç«å…ƒç´ ', 'å†°å…ƒç´ ', 'é›·å…ƒç´ '];
                const typeIndex = Math.floor((player.powerLevel - 11) / 5);
                weaponType = elementTypes[typeIndex] || 'å…ƒç´ æ­¦å™¨';
            } else if (player.powerLevel <= 50) {
                const energyTypes = ['æ¿€å…‰é™£åˆ—', 'é›»æ¼¿ç‚®', 'èƒ½é‡é¢¨æš´'];
                const typeIndex = Math.floor((player.powerLevel - 26) / 8);
                weaponType = energyTypes[typeIndex] || 'èƒ½é‡æ­¦å™¨';
            } else if (player.powerLevel <= 75) {
                const magicTypes = ['æ˜Ÿçˆ†è¡“', 'æ™‚ç©ºæ‰­æ›²', 'å½—æ˜Ÿé›¨'];
                const typeIndex = Math.floor((player.powerLevel - 51) / 8);
                weaponType = magicTypes[typeIndex] || 'é­”æ³•æ­¦å™¨';
            } else if (player.powerLevel <= 99) {
                const legendaryTypes = ['é¾æ¯ç ²', 'é»‘æ´ç ²', 'å®‡å®™å°„ç·š'];
                const typeIndex = Math.floor((player.powerLevel - 76) / 8);
                weaponType = legendaryTypes[typeIndex] || 'å‚³èªªæ­¦å™¨';
            } else if (player.powerLevel === 100) {
                weaponType = 'ğŸŒŸ çµ‚æ¥µæ­¦å™¨ ğŸŒŸ';
            }
            
            let text = `æ­¦å™¨ç­‰ç´š: ${player.powerLevel}/100 | ${weaponType} | å°„é€Ÿ: ${(1000/player.fireRate).toFixed(1)}/ç§’`;
            indicator.textContent = text;
        }
        
        // ç¹ªè£½éŠæˆ²
        function draw() {
            // æ¸…ç©ºç•«å¸ƒ
            ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.fillRect(star.x, star.y, 2, 2);
            });
            
            if (gameState !== 'playing') return;
            
            // ç¹ªè£½ç©å®¶
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // ç¹ªè£½ç©å®¶ç´°ç¯€
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-5, -player.height/2, 10, 20);
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(-15, player.height/2 - 10, 8, 8);
            ctx.fillRect(7, player.height/2 - 10, 8, 8);
            ctx.restore();
            
            // ç¹ªè£½å­å½ˆ
            bullets.forEach(bullet => {
                // ç¹ªè£½è»Œè·¡
                if (bullet.trail.length > 1 && bullet.effect !== 'normal') {
                    ctx.strokeStyle = bullet.color + '40';
                    ctx.lineWidth = bullet.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(bullet.trail[0].x + bullet.width/2, bullet.trail[0].y + bullet.height/2);
                    for (let i = 1; i < bullet.trail.length; i++) {
                        ctx.lineTo(bullet.trail[i].x + bullet.width/2, bullet.trail[i].y + bullet.height/2);
                    }
                    ctx.stroke();
                }
                
                // æ ¹æ“šç‰¹æ•ˆé¡å‹ç¹ªè£½ä¸åŒæ•ˆæœ
                switch (bullet.effect) {
                    case 'basic':
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                        
                    case 'fire':
                    case 'fireball':
                        // ç«ç„°ç‰¹æ•ˆ
                        ctx.fillStyle = '#ff3300';
                        ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // ç«èŠ±ç²’å­
                        if (Math.random() < 0.3) {
                            createParticles(bullet.x + bullet.width/2, bullet.y + bullet.height, '#ff6600', 1);
                        }
                        break;
                        
                    case 'ice':
                        // å†°å…ƒç´ ç‰¹æ•ˆ
                        ctx.shadowColor = '#00aaff';
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // å†°æ™¶æ•ˆæœ
                        ctx.strokeStyle = '#aaffff80';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        break;
                        
                    case 'lightning':
                        // é›·é›»ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // é›»æµæ•ˆæœ
                        if (Math.random() < 0.5) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(bullet.x, bullet.y);
                            ctx.lineTo(bullet.x + Math.random() * 10 - 5, bullet.y + bullet.height + 5);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'laser':
                        // æ¿€å…‰ç‰¹æ•ˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'plasma':
                        // é›»æ¼¿ç‰¹æ•ˆ
                        const time = Date.now() * 0.01;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // é›»æ¼¿ç’°
                        ctx.strokeStyle = bullet.color + '80';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                               8 + Math.sin(time + bullet.x) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'energy':
                        // èƒ½é‡ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // èƒ½é‡å…‰ç’°
                        for (let i = 0; i < 3; i++) {
                            ctx.fillStyle = bullet.color + (60 - i * 20).toString(16);
                            ctx.fillRect(bullet.x - i, bullet.y - i, bullet.width + i*2, bullet.height + i*2);
                        }
                        break;
                        
                    case 'star':
                        // æ˜Ÿçˆ†ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // æ˜Ÿå…‰æ•ˆæœ
                        ctx.strokeStyle = bullet.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(bullet.x + bullet.width/2, bullet.y - 5);
                        ctx.lineTo(bullet.x + bullet.width/2, bullet.y + bullet.height + 5);
                        ctx.moveTo(bullet.x - 5, bullet.y + bullet.height/2);
                        ctx.lineTo(bullet.x + bullet.width + 5, bullet.y + bullet.height/2);
                        ctx.stroke();
                        break;
                        
                    case 'portal':
                        // æ™‚ç©ºæ‰­æ›²ç‰¹æ•ˆ
                        const portalTime = Date.now() * 0.02;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // æ‰­æ›²ç’°
                        for (let i = 0; i < 3; i++) {
                            ctx.strokeStyle = bullet.color + (80 - i * 30).toString(16);
                            ctx.lineWidth = 2 - i * 0.5;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                                   5 + i * 3 + Math.sin(portalTime + i) * 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'comet':
                        // å½—æ˜Ÿç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å½—æ˜Ÿå°¾å·´
                        const gradient = ctx.createLinearGradient(bullet.x, bullet.y, bullet.x, bullet.y + 20);
                        gradient.addColorStop(0, bullet.color);
                        gradient.addColorStop(1, bullet.color + '00');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(bullet.x - 1, bullet.y + bullet.height, bullet.width + 2, 15);
                        break;
                        
                    case 'dragon':
                        // é¾æ¯ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // é¾ç«ç²’å­
                        if (Math.random() < 0.4) {
                            createParticles(bullet.x + bullet.width/2, bullet.y + bullet.height, bullet.color, 2);
                        }
                        break;
                        
                    case 'blackhole':
                        // é»‘æ´ç‰¹æ•ˆ
                        const blackholeTime = Date.now() * 0.01;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // é‡åŠ›æ³¢æ•ˆæœ
                        for (let i = 0; i < 5; i++) {
                            ctx.strokeStyle = `rgba(100, 100, 255, ${(5-i)*0.1})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                                   i * 4 + Math.sin(blackholeTime + i) * 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'cosmic':
                        // å®‡å®™å°„ç·šç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 20;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'godray':
                        // ç¥å…‰å°„ç·šç‰¹æ•ˆ
                        const godrayTime = Date.now() * 0.03;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // ç¥è–å…‰ç’°
                        ctx.strokeStyle = '#ffffff80';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                               15 + Math.sin(godrayTime) * 5, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'rainbow':
                        // å½©è™¹ç‰¹æ•ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å½©è™¹å…‰æšˆ
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'ultimate':
                        // çµ‚æ¥µç‰¹æ•ˆ
                        const pulseTime = Date.now() * 0.02;
                        const pulse = Math.sin(pulseTime) * 0.5 + 1;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // è„ˆå‹•å…‰ç’°
                        ctx.strokeStyle = '#ffffff80';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 10 * pulse, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    default:
                        // æ™®é€šå­å½ˆ
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // å­å½ˆå…‰æšˆæ•ˆæœ
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        break;
                }
            });
            
            // ç¹ªè£½æ•µäºº
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // ç¹ªè£½ç”Ÿå‘½å€¼æ¢
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(enemy.x, enemy.y - 8, enemy.width, 4);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.fillRect(enemy.x, enemy.y - 8, enemy.width * healthPercent, 4);
            });
            
            // ç¹ªè£½é“å…·
            powerups.forEach(powerup => {
                ctx.save();
                ctx.translate(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                ctx.rotate(powerup.rotation);
                
                switch (powerup.type) {
                    case 'health':
                        ctx.fillStyle = '#ff4444';
                        break;
                    case 'maxhealth':
                        // æœ€å¤§è¡€é‡é“å…· - é‡‘è‰²
                        ctx.fillStyle = '#ffaa00';
                        // æ·»åŠ å…‰ç’°æ•ˆæœ
                        ctx.shadowColor = '#ffaa00';
                        ctx.shadowBlur = 10;
                        break;
                }
                
                ctx.fillRect(-powerup.width/2, -powerup.height/2, powerup.width, powerup.height);
                
                // ç‚ºç‰¹æ®Šé“å…·æ·»åŠ é¡å¤–è¦–è¦ºæ•ˆæœ
                if (powerup.type === 'maxhealth') {
                    // é‡‘è‰²åå­—
                    ctx.strokeStyle = '#ffdd00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-powerup.width/2, 0);
                    ctx.lineTo(powerup.width/2, 0);
                    ctx.moveTo(0, -powerup.height/2);
                    ctx.lineTo(0, powerup.height/2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
            
            // ç¹ªè£½ç²’å­
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `${particle.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            });
        }
        
        // éŠæˆ²ä¸»å¾ªç’°
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // é–‹å§‹éŠæˆ²
        function startGame() {
            gameState = 'playing';
            score = 0;
            level = 1;
            health = 100;
            maxHealth = 100;
            player.x = 375;
            player.y = 500;
            player.powerLevel = 1;
            player.fireRate = 200;
            bullets = [];
            enemies = [];
            powerups = [];
            particles = [];
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            updatePowerupIndicator();
        }
        
        // é‡æ–°é–‹å§‹éŠæˆ²
        function restartGame() {
            startGame();
        }
        
        // åˆå§‹åŒ–
        initStars();
        updatePowerupIndicator();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>