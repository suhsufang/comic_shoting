<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>宇宙打亂鬥</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #000011 0%, #000033 50%, #000066 100%);
            display: block;
        }
        
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            display: none;
            z-index: 20;
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid #00ffff;
            border-radius: 15px;
            z-index: 30;
        }

        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border: 3px solid #00ffff;
            border-radius: 20px;
            z-index: 40;
            box-shadow: 0 0 30px #00ffff;
        }

        #weaponShop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #ffaa00;
            border-radius: 20px;
            z-index: 40;
            box-shadow: 0 0 30px #ffaa00;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
        }

        .difficulty-btn {
            background: linear-gradient(45deg, #00ff00, #00aa00);
            margin: 15px;
            padding: 20px 35px;
            font-size: 20px;
        }

        .difficulty-btn.medium {
            background: linear-gradient(45deg, #ffaa00, #ff8800);
        }

        .difficulty-btn.hard {
            background: linear-gradient(45deg, #ff3300, #aa0000);
        }
        
        .difficulty-btn.boss {
            background: linear-gradient(45deg, #8800ff, #4400aa);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px #8800ff;
        }
        
        .difficulty-btn.street-fighter {
            background: linear-gradient(45deg, #ff0000, #800000);
            border: 2px solid #ff6600;
            box-shadow: 0 0 20px #ff0000;
            color: #ffffff;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .weapon-item {
            background: rgba(0, 50, 100, 0.7);
            border: 2px solid #00aaff;
            border-radius: 10px;
            margin: 10px;
            padding: 15px;
            display: inline-block;
            width: 200px;
            vertical-align: top;
        }

        .weapon-item.owned {
            border-color: #00ff00;
            background: rgba(0, 100, 50, 0.7);
        }

        .weapon-item.equipped {
            border-color: #ffff00;
            background: rgba(100, 100, 0, 0.7);
        }

        .weapon-price {
            color: #ffaa00;
            font-weight: bold;
            font-size: 18px;
        }

        .weapon-stats {
            font-size: 14px;
            color: #aaaaaa;
            margin-top: 10px;
        }

        .credits-display {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #ffaa00;
            font-size: 18px;
            text-shadow: 0 0 10px #ffaa00;
        }

        .shop-tab {
            background: linear-gradient(45deg, #333, #666);
            color: #fff;
            margin: 5px;
            padding: 10px 20px;
            border: 2px solid #666;
        }

        .shop-tab.active {
            background: linear-gradient(45deg, #ffaa00, #ff8800);
            border-color: #ffaa00;
            color: #000;
        }
        
        button {
            background: linear-gradient(45deg, #05f900, #00d5ff);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #00ffff;
        }
        
        .controls {
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }
        
        .powerup-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            color: #ffff00;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="gameUI">
            <div>生命值: <span id="health">100/100</span></div>
            <div>分數: <span id="score">0</span></div>
            <div>等級: <span id="level">1</span></div>
            <div>經驗值: <span id="experience">0</span>/<span id="experienceToNext">100</span></div>
            <div>大招: <span id="ultimateStatus">準備就緒</span> (X鍵)</div>
            <div id="bossTimer" style="display: none;">剩餘時間: <span id="remainingTime">05:00</span></div>
        </div>
        
        <div id="powerup-indicator" class="powerup-indicator"></div>
        <div class="credits-display">金幣: <span id="credits">0</span></div>
        
        <div id="mainMenu">
            <h1 style="color: #0004ff; margin-bottom: 30px; text-shadow: 0 0 20px #002aff;">宇宙大亂鬥</h1>
            <div style="margin: 30px 0;">
                <h2 style="color: #00ffff;">選擇難度</h2>
                <button class="difficulty-btn" onclick="selectDifficulty('easy')">簡單</button>
                <button class="difficulty-btn medium" onclick="selectDifficulty('medium')">普通</button>
                <button class="difficulty-btn hard" onclick="selectDifficulty('hard')">困難</button>
                <button class="difficulty-btn boss" onclick="selectDifficulty('boss')">魔王挑戰</button>
                <button class="difficulty-btn street-fighter" onclick="selectDifficulty('street_fighter')">快打旋風</button>
            </div>
            <div style="margin: 30px 0;">
                <button onclick="openWeaponShop()">武器商店</button>
                <button onclick="showControls()">操作說明</button>
            </div>
            <div style="margin: 20px 0;">
                <button onclick="saveGame()" style="background: linear-gradient(45deg, #00ff00, #00aa00);">保存遊戲</button>
                <button onclick="loadGame()" style="background: linear-gradient(45deg, #0088ff, #004488);">載入遊戲</button>
            </div>
        </div>

        <div id="startScreen" style="display: none;">
            <h2 style="color: #00ffff; margin-bottom: 20px;">準備開始</h2>
            <p>難度: <span id="selectedDifficulty" style="color: #ffaa00;">簡單</span></p>
            <p>裝備武器: <span id="equippedWeapon" style="color: #ffaa00;">基礎射手</span></p>
            <p>裝備子彈: <span id="equippedBulletDisplay" style="color: #ffaa00;">標準子彈</span></p>
            <button onclick="startGame()">開始遊戲</button>
            <button onclick="backToMainMenu()">返回主選單</button>
        </div>

        <div id="controlsScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); padding: 40px; border: 2px solid #00ffff; border-radius: 15px; z-index: 30;">
            <h2 style="color: #00ffff;">操作說明</h2>
            <div class="controls">
                <p>WASD 或 方向鍵 - 移動飛船</p>
                <p>空白鍵 - 射擊</p>
                <p>消滅敵人獲得分數、金幣和道具！</p>
                <p>升級解鎖更強大的武器</p>
            </div>
            <button onclick="backToMainMenu()">返回主選單</button>
        </div>

        <div id="weaponShop">
            <h2 style="color: #ffaa00; margin-bottom: 20px;">武器商店</h2>
            <div style="margin-bottom: 20px;">
                <span style="color: #ffaa00; font-size: 20px;">金幣: <span id="shopCredits">0</span></span>
            </div>
            <div style="margin-bottom: 20px;">
                <button onclick="showWeapons()" id="weaponTab" class="shop-tab active">武器</button>
                <button onclick="showBullets()" id="bulletTab" class="shop-tab">子彈</button>
                <button onclick="showArmors()" id="armorTab" class="shop-tab">盔甲</button>
                <button onclick="showUltimates()" id="ultimateTab" class="shop-tab">大絕招</button>
            </div>
            <div id="weaponList"></div>
            <div id="bulletList" style="display: none;"></div>
            <div id="armorList" style="display: none;"></div>
            <div id="ultimateList" style="display: none;"></div>
            <button onclick="backToMainMenu()" style="margin-top: 20px;">返回主選單</button>
        </div>
        
        <div id="gameOver">
            <h2 style="color: #ff0000;">遊戲結束！</h2>
            <p>最終分數: <span id="finalScore">0</span></p>
            <p>達到等級: <span id="finalLevel">1</span></p>
            <p style="margin: 15px 0;">
                <button onclick="saveGame()" style="background: linear-gradient(45deg, #00ff00, #00aa00);">儲存遊戲</button>
            </p>
            <button onclick="restartGame()">重新開始</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 遊戲狀態
        let gameState = 'menu'; // 'menu', 'start', 'playing', 'gameOver', 'victory'
        let score = 0;
        let level = 1;
        let experience = 0; // 經驗值
        let experienceToNextLevel = 100; // 升級所需經驗值
        let health = 100;
        let maxHealth = 100;
        let credits = 0; // 遊戲貨幣
        let keys = {};
        let lastTime = 0;
        
        // 難度設定
        let difficulty = 'easy';
        
        // 魔王挑戰模式計時器
        let bossTimerStart = 0;
        let bossTimeLimit = 5 * 60 * 1000; // 5分鐘 (毫秒)
        let streetFighterTimeLimit = 3 * 60 * 1000; // 3分鐘 (毫秒)
        
        let difficultySettings = {
            easy: {
                enemySpeedMultiplier: 1,
                enemyHealthMultiplier: 0.7,
                enemySpawnRate: 0.8,
                playerDamageMultiplier: 1.2,
                creditMultiplier: 1
            },
            medium: {
                enemySpeedMultiplier: 1.3,
                enemyHealthMultiplier: 1,
                enemySpawnRate: 1,
                playerDamageMultiplier: 1,
                creditMultiplier: 1.5
            },
            hard: {
                enemySpeedMultiplier: 1.6,
                enemyHealthMultiplier: 1.5,
                enemySpawnRate: 1.3,
                playerDamageMultiplier: 0.8,
                creditMultiplier: 2
            },
            boss: {
                enemySpeedMultiplier: 2.0,
                enemyHealthMultiplier: 2.5,
                enemySpawnRate: 0,
                playerDamageMultiplier: 0.7,
                creditMultiplier: 10.0
            },
            street_fighter: {
                enemySpeedMultiplier: 3.0,
                enemyHealthMultiplier: 4.0,
                enemySpawnRate: 0,
                playerDamageMultiplier: 0.5,
                creditMultiplier: 20.0
            }
        };
        
        // 武器系統
        let ownedWeapons = ['basic'];
        let equippedWeapon = 'basic';
        let ownedBullets = ['normal'];
        let equippedBullet = 'normal';
        
        // 盔甲系統
        let ownedArmors = ['none', 'light', 'medium', 'heavy'];
        let equippedArmor = 'none';
        
        // 大絕招系統
        let ownedUltimates = ['shield', 'laser_storm', 'divine_wrath', 'black_hole', 'void_storm', 'dimensional_rift', 'cosmos_annihilation', 'quantum_field'];
        let equippedUltimate = 'divine_wrath';
        
        let weapons = {
            basic: {
                name: '基礎射手',
                price: 0,
                damage: 2.5,
                fireRate: 150,
                description: '強化標準射擊武器',
                minLevel: 1
            },
            rapid: {
                name: '快速射手',
                price: 2000,
                damage: 2.0,
                fireRate: 80,
                description: '超高射速攻擊',
                minLevel: 1
            },
            heavy: {
                name: '重型砲台',
                price: 5000,
                damage: 4.0,
                fireRate: 300,
                description: '超高傷害重砲',
                minLevel: 1
            },
            spread: {
                name: '散射炮',
                price: 8000,
                damage: 2.8,
                fireRate: 200,
                description: '3發高傷散射攻擊',
                minLevel: 1
            },
            piercing: {
                name: '穿透槍',
                price: 12000,
                damage: 3.5,
                fireRate: 140,
                description: '高傷穿透攻擊',
                minLevel: 1
            },
            elemental: {
                name: '元素之力',
                price: 20000,
                damage: 3.2,
                fireRate: 120,
                description: '雙發元素攻擊',
                minLevel: 1
            },
            sniper: {
                name: '宇宙狙擊槍',
                price: 35000,
                damage: 8.0,
                fireRate: 800,
                description: '極高傷害精準攻擊',
                minLevel: 1
            },
            minigun: {
                name: '旋轉機砲',
                price: 50000,
                damage: 2.2,
                fireRate: 40,
                description: '極速連續攻擊',
                minLevel: 1
            },
            fusion: {
                name: '核融合砲',
                price: 80000,
                damage: 6.0,
                fireRate: 180,
                description: '核能融合爆炸',
                minLevel: 1
            },
            antimatter: {
                name: '反物質射線',
                price: 150000,
                damage: 12.0,
                fireRate: 600,
                description: '最高科技武器',
                minLevel: 1
            },
            quantum: {
                name: '量子破壞者',
                price: 300000,
                damage: 15.0,
                fireRate: 400,
                description: '量子空間武器',
                minLevel: 1
            },
            laser: {
                name: '激光劍',
                price: 30000,
                damage: 12.0,
                fireRate: 180,
                description: '高能激光連射',
                minLevel: 1
            },
            plasma: {
                name: '等離子炮',
                price: 45000,
                damage: 15.0,
                fireRate: 220,
                description: '爆炸性等離子攻擊',
                minLevel: 1
            },
            railgun: {
                name: '軌道炮',
                price: 65000,
                damage: 25.0,
                fireRate: 400,
                description: '瞬間穿透一切敵人',
                minLevel: 1
            },
            gatling: {
                name: '加特林機炮',
                price: 80000,
                damage: 4.0,
                fireRate: 40,
                description: '超高射速彈幕攻擊',
                minLevel: 1
            },
            quantum: {
                name: '量子分解器',
                price: 120000,
                damage: 20.0,
                fireRate: 160,
                description: '分子級別的毀滅武器',
                minLevel: 1
            },
            chaos: {
                name: '混沌之源',
                price: 200000,
                damage: 35.0,
                fireRate: 200,
                description: '傳說級混沌力量',
                minLevel: 1
            },
            cosmic: {
                name: '宇宙毀滅者',
                price: 500000,
                damage: 100.0,
                fireRate: 300,
                description: '終極宇宙武器',
                minLevel: 1
            }
        };
        
        let bulletTypes = {
            normal: {
                name: '標準子彈',
                price: 0,
                damageMultiplier: 1.5,
                speed: 10,
                color: '#ffff00',
                effect: 'normal',
                description: '強化基礎子彈',
                minLevel: 1
            },
            explosive: {
                name: '爆炸彈',
                price: 3000,
                damageMultiplier: 2.0,
                speed: 8,
                color: '#ff4400',
                effect: 'explosive',
                description: '擊中時產生爆炸',
                minLevel: 1
            },
            ice: {
                name: '冰凍彈',
                price: 5000,
                damageMultiplier: 1.8,
                speed: 9,
                color: '#00aaff',
                effect: 'ice',
                description: '減緩敵人速度',
                minLevel: 1
            },
            lightning: {
                name: '電漿彈',
                price: 8000,
                damageMultiplier: 2.2,
                speed: 12,
                color: '#ffff00',
                effect: 'lightning',
                description: '快速且帶電效果',
                minLevel: 1
            },
            laser: {
                name: '激光束',
                price: 12000,
                damageMultiplier: 2.5,
                speed: 14,
                color: '#00ff37',
                effect: 'laser',
                description: '高速穿透攻擊',
                minLevel: 1
            },
            plasma: {
                name: '等離子炮',
                price: 20000,
                damageMultiplier: 3.0,
                speed: 11,
                color: '#aa00ff',
                effect: 'plasma',
                description: '超高傷害等離子體',
                minLevel: 1
            },
            neutron: {
                name: '中子星彈',
                price: 35000,
                damageMultiplier: 4.0,
                speed: 13,
                color: '#ff0080',
                effect: 'neutron',
                description: '極重中子星物質',
                minLevel: 1
            },
            antimatter: {
                name: '反物質彈',
                price: 60000,
                damageMultiplier: 5.0,
                speed: 15,
                color: '#8000ff',
                effect: 'antimatter',
                description: '反物質湍滅彈藥',
                minLevel: 1
            },
            quantum: {
                name: '量子彈',
                price: 100000,
                damageMultiplier: 6.0,
                speed: 16,
                color: '#00ffff',
                effect: 'quantum',
                description: '量子空間破壞',
                minLevel: 1
            },
            singularity: {
                name: '黑洞彈',
                price: 200000,
                damageMultiplier: 8.0,
                speed: 12,
                color: '#4d0080',
                effect: 'singularity',
                description: '微型黑洞吸取彈',
                minLevel: 1
            },
            genesis: {
                name: '創世之彈',
                price: 500000,
                damageMultiplier: 10.0,
                speed: 18,
                color: '#ffffff',
                effect: 'genesis',
                description: '終極創世力量',
                minLevel: 1
            },
            void: {
                name: '虛空彈',
                price: 300000,
                damageMultiplier: 8.0,
                speed: 18,
                color: '#000080',
                effect: 'void',
                description: '虛空吞噬一切',
                minLevel: 1
            },
            time: {
                name: '時間彈',
                price: 800000,
                damageMultiplier: 12.0,
                speed: 25,
                color: '#ffaa00',
                effect: 'time',
                description: '時間扭曲攻擊',
                minLevel: 1
            },
            reality: {
                name: '現實彈',
                price: 1200000,
                damageMultiplier: 15.0,
                speed: 22,
                color: '#ff0040',
                effect: 'reality',
                description: '扭曲現實的力量',
                minLevel: 1
            },
            infinity: {
                name: '無限彈',
                price: 2000000,
                damageMultiplier: 20.0,
                speed: 30,
                color: '#rainbow',
                effect: 'infinity',
                description: '無限宇宙的力量',
                minLevel: 1
            },
            godkiller: {
                name: '弒神彈',
                price: 5000000,
                damageMultiplier: 50.0,
                speed: 35,
                color: '#ff0000',
                effect: 'godkiller',
                description: '弒殺神靈的終極彈藥',
                minLevel: 1
            }
        };
        
        // 盔甲系統定義
        let armorTypes = {
            none: {
                name: '無裝備',
                price: 0,
                speedBoost: 0,
                healthBoost: 0,
                description: '沒有裝備盔甲',
                minLevel: 1
            },
            light: {
                name: '輕型盔甲',
                price: 1500,
                speedBoost: 1,
                healthBoost: 20,
                description: '輕量化設計，提升速度和少量血量',
                minLevel: 1
            },
            medium: {
                name: '中型盔甲',
                price: 3500,
                speedBoost: 0.5,
                healthBoost: 50,
                description: '平衡的防護，適度提升生存能力',
                minLevel: 1
            },
            heavy: {
                name: '重型盔甲',
                price: 7000,
                speedBoost: -0.5,
                healthBoost: 100,
                description: '厚重防護，大幅提升血量但略減速度',
                minLevel: 1
            },
            nano: {
                name: '奈米盔甲',
                price: 12000,
                speedBoost: 2,
                healthBoost: 80,
                description: '高科技材質，同時提升速度和血量',
                minLevel: 1
            },
            quantum: {
                name: '量子盔甲',
                price: 25000,
                speedBoost: 3,
                healthBoost: 150,
                description: '量子防護技術',
                minLevel: 1
            },
            plasma: {
                name: '等離子盔甲',
                price: 45000,
                speedBoost: 2,
                healthBoost: 200,
                description: '等離子能量護盾',
                minLevel: 1
            },
            void: {
                name: '虛空盔甲',
                price: 80000,
                speedBoost: 4,
                healthBoost: 250,
                description: '虛空能量保護',
                minLevel: 1
            },
            dimension: {
                name: '次元盔甲',
                price: 150000,
                speedBoost: 5,
                healthBoost: 300,
                description: '次元空間防護',
                minLevel: 1
            },
            cosmic: {
                name: '宇宙盔甲',
                price: 300000,
                speedBoost: 6,
                healthBoost: 500,
                description: '宇宙級防護系統',
                minLevel: 1
            },
            infinity: {
                name: '無限盔甲',
                price: 1000000,
                speedBoost: 10,
                healthBoost: 1000,
                description: '無限宇宙的終極防護',
                minLevel: 1
            },
            godslayer: {
                name: '弒神盔甲',
                price: 5000000,
                speedBoost: 15,
                healthBoost: 2000,
                description: '弒殺神靈的傳說盔甲',
                minLevel: 1
            }
        };
        
        // 大絕招系統定義
        let ultimateTypes = {
            shield: {
                name: '護盾增強',
                price: 0,
                cooldown: 15000,
                duration: 5000,
                description: '短時間內免疫傷害',
                minLevel: 1
            },
            laser_storm: {
                name: '激光風暴',
                price: 8000,
                cooldown: 35000,
                duration: 3000,
                description: '發射大量激光橫掃敵人',
                minLevel: 1
            },
            time_slow: {
                name: '時間減緩',
                price: 5000,
                cooldown: 25000,
                duration: 4000,
                description: '減慢敵人移動和攻擊速度',
                minLevel: 1
            },
            nuclear_blast: {
                name: '核爆清場',
                price: 8000,
                cooldown: 30000,
                duration: 1000,
                description: '瞬間清除所有敵人',
                minLevel: 1
            },
            phoenix: {
                name: '鳳凰重生',
                price: 15000,
                cooldown: 45000,
                duration: 8000,
                description: '死亡時自動復活並獲得無敵時間',
                minLevel: 1
            },
            berserker_rage: {
                name: '狂戰士怒吼',
                price: 25000,
                cooldown: 35000,
                duration: 6000,
                description: '大幅提升攻擊力和射擊速度',
                minLevel: 1
            },
            black_hole: {
                name: '黑洞吸收',
                price: 40000,
                cooldown: 50000,
                duration: 5000,
                description: '吸引敵人並造成持續傷害',
                minLevel: 1
            },
            dimensional_rift: {
                name: '次元裂縫',
                price: 60000,
                cooldown: 40000,
                duration: 4000,
                description: '瞬移並在原位置留下爆炸',
                minLevel: 1
            },
            elemental_fury: {
                name: '元素狂怒',
                price: 80000,
                cooldown: 45000,
                duration: 7000,
                description: '發射火焰、冰霜、雷電三種元素攻擊',
                minLevel: 1
            },
            void_storm: {
                name: '虛空風暴',
                price: 120000,
                cooldown: 60000,
                duration: 8000,
                description: '召喚虛空能量環繞玩家',
                minLevel: 1
            },
            quantum_field: {
                name: '量子力場',
                price: 200000,
                cooldown: 70000,
                duration: 10000,
                description: '反射所有敵人子彈回去攻擊它們',
                minLevel: 1
            },
            divine_wrath: {
                name: '神聖制裁',
                price: 350000,
                cooldown: 80000,
                duration: 12000,
                description: '召喚天雷轟擊所有敵人',
                minLevel: 1
            },
            reality_break: {
                name: '現實破碎',
                price: 500000,
                cooldown: 90000,
                duration: 6000,
                description: '短時間內無視一切物理法則',
                minLevel: 1
            },
            cosmos_annihilation: {
                name: '宇宙湮滅',
                price: 1000000,
                cooldown: 120000,
                duration: 15000,
                description: '終極大絕招，毀滅一切',
                minLevel: 1
            }
        };
        
        // 玩家飛船
        const player = {
            x: 375,
            y: 500,
            width: 50,
            height: 50,
            speed: 5,
            fireRate: 200,
            lastFire: 0,
            powerLevel: 1
        };
        
        
        // 應用盔甲效果的函數
        function applyArmorEffects() {
            const currentArmor = armorTypes[equippedArmor] || armorTypes['none'];

            // 保存舊的最大血量
            const oldMaxHealth = maxHealth;

            // 重置玩家基礎數值
            player.baseSpeed = player.baseSpeed || 5;
            player.baseMaxHealth = player.baseMaxHealth || 100;

            // 應用盔甲效果
            player.speed = player.baseSpeed + currentArmor.speedBoost;
            player.maxHealth = player.baseMaxHealth + currentArmor.healthBoost;
            maxHealth = player.maxHealth;

            // 確保速度不會太低
            if (player.speed < 1) player.speed = 1;

            // 如果最大血量增加了，也增加當前血量
            const healthIncrease = maxHealth - oldMaxHealth;
            if (healthIncrease > 0) {
                health += healthIncrease;
            }

            // 如果當前血量超過新的最大血量，調整血量
            if (health > maxHealth) {
                health = maxHealth;
            }

            // 確保血量不會低於1
            if (health < 1) health = 1;
        }
        
        // 大絕招狀態變數
        let ultimateActive = false;
        let ultimateType = null;
        let ultimateStartTime = 0;
        let ultimateDuration = 0;
        let ultimateCooldownEnd = 0;
        
        // 遊戲物件陣列
        let bullets = [];
        let enemies = [];
        let bosses = [];
        let bossBullets = [];
        let powerups = [];
        let particles = [];
        let stars = [];
        let bossSpawnTimer = 0;
        
        // 初始化星星背景
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }
        }
        
        // 鍵盤事件
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
            }
            if (e.code === 'KeyX' && gameState === 'playing') {
                useUltimate();
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // 射擊函數
        function shoot() {
            const now = Date.now();
            if (now - player.lastFire > player.fireRate) {
                createBulletPattern();
                player.lastFire = now;
            }
        }
        
        // 創建不同等級的子彈模式
        function createBulletPattern() {
            const centerX = player.x + player.width / 2;
            const centerY = player.y;
            const currentWeapon = weapons[equippedWeapon] || weapons['basic'];
            const currentBullet = bulletTypes[equippedBullet] || bulletTypes['normal'];
            
            // 根據武器類型創建子彈
            switch (equippedWeapon) {
                case 'basic':
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
                case 'rapid':
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
                case 'heavy':
                    createBullet(centerX - 4, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
                case 'spread':
                    for (let i = 0; i < 3; i++) {
                        const angle = (i - 1) * 0.3;
                        createBullet(centerX - 2 + (i - 1) * 10, centerY, angle, currentBullet.color, 1, currentBullet.effect);
                    }
                    break;
                case 'piercing':
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, 'piercing');
                    break;
                case 'elemental':
                    const elementalTime = Date.now() * 0.01;
                    for (let i = 0; i < 2; i++) {
                        const angle = (i - 0.5) * 0.2;
                        createBullet(centerX - 2 + (i - 0.5) * 15, centerY, angle, currentBullet.color, 1, currentBullet.effect);
                    }
                    break;
                default:
                    createBullet(centerX - 2, centerY, 0, currentBullet.color, 1, currentBullet.effect);
                    break;
            }
        }
        
        // 1-10等：基礎武器 - 減少子彈數量和範圍
        function createBasicWeapons(centerX, centerY, level) {
            const bulletCount = Math.min(Math.ceil(level / 2), 3); // 最多3發子彈
            const spread = 0.15; // 減少散射範圍
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = (i - (bulletCount - 1) / 2) * spread / Math.max(bulletCount - 1, 1);
                const color = `hsl(${60 + level * 5}, 100%, 50%)`;
                createBullet(centerX - 2, centerY, angle, color, 1, 'basic');
            }
        }
        
        // 11-25等：元素武器 - 減少子彈數量
        function createElementalWeapons(centerX, centerY, level, time) {
            const elementType = Math.floor((level - 11) / 5);
            const bulletCount = Math.min(3 + Math.ceil((level - 10) / 3), 5); // 最多5發
            
            switch (elementType) {
                case 0: // 火元素 (11-15等)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = (i - (bulletCount - 1) / 2) * 0.1; // 減少散射
                        createBullet(centerX - 2, centerY, angle, '#ff4400', 1 + Math.floor(level / 5), 'fire');
                        if (Math.random() < 0.2 && i < 2) { // 減少額外子彈
                            createBullet(centerX + Math.sin(time + i) * 8, centerY, angle, '#ff6600', 1 + Math.floor(level / 6), 'fireball');
                        }
                    }
                    break;
                case 1: // 冰元素 (16-20等)
                    for (let i = 0; i < bulletCount; i++) {
                        const angle = (i - (bulletCount - 1) / 2) * 0.08; // 減少散射
                        createBullet(centerX - 2, centerY, angle, '#00aaff', 1 + Math.floor(level / 5), 'ice');
                    }
                    break;
                case 2: // 雷元素 (21-25等)
                    for (let i = 0; i < Math.min(bulletCount, 3); i++) { // 限制雷電子彈數量
                        const angle = Math.sin(time + i) * 0.3; // 減少搖擺範圍
                        createBullet(centerX + Math.sin(time + i) * 10, centerY, angle, '#ffff00', 1 + Math.floor(level / 4), 'lightning');
                    }
                    break;
            }
        }
        
        // 26-50等：能量武器
        function createEnergyWeapons(centerX, centerY, level, time) {
            const weaponType = Math.floor((level - 26) / 8);
            const intensity = level - 25;
            
            switch (weaponType) {
                case 0: // 水藍機光(26-33等)
                    for (let i = 0; i < 8 + intensity; i++) {
                        const angle = (i * Math.PI / (4 + intensity)) - Math.PI/2;
                        createBullet(centerX, centerY, Math.sin(angle), '#000598', 2 + Math.floor(level / 8), 'laser');
                    }
                    break;
                case 1: // 光輝機關槍 (34-41等)
                    for (let i = 0; i < 6; i++) {
                        const radius = 30 + Math.sin(time + i) * 15;
                        const angle = (i * Math.PI / 3) + time;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * 10;
                        createBullet(x, y, 0, '#00ff37', 2 + Math.floor(level / 7), 'plasma');
                    }
                    break;
                case 2: // 宇宙風暴 (42-50等)
                    for (let i = 0; i < 12 + intensity; i++) {
                        const angle = (i * Math.PI / 6) + time;
                        const distance = 20 + Math.sin(time * 2 + i) * 25;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, Math.sin(angle) * 0.3, '#00ffff', 3 + Math.floor(level / 6), 'energy');
                    }
                    break;
            }
        }
        
        // 51-75等：魔法武器
        function createMagicWeapons(centerX, centerY, level, time) {
            const spellType = Math.floor((level - 51) / 8);
            
            switch (spellType) {
                case 0: // 喚星術 (51-58等)
                    for (let i = 0; i < 16; i++) {
                        const angle = (i * Math.PI / 8) + time;
                        const distance = 15 + Math.sin(time * 3 + i) * 20;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, Math.sin(angle), '#ffaa00', 4 + Math.floor(level / 5), 'star');
                    }
                    break;
                case 1: // 時空扭曲 (59-66等)
                    for (let i = 0; i < 20; i++) {
                        const angle = time + i * 0.3;
                        const spiral = angle * 3;
                        createBullet(centerX + Math.cos(spiral) * (i * 2), centerY, Math.sin(angle), '#aa00ff', 5 + Math.floor(level / 4), 'portal');
                    }
                    break;
                case 2: // 彗星雨 (67-75等)
                    for (let i = 0; i < 25; i++) {
                        const x = centerX + (Math.random() - 0.5) * 100;
                        const angle = (Math.random() - 0.5) * 0.8;
                        createBullet(x, centerY, angle, '#ff00ff', 6 + Math.floor(level / 3), 'comet');
                    }
                    break;
            }
        }
        
        // 76-99等：傳說武器
        function createLegendaryWeapons(centerX, centerY, level, time) {
            const weaponType = Math.floor((level - 76) / 8);
            
            switch (weaponType) {
                case 0: // 龍息砲 (76-83等) - 簡化
                    for (let i = 0; i < 8; i++) { // 從30減少到8
                        const angle = (i - 3.5) * 0.3;
                        const hue = (time * 50 + i * 45) % 360;
                        createBullet(centerX + Math.sin(time + i) * 10, centerY, angle, `hsl(${hue}, 100%, 50%)`, 8 + Math.floor(level / 2), 'dragon');
                    }
                    break;
                case 1: // 黑洞砲 (84-91等) - 簡化
                    for (let i = 0; i < 10; i++) { // 從40減少到10
                        const angle = (i * Math.PI / 5) + time;
                        const distance = Math.sin(time * 2 + i) * 20;
                        createBullet(centerX + Math.cos(angle) * distance, centerY, 0, '#000033', 10 + Math.floor(level / 2), 'blackhole');
                    }
                    break;
                case 2: // 彩虹射線 (92-99等) - 簡化
                    for (let i = 0; i < 12; i++) { // 從50減少到12
                        const angle = (i - 5.5) * 0.2;
                        const hue = (time * 100 + i * 30) % 360;
                        createBullet(centerX + (i - 5.5) * 8, centerY, angle, `hsl(${hue}, 100%, 70%)`, 12 + Math.floor(level / 1.5), 'cosmic');
                    }
                    break;
            }
        }
        
        // 100等：終極武器 - 簡化
        function createUltimateWeapon(centerX, centerY, time) {
            // 終極彩虹螺旋 - 簡化
            for (let i = 0; i < 20; i++) { // 從100減少到20
                const angle = (i * Math.PI / 10) + time;
                const distance = Math.sin(time + i * 0.5) * 30;
                const hue = (time * 200 + i * 18) % 360;
                
                createBullet(
                    centerX + Math.cos(angle) * distance, 
                    centerY, 
                    Math.sin(angle) * 0.3, 
                    `hsl(${hue}, 100%, 50%)`, 
                    15,
                    'ultimate'
                );
            }
            
            // 中心超級射線 - 簡化
            for (let i = 0; i < 5; i++) { // 從10減少到5
                createBullet(centerX - 2 + i, centerY, 0, '#ffffff', 20, 'godray');
            }
        }
        
        // 選單導航函數
        function selectDifficulty(diff) {
            difficulty = diff;
            const difficultyNames = {
                'easy': '簡單',
                'medium': '普通', 
                'hard': '困難',
                'boss': '魔王挑戰',
                'street_fighter': '快打旋風 '
            };
            document.getElementById('selectedDifficulty').textContent = difficultyNames[diff];
            showStartScreen();
        }

        function showStartScreen() {
            hideAllScreens();
            document.getElementById('startScreen').style.display = 'block';
            gameState = 'start';
        }

        function showControls() {
            hideAllScreens();
            document.getElementById('controlsScreen').style.display = 'block';
        }

        function openWeaponShop() {
            hideAllScreens();
            document.getElementById('weaponShop').style.display = 'block';
            updateWeaponShop();
        }

        function backToMainMenu() {
            hideAllScreens();
            document.getElementById('mainMenu').style.display = 'block';
            gameState = 'menu';
        }

        function hideAllScreens() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controlsScreen').style.display = 'none';
            document.getElementById('weaponShop').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
        }

        function showWeapons() {
            // 移除所有活動狀態
            document.getElementById('weaponTab').classList.add('active');
            document.getElementById('bulletTab').classList.remove('active');
            document.getElementById('armorTab').classList.remove('active');
            document.getElementById('ultimateTab').classList.remove('active');
            
            // 隱藏所有列表
            document.getElementById('weaponList').style.display = 'block';
            document.getElementById('bulletList').style.display = 'none';
            document.getElementById('armorList').style.display = 'none';
            document.getElementById('ultimateList').style.display = 'none';
            
            updateWeaponShop();
        }

        function showBullets() {
            // 移除所有活動狀態
            document.getElementById('weaponTab').classList.remove('active');
            document.getElementById('bulletTab').classList.add('active');
            document.getElementById('armorTab').classList.remove('active');
            document.getElementById('ultimateTab').classList.remove('active');
            
            // 隱藏所有列表
            document.getElementById('weaponList').style.display = 'none';
            document.getElementById('bulletList').style.display = 'block';
            document.getElementById('armorList').style.display = 'none';
            document.getElementById('ultimateList').style.display = 'none';
            
            updateBulletShop();
        }

        function showArmors() {
            // 移除所有活動狀態
            document.getElementById('weaponTab').classList.remove('active');
            document.getElementById('bulletTab').classList.remove('active');
            document.getElementById('armorTab').classList.add('active');
            document.getElementById('ultimateTab').classList.remove('active');
            
            // 隱藏所有列表
            document.getElementById('weaponList').style.display = 'none';
            document.getElementById('bulletList').style.display = 'none';
            document.getElementById('armorList').style.display = 'block';
            document.getElementById('ultimateList').style.display = 'none';
            
            updateArmorShop();
        }

        function showUltimates() {
            // 移除所有活動狀態
            document.getElementById('weaponTab').classList.remove('active');
            document.getElementById('bulletTab').classList.remove('active');
            document.getElementById('armorTab').classList.remove('active');
            document.getElementById('ultimateTab').classList.add('active');
            
            // 隱藏所有列表
            document.getElementById('weaponList').style.display = 'none';
            document.getElementById('bulletList').style.display = 'none';
            document.getElementById('armorList').style.display = 'none';
            document.getElementById('ultimateList').style.display = 'block';
            
            updateUltimateShop();
        }

        function updateWeaponShop() {
            const weaponList = document.getElementById('weaponList');
            const shopCredits = document.getElementById('shopCredits');
            shopCredits.textContent = credits;
            
            weaponList.innerHTML = '';
            
            Object.keys(weapons).forEach(weaponId => {
                const weapon = weapons[weaponId];
                const weaponDiv = document.createElement('div');
                weaponDiv.className = 'weapon-item';
                
                const isOwned = ownedWeapons.includes(weaponId);
                const isEquipped = equippedWeapon === weaponId;
                const canBuy = credits >= weapon.price && level >= weapon.minLevel;
                
                if (isOwned) weaponDiv.className += ' owned';
                if (isEquipped) weaponDiv.className += ' equipped';
                
                let buttonText = '';
                let buttonAction = '';
                
                if (isEquipped) {
                    buttonText = '✓ 已裝備';
                    buttonAction = '';
                } else if (isOwned) {
                    buttonText = '裝備';
                    buttonAction = `onclick="equipWeapon('${weaponId}')"`;
                } else if (level < weapon.minLevel) {
                    buttonText = `需要等級${weapon.minLevel}`;
                    buttonAction = '';
                } else if (credits >= weapon.price) {
                    buttonText = `購買 (${weapon.price}金)`;
                    buttonAction = `onclick="buyWeapon('${weaponId}')"`;
                } else {
                    buttonText = `金幣不足 (${weapon.price}金)`;
                    buttonAction = '';
                }
                
                weaponDiv.innerHTML = `
                    <h3 style="color: #00ffff; margin-bottom: 10px;">${weapon.name}</h3>
                    <p style="color: #ffffff; margin-bottom: 10px;">${weapon.description}</p>
                    <div class="weapon-stats">
                        <p>傷害: ${weapon.damage}x</p>
                        <p>射速: ${(1000/weapon.fireRate).toFixed(1)}/秒</p>
                    </div>
                    <div class="weapon-price">${weapon.price === 0 ? '免費' : weapon.price + '金幣'}</div>
                    <button ${buttonAction} ${!buttonAction ? 'disabled' : ''}>${buttonText}</button>
                `;
                
                weaponList.appendChild(weaponDiv);
            });
        }

        function updateBulletShop() {
            const bulletList = document.getElementById('bulletList');
            bulletList.innerHTML = '';
            
            Object.keys(bulletTypes).forEach(bulletId => {
                const bullet = bulletTypes[bulletId];
                const bulletDiv = document.createElement('div');
                bulletDiv.className = 'weapon-item';
                
                const isOwned = ownedBullets.includes(bulletId);
                const isEquipped = equippedBullet === bulletId;
                const canBuy = credits >= bullet.price && level >= bullet.minLevel;
                
                if (isOwned) bulletDiv.className += ' owned';
                if (isEquipped) bulletDiv.className += ' equipped';
                
                let buttonText = '';
                let buttonAction = '';
                
                if (isEquipped) {
                    buttonText = '✓ 已裝備';
                    buttonAction = '';
                } else if (isOwned) {
                    buttonText = '裝備';
                    buttonAction = `onclick="equipBullet('${bulletId}')"`;
                } else if (level < bullet.minLevel) {
                    buttonText = `需要等級${bullet.minLevel}`;
                    buttonAction = '';
                } else if (credits >= bullet.price) {
                    buttonText = `購買 (${bullet.price}金)`;
                    buttonAction = `onclick="buyBullet('${bulletId}')"`;
                } else {
                    buttonText = `金幣不足 (${bullet.price}金)`;
                    buttonAction = '';
                }
                
                bulletDiv.innerHTML = `
                    <h3 style="color: #ffff00; margin-bottom: 10px;">${bullet.name}</h3>
                    <p style="color: #ffffff; margin-bottom: 10px;">${bullet.description}</p>
                    <div class="weapon-stats">
                        <p>傷害倍率: ${bullet.damageMultiplier}x</p>
                        <p>速度: ${bullet.speed}</p>
                        <p>需求等級: ${bullet.minLevel}</p>
                    </div>
                    <div class="weapon-price">${bullet.price === 0 ? '免費' : bullet.price + '金幣'}</div>
                    <button ${buttonAction} ${!buttonAction ? 'disabled' : ''}>${buttonText}</button>
                `;
                
                bulletList.appendChild(bulletDiv);
            });
        }
        
        function updateArmorShop() {
            const armorList = document.getElementById('armorList');
            armorList.innerHTML = '';
            
            Object.keys(armorTypes).forEach(armorId => {
                const armor = armorTypes[armorId];
                const armorDiv = document.createElement('div');
                armorDiv.className = 'weapon-item';
                
                const isOwned = ownedArmors.includes(armorId);
                const isEquipped = equippedArmor === armorId;
                const canBuy = credits >= armor.price && level >= armor.minLevel;
                
                if (isOwned) armorDiv.className += ' owned';
                if (isEquipped) armorDiv.className += ' equipped';
                
                let buttonText = '';
                let buttonAction = '';
                
                if (isEquipped) {
                    buttonText = '✓ 已裝備';
                    buttonAction = '';
                } else if (isOwned) {
                    buttonText = '裝備';
                    buttonAction = `onclick="equipArmor('${armorId}')"`;
                } else if (level < armor.minLevel) {
                    buttonText = `需要等級${armor.minLevel}`;
                    buttonAction = '';
                } else if (credits >= armor.price) {
                    buttonText = `購買 (${armor.price}金)`;
                    buttonAction = `onclick="buyArmor('${armorId}')"`;
                } else {
                    buttonText = `金幣不足 (${armor.price}金)`;
                    buttonAction = '';
                }
                
                armorDiv.innerHTML = `
                    <h3 style="color: #00ff88; margin-bottom: 10px;">${armor.name}</h3>
                    <p style="color: #ffffff; margin-bottom: 10px;">${armor.description}</p>
                    <div class="weapon-stats">
                        <p>速度加成: ${armor.speedBoost >= 0 ? '+' : ''}${armor.speedBoost}</p>
                        <p>血量加成: +${armor.healthBoost}</p>
                        <p>需求等級: ${armor.minLevel}</p>
                    </div>
                    <div class="weapon-price">${armor.price === 0 ? '免費' : armor.price + '金幣'}</div>
                    <button ${buttonAction} ${!buttonAction ? 'disabled' : ''}>${buttonText}</button>
                `;
                
                armorList.appendChild(armorDiv);
            });
        }
        
        function updateUltimateShop() {
            const ultimateList = document.getElementById('ultimateList');
            ultimateList.innerHTML = '';
            
            Object.keys(ultimateTypes).forEach(ultimateId => {
                const ultimate = ultimateTypes[ultimateId];
                const ultimateDiv = document.createElement('div');
                ultimateDiv.className = 'weapon-item';
                
                const isOwned = ownedUltimates.includes(ultimateId);
                const isEquipped = equippedUltimate === ultimateId;
                const canBuy = credits >= ultimate.price && level >= ultimate.minLevel;
                
                if (isOwned) ultimateDiv.className += ' owned';
                if (isEquipped) ultimateDiv.className += ' equipped';
                
                let buttonText = '';
                let buttonAction = '';
                
                if (isEquipped) {
                    buttonText = '✓ 已裝備';
                    buttonAction = '';
                } else if (isOwned) {
                    buttonText = '裝備';
                    buttonAction = `onclick="equipUltimate('${ultimateId}')"`;
                } else if (level < ultimate.minLevel) {
                    buttonText = `需要等級${ultimate.minLevel}`;
                    buttonAction = '';
                } else if (credits >= ultimate.price) {
                    buttonText = `購買 (${ultimate.price}金)`;
                    buttonAction = `onclick="buyUltimate('${ultimateId}')"`;
                } else {
                    buttonText = `金幣不足 (${ultimate.price}金)`;
                    buttonAction = '';
                }
                
                ultimateDiv.innerHTML = `
                    <h3 style="color: #ff00ff; margin-bottom: 10px;">${ultimate.name}</h3>
                    <p style="color: #ffffff; margin-bottom: 10px;">${ultimate.description}</p>
                    <div class="weapon-stats">
                        <p>冷卻時間: ${ultimate.cooldown / 1000}秒</p>
                        <p>持續時間: ${ultimate.duration / 1000}秒</p>
                        <p>需求等級: ${ultimate.minLevel}</p>
                    </div>
                    <div class="weapon-price">${ultimate.price === 0 ? '免費' : ultimate.price + '金幣'}</div>
                    <button ${buttonAction} ${!buttonAction ? 'disabled' : ''}>${buttonText}</button>
                `;
                
                ultimateList.appendChild(ultimateDiv);
            });
        }

        function buyWeapon(weaponId) {
            const weapon = weapons[weaponId];
            if (credits >= weapon.price && level >= weapon.minLevel) {
                credits -= weapon.price;
                ownedWeapons.push(weaponId);
                updateCreditsDisplay();
                updateWeaponShop();
                autoSaveGame(); // 自動保存
            }
        }

        function equipWeapon(weaponId) {
            if (ownedWeapons.includes(weaponId)) {
                equippedWeapon = weaponId;
                const weapon = weapons[weaponId];
                player.fireRate = weapon.fireRate;
                document.getElementById('equippedWeapon').textContent = weapon.name;
                updateWeaponShop();
                autoSaveGame(); // 自動保存
            }
        }

        function buyBullet(bulletId) {
            const bullet = bulletTypes[bulletId];
            if (credits >= bullet.price && level >= bullet.minLevel) {
                credits -= bullet.price;
                ownedBullets.push(bulletId);
                updateCreditsDisplay();
                updateBulletShop();
                autoSaveGame(); // 自動保存
            }
        }

        function equipBullet(bulletId) {
            if (ownedBullets.includes(bulletId)) {
                equippedBullet = bulletId;
                const bullet = bulletTypes[bulletId];
                document.getElementById('equippedBulletDisplay').textContent = bullet.name;
                updateBulletShop();
                autoSaveGame(); // 自動保存
            }
        }
        
        // 盔甲相關函數
        function buyArmor(armorId) {
            const armor = armorTypes[armorId];
            if (credits >= armor.price && level >= armor.minLevel) {
                credits -= armor.price;
                ownedArmors.push(armorId);
                updateCreditsDisplay();
                updateArmorShop();
                autoSaveGame(); // 自動保存
            }
        }
        
        function equipArmor(armorId) {
            if (ownedArmors.includes(armorId)) {
                equippedArmor = armorId;
                applyArmorEffects(); // 應用盔甲效果
                updateArmorShop();
                autoSaveGame(); // 自動保存
            }
        }
        
        // 大絕招相關函數
        function buyUltimate(ultimateId) {
            const ultimate = ultimateTypes[ultimateId];
            if (credits >= ultimate.price && level >= ultimate.minLevel) {
                credits -= ultimate.price;
                ownedUltimates.push(ultimateId);
                updateCreditsDisplay();
                updateUltimateShop();
                autoSaveGame(); // 自動保存
            }
        }
        
        function equipUltimate(ultimateId) {
            if (ownedUltimates.includes(ultimateId)) {
                equippedUltimate = ultimateId;
                updateUltimateShop();
                autoSaveGame(); // 自動保存
            }
        }
        
        // 使用大絕招
        function useUltimate() {
            if (ultimateActive || Date.now() < ultimateCooldownEnd) {
                // 在畫面上顯示冷卻提示
                if (Date.now() < ultimateCooldownEnd) {
                    const remainingCooldown = Math.ceil((ultimateCooldownEnd - Date.now()) / 1000);
                    console.log(`大招冷卻中，還需 ${remainingCooldown} 秒`);
                }
                return;
            }
            
            const currentUltimate = ultimateTypes[equippedUltimate];
            if (!currentUltimate) {
                console.log('沒有裝備大招！');
                return;
            }
            
            console.log(`使用大招: ${currentUltimate.name}`);
            
            ultimateActive = true;
            ultimateType = equippedUltimate;
            ultimateStartTime = Date.now();
            ultimateDuration = currentUltimate.duration;
            ultimateCooldownEnd = Date.now() + currentUltimate.cooldown;
            
            // 執行大絕招效果
            executeUltimate(equippedUltimate);
        }
        
        function executeUltimate(ultimateType) {
            switch(ultimateType) {
                case 'shield':
                    // 護盾效果在傷害檢測中處理
                    break;
                case 'laser_storm':
                    executeLaserStorm();
                    break;
                case 'time_slow':
                    executeTimeSlow();
                    break;
                case 'nuclear_blast':
                    executeNuclearBlast();
                    break;
                case 'phoenix':
                    executePhoenix();
                    break;
                case 'berserker_rage':
                    executeBerserkerRage();
                    break;
                case 'black_hole':
                    executeBlackHole();
                    break;
                case 'dimensional_rift':
                    executeDimensionalRift();
                    break;
                case 'elemental_fury':
                    executeElementalFury();
                    break;
                case 'void_storm':
                    executeVoidStorm();
                    break;
                case 'quantum_field':
                    executeQuantumField();
                    break;
                case 'divine_wrath':
                    executeDivineWrath();
                    break;
                case 'reality_break':
                    executeRealityBreak();
                    break;
                case 'cosmos_annihilation':
                    executeCosmosAnnihilation();
                    break;
            }
        }
        
        function executeLaserStorm() {
            const interval = setInterval(() => {
                if (!ultimateActive || ultimateType !== 'laser_storm') {
                    clearInterval(interval);
                    return;
                }
                
                // 發射多道激光
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI / 4);
                    const x = player.x + player.width / 2;
                    const y = player.y + player.height / 2;
                    createBullet(x, y, angle, '#ff00ff', 3, 'piercing');
                }
            }, 100);
        }
        
        function executeTimeSlow() {
            // 時間減緩效果在敵人移動更新中處理
        }
        
        function executeNuclearBlast() {
            // 清除所有敵人
            enemies.forEach(enemy => {
                createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff0000', 10);
                credits += Math.floor(enemy.credits * 2); // 雙倍獎勵
            });
            bosses.forEach(boss => {
                createParticles(boss.x + boss.width/2, boss.y + boss.height/2, '#ff0000', 20);
                credits += Math.floor(boss.credits * 2);
            });
            enemies.length = 0;
            bosses.length = 0;
            bossBullets.length = 0;
            updateCreditsDisplay();
        }
        
        function executePhoenix() {
            // 鳳凰重生效果在玩家死亡時處理
        }
        
        function executeBerserkerRage() {
            // 暫存原始數值
            const originalFireRate = weapons[equippedWeapon].fireRate;
            const originalDamage = weapons[equippedWeapon].damage;
            
            // 增強數值
            weapons[equippedWeapon].fireRate *= 2;
            weapons[equippedWeapon].damage *= 1.5;
            
            setTimeout(() => {
                if (weapons[equippedWeapon]) {
                    weapons[equippedWeapon].fireRate = originalFireRate;
                    weapons[equippedWeapon].damage = originalDamage;
                }
            }, ultimateTypes.berserker_rage.duration);
        }
        
        function executeBlackHole() {
            const interval = setInterval(() => {
                if (!ultimateActive || ultimateType !== 'black_hole') {
                    clearInterval(interval);
                    return;
                }

                const blackHoleX = player.x + player.width / 2;
                const blackHoleY = player.y + player.height / 2;
                const attractRadius = 200;

                // 處理普通敵人
                enemies.forEach(enemy => {
                    const dx = blackHoleX - (enemy.x + enemy.width / 2);
                    const dy = blackHoleY - (enemy.y + enemy.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < attractRadius) {
                        const force = (attractRadius - distance) / attractRadius;
                        enemy.x += dx * force * 0.05;
                        enemy.y += dy * force * 0.05;

                        // 造成傷害
                        if (distance < 50) {
                            enemy.health -= 2;
                            if (enemy.health <= 0) {
                                enemies.splice(enemies.indexOf(enemy), 1);
                                score += enemy.points;
                                credits += enemy.credits;

                                // 獲得經驗值
                                const expReward = Math.ceil(enemy.points * 0.5);
                                gainExperience(expReward);

                                updateCreditsDisplay();
                            }
                        }
                    }
                });

                // 處理BOSS
                bosses.forEach(boss => {
                    const dx = blackHoleX - (boss.x + boss.width / 2);
                    const dy = blackHoleY - (boss.y + boss.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < attractRadius) {
                        const force = (attractRadius - distance) / attractRadius;
                        // BOSS較重，移動速度較慢
                        boss.x += dx * force * 0.02;
                        boss.y += dy * force * 0.02;

                        // 對BOSS造成更高傷害
                        if (distance < 80) {
                            // 先扣護盾（如果有的話）
                            if (boss.shield && boss.shield > 0) {
                                const shieldDamage = Math.min(8, boss.shield);
                                boss.shield -= shieldDamage;
                                const remainingDamage = 8 - shieldDamage;
                                if (remainingDamage > 0) {
                                    boss.health -= remainingDamage;
                                }
                            } else {
                                boss.health -= 8;
                            }

                            if (boss.health <= 0) {
                                bosses.splice(bosses.indexOf(boss), 1);
                                score += boss.points * 2;
                                credits += boss.credits * 2;

                                // 獲得經驗值（Boss擊殺有豐厚獎勵）
                                const expReward = Math.ceil(boss.points * 1.5);
                                gainExperience(expReward);

                                updateCreditsDisplay();
                            }
                        }
                    }
                });
            }, 50);
        }
        
        function executeDimensionalRift() {
            const originalX = player.x;
            const originalY = player.y;
            
            // 瞬移到隨機位置
            player.x = Math.random() * (canvas.width - player.width);
            player.y = Math.random() * (canvas.height - player.height);
            
            // 在原位置創造爆炸
            setTimeout(() => {
                const explosionRadius = 100;

                // 爆炸影響普通敵人
                enemies.forEach((enemy, index) => {
                    const dx = originalX - enemy.x;
                    const dy = originalY - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < explosionRadius) {
                        enemies.splice(index, 1);
                        score += enemy.points * 2;
                        credits += enemy.credits * 2;

                        // 獲得經驗值（爆炸擊殺有額外獎勵）
                        const expReward = Math.ceil(enemy.points * 1.0); // 經驗值為點數的100%
                        gainExperience(expReward);

                        updateCreditsDisplay();
                    }
                });

                // 爆炸影響BOSS
                bosses.forEach((boss, index) => {
                    const dx = originalX - boss.x;
                    const dy = originalY - boss.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < explosionRadius) {
                        const damage = Math.floor(boss.maxHealth * 0.25); // 造成25%最大血量傷害

                        // 先扣護盾（如果有的話）
                        if (boss.shield && boss.shield > 0) {
                            const shieldDamage = Math.min(damage, boss.shield);
                            boss.shield -= shieldDamage;
                            const remainingDamage = damage - shieldDamage;
                            if (remainingDamage > 0) {
                                boss.health -= remainingDamage;
                            }
                        } else {
                            boss.health -= damage;
                        }

                        createParticles(boss.x + boss.width/2, boss.y + boss.height/2, '#ff00ff', 20);

                        if (boss.health <= 0) {
                            bosses.splice(index, 1);
                            score += boss.points * 3;
                            credits += boss.credits * 3;

                            // 獲得經驗值（爆炸擊殺Boss有額外獎勵）
                            const expReward = Math.ceil(boss.points * 2.0); // 經驗值為點數的200%
                            gainExperience(expReward);

                            updateCreditsDisplay();
                        }
                    }
                });
            }, 500);
        }
        
        function executeElementalFury() {
            const interval = setInterval(() => {
                if (!ultimateActive || ultimateType !== 'elemental_fury') {
                    clearInterval(interval);
                    return;
                }
                
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                
                // 火焰攻擊 - 紅色
                createBullet(playerCenterX, playerCenterY, -Math.PI/2, '#ff0000', 5, 'fire');
                
                // 冰霜攻擊 - 藍色
                createBullet(playerCenterX, playerCenterY, -Math.PI/2 - 0.3, '#0080ff', 4, 'ice');
                
                // 雷電攻擊 - 黃色
                createBullet(playerCenterX, playerCenterY, -Math.PI/2 + 0.3, '#ffff00', 6, 'lightning');
            }, 200);
        }
        
        function executeVoidStorm() {
            const voidParticles = [];
            for (let i = 0; i < 8; i++) {
                voidParticles.push({
                    angle: (i * Math.PI / 4),
                    distance: 80,
                    speed: 0.1
                });
            }
            
            const interval = setInterval(() => {
                if (!ultimateActive || ultimateType !== 'void_storm') {
                    clearInterval(interval);
                    return;
                }
                
                voidParticles.forEach(particle => {
                    particle.angle += particle.speed;
                    const x = player.x + player.width / 2 + Math.cos(particle.angle) * particle.distance;
                    const y = player.y + player.height / 2 + Math.sin(particle.angle) * particle.distance;
                    
                    // 檢查與敵人碰撞
                    enemies.forEach((enemy, index) => {
                        const dx = x - (enemy.x + enemy.width / 2);
                        const dy = y - (enemy.y + enemy.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 30) {
                            enemy.health -= 3;
                            if (enemy.health <= 0) {
                                enemies.splice(index, 1);
                                score += enemy.points;
                                credits += enemy.credits;

                                // 獲得經驗值
                                const expReward = Math.ceil(enemy.points * 0.5);
                                gainExperience(expReward);

                                updateCreditsDisplay();
                            }
                        }
                    });

                    // 檢查與BOSS碰撞
                    bosses.forEach((boss, index) => {
                        const dx = x - (boss.x + boss.width / 2);
                        const dy = y - (boss.y + boss.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 50) {
                            // 先扣護盾（如果有的話）
                            if (boss.shield && boss.shield > 0) {
                                const shieldDamage = Math.min(12, boss.shield);
                                boss.shield -= shieldDamage;
                                const remainingDamage = 12 - shieldDamage;
                                if (remainingDamage > 0) {
                                    boss.health -= remainingDamage;
                                }
                            } else {
                                boss.health -= 12;
                            }

                            if (boss.health <= 0) {
                                bosses.splice(index, 1);
                                score += boss.points * 2;
                                credits += boss.credits * 2;
                                updateCreditsDisplay();
                            }
                        }
                    });
                });
            }, 50);
        }
        
        function executeQuantumField() {
            // 量子力場在傷害檢測中處理反彈效果
        }

        // 輔助函數：找到最近的目標（敵人或BOSS）
        function findNearestTarget(x, y) {
            let nearestTarget = null;
            let minDistance = Infinity;

            // 檢查所有敵人
            enemies.forEach(enemy => {
                const dx = (enemy.x + enemy.width/2) - x;
                const dy = (enemy.y + enemy.height/2) - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < minDistance) {
                    minDistance = distance;
                    nearestTarget = enemy;
                }
            });

            // 檢查所有BOSS
            bosses.forEach(boss => {
                const dx = (boss.x + boss.width/2) - x;
                const dy = (boss.y + boss.height/2) - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < minDistance) {
                    minDistance = distance;
                    nearestTarget = boss;
                }
            });

            return nearestTarget;
        }
        
        function executeDivineWrath() {
            const interval = setInterval(() => {
                if (!ultimateActive || ultimateType !== 'divine_wrath') {
                    clearInterval(interval);
                    return;
                }

                // 合併所有目標（普通敵人和BOSS）
                let allTargets = [...enemies];
                if (bosses.length > 0) {
                    allTargets = allTargets.concat(bosses);
                }

                // 隨機選擇目標進行天雷轟擊
                if (allTargets.length > 0) {
                    const randomTarget = allTargets[Math.floor(Math.random() * allTargets.length)];
                    const lightningX = randomTarget.x + randomTarget.width / 2;
                    const lightningY = 0;

                    // 創造閃電效果
                    createBullet(lightningX, lightningY, Math.PI/2, '#ffffff', 10, 'divine');

                    // 計算傷害（對BOSS造成更高傷害）
                    const isBoss = bosses.includes(randomTarget);
                    const damage = isBoss ? 50 : 15; // BOSS受到50傷害，普通敵人受到15傷害

                    // 先扣護盾（如果有的話）
                    if (randomTarget.shield && randomTarget.shield > 0) {
                        const shieldDamage = Math.min(damage, randomTarget.shield);
                        randomTarget.shield -= shieldDamage;
                        const remainingDamage = damage - shieldDamage;
                        if (remainingDamage > 0) {
                            randomTarget.health -= remainingDamage;
                        }
                    } else {
                        randomTarget.health -= damage;
                    }

                    // 檢查目標是否死亡
                    if (randomTarget.health <= 0) {
                        if (isBoss) {
                            bosses.splice(bosses.indexOf(randomTarget), 1);
                            score += randomTarget.points * 3;
                            credits += randomTarget.credits * 3;
                        } else {
                            enemies.splice(enemies.indexOf(randomTarget), 1);
                            score += randomTarget.points * 2;
                            credits += randomTarget.credits * 2;
                        }
                        updateCreditsDisplay();
                    }
                }
            }, 300);
        }

        
        function executeRealityBreak() {
            // 現實破碎期間無視碰撞和物理法則
            player.invulnerable = true;
            player.speed *= 3; // 加速移動
            
            setTimeout(() => {
                player.invulnerable = false;
                player.speed /= 3; // 恢復速度
            }, ultimateTypes.reality_break.duration);
        }
        
        function executeCosmosAnnihilation() {
            const waves = 5;
            let waveCount = 0;
            
            const interval = setInterval(() => {
                if (!ultimateActive || ultimateType !== 'cosmos_annihilation' || waveCount >= waves) {
                    clearInterval(interval);
                    return;
                }
                
                // 每波清除大部分敵人
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (Math.random() < 0.8) { // 80%機率清除
                        score += enemies[i].points * 3;
                        credits += enemies[i].credits * 3;
                        enemies.splice(i, 1);
                    }
                }

                // 對BOSS造成大量傷害
                bosses.forEach(boss => {
                    const damage = Math.floor(boss.maxHealth * 0.15); // 每波造成15%最大血量傷害

                    // 先扣護盾（如果有的話）
                    if (boss.shield && boss.shield > 0) {
                        const shieldDamage = Math.min(damage, boss.shield);
                        boss.shield -= shieldDamage;
                        const remainingDamage = damage - shieldDamage;
                        if (remainingDamage > 0) {
                            boss.health -= remainingDamage;
                        }
                    } else {
                        boss.health -= damage;
                    }

                    createParticles(boss.x + boss.width/2, boss.y + boss.height/2, '#ff00ff', 15);

                    if (boss.health <= 0) {
                        bosses.splice(bosses.indexOf(boss), 1);
                        score += boss.points * 5;
                        credits += boss.credits * 5;
                    }
                });
                
                // 創造宇宙能量波
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    createBullet(
                        player.x + player.width / 2,
                        player.y + player.height / 2,
                        angle,
                        '#ff00ff',
                        8,
                        'cosmic'
                    );
                }
                
                waveCount++;
                updateCreditsDisplay();
            }, 1000);
        }
        
        // 更新計時模式計時器
        function updateBossTimer() {
            if ((difficulty !== 'boss' && difficulty !== 'street_fighter') || bossTimerStart === 0) return;
            if (gameState !== 'playing') return; // 遊戲不在進行中時不更新計時器

            const now = Date.now();
            const elapsed = now - bossTimerStart;
            const remaining = Math.max(0, bossTimeLimit - elapsed);

            // 更新顯示
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            let timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // 魔王挑戰模式顯示進度等級
            if (difficulty === 'boss') {
                const progressLevel = Math.floor(elapsed / 30000) + 1;
                const bossMultiplier = 2.5 + (progressLevel - 1) * 0.8;
                timeString += ` | 階段${progressLevel} (強度×${bossMultiplier.toFixed(1)})`;
            }

            document.getElementById('remainingTime').textContent = timeString;
            
            // 時間到期處理
            if (remaining <= 0) {
                if (difficulty === 'boss') {
                    // 魔王挑戰時間到，玩家勝利
                    gameState = 'victory';
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('finalLevel').textContent = level;
                    document.getElementById('gameOver').querySelector('h2').textContent = '🎉 時間到！挑戰成功！ 🎉';
                    document.getElementById('gameOver').querySelector('h2').style.color = '#00ff00';
                    document.getElementById('gameOver').style.display = 'block';
                    autoSaveGame();
                } else if (difficulty === 'street_fighter') {
                    // 快打旋風時間到，玩家失敗
                    gameState = 'gameOver';
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('finalLevel').textContent = level;
                    document.getElementById('gameOver').querySelector('h2').textContent = '💀 時間到！挑戰失敗！ 💀';
                    document.getElementById('gameOver').querySelector('h2').style.color = '#ff0000';
                    document.getElementById('gameOver').style.display = 'block';
                    autoSaveGame();
                }
            }
            
            // 時間剩餘少於30秒時閃爍警告
            if (remaining <= 30000 && Math.floor(remaining / 500) % 2 === 0) {
                document.getElementById('remainingTime').style.color = '#ff0000';
            } else {
                document.getElementById('remainingTime').style.color = '#00ffff';
            }
        }
        
        // 更新大絕招狀態
        function updateUltimateStatus() {
            if (ultimateActive) {
                const now = Date.now();
                if (now - ultimateStartTime >= ultimateDuration) {
                    ultimateActive = false;
                    ultimateType = null;
                }
            }
            
            // 更新大招狀態顯示
            updateUltimateDisplay();
        }
        
        function updateUltimateDisplay() {
            const ultimateStatusElement = document.getElementById('ultimateStatus');
            if (!ultimateStatusElement) return;
            
            if (ultimateActive) {
                const currentUltimate = ultimateTypes[ultimateType];
                ultimateStatusElement.textContent = `使用中: ${currentUltimate?.name}`;
                ultimateStatusElement.style.color = '#00ff00';
            } else if (Date.now() < ultimateCooldownEnd) {
                const remainingCooldown = Math.ceil((ultimateCooldownEnd - Date.now()) / 1000);
                ultimateStatusElement.textContent = `冷卻中 (${remainingCooldown}s)`;
                ultimateStatusElement.style.color = '#ff8800';
            } else {
                const currentUltimate = ultimateTypes[equippedUltimate];
                ultimateStatusElement.textContent = `準備就緒: ${currentUltimate?.name}`;
                ultimateStatusElement.style.color = '#00ffff';
            }
        }

        function updateCreditsDisplay() {
            document.getElementById('credits').textContent = credits;
            document.getElementById('shopCredits').textContent = credits;
        }

        // 升級系統
        function gainExperience(amount) {
            experience += amount;
            updateExperienceDisplay();

            // 檢查是否可以升級
            while (experience >= experienceToNextLevel) {
                levelUp();
            }
        }

        function levelUp() {
            experience -= experienceToNextLevel;
            level++;
            experienceToNextLevel = Math.floor(experienceToNextLevel * 1.2); // 每次升級所需經驗增加20%

            // 升級獎勵
            maxHealth += 10; // 每升級增加10點最大生命值
            health = Math.min(health + 5, maxHealth); // 恢復5點生命值，不超過最大值
            credits += level * 10; // 獲得等級*10的金幣獎勵

            updateExperienceDisplay();
            updateCreditsDisplay();
            document.getElementById('health').textContent = `${health}/${maxHealth}`;
        }

        function updateExperienceDisplay() {
            document.getElementById('level').textContent = level;
            document.getElementById('experience').textContent = experience;
            document.getElementById('experienceToNext').textContent = experienceToNextLevel;
        }


        // 遊戲存檔功能
        function saveGame() {
            const saveData = {
                credits: credits,
                level: level, // 保存實際等級
                experience: experience, // 保存經驗值
                experienceToNextLevel: experienceToNextLevel, // 保存升級所需經驗值
                maxHealth: maxHealth,
                ownedWeapons: ownedWeapons,
                ownedBullets: ownedBullets,
                ownedArmors: ownedArmors,
                ownedUltimates: ownedUltimates,
                equippedWeapon: equippedWeapon,
                equippedBullet: equippedBullet,
                equippedArmor: equippedArmor,
                equippedUltimate: equippedUltimate,
                difficulty: difficulty,
                saveDate: new Date().toLocaleDateString('zh-TW')
            };
            
            try {
                localStorage.setItem('cosmosShootingSave', JSON.stringify(saveData));
                alert('遊戲已保存！\n保存時間: ' + saveData.saveDate);
            } catch (error) {
                alert('保存失敗！可能是瀏覽器存儲空間不足。');
            }
        }

        function loadGame() {
            try {
                const saveData = localStorage.getItem('cosmosShootingSave');
                if (!saveData) {
                    alert('沒有找到存檔！');
                    return;
                }
                
                const data = JSON.parse(saveData);
                
                // 載入存檔數據（包含等級系統）
                credits = data.credits || 0;
                level = data.level || 1; // 載入等級
                experience = data.experience || 0; // 載入經驗值
                experienceToNextLevel = data.experienceToNextLevel || 100; // 載入升級所需經驗值
                maxHealth = data.maxHealth || 100;
                ownedWeapons = data.ownedWeapons || ['basic'];
                ownedBullets = data.ownedBullets || ['normal'];
                ownedArmors = data.ownedArmors || ['none'];
                ownedUltimates = data.ownedUltimates || ['shield'];
                equippedWeapon = data.equippedWeapon || 'basic';
                equippedBullet = data.equippedBullet || 'normal';
                equippedArmor = data.equippedArmor || 'none';
                equippedUltimate = data.equippedUltimate || 'shield';
                difficulty = data.difficulty || 'easy';
                
                // 更新UI顯示
                updateCreditsDisplay();
                updateExperienceDisplay();
                updateAllDisplays();
                
                alert('遊戲載入成功！\n存檔時間: ' + (data.saveDate || '未知'));
                
            } catch (error) {
                alert('載入失敗！存檔可能已損壞。');
            }
        }

        // 自動保存（靜默保存，不顯示提示）
        function autoSaveGame() {
            const saveData = {
                credits: credits,
                level: level,
                maxHealth: maxHealth,
                ownedWeapons: ownedWeapons,
                ownedBullets: ownedBullets,
                ownedArmors: ownedArmors,
                ownedUltimates: ownedUltimates,
                equippedWeapon: equippedWeapon,
                equippedBullet: equippedBullet,
                equippedArmor: equippedArmor,
                equippedUltimate: equippedUltimate,
                difficulty: difficulty,
                saveDate: new Date().toLocaleDateString('zh-TW')
            };
            
            try {
                localStorage.setItem('cosmosShootingSave', JSON.stringify(saveData));
            } catch (error) {
                console.log('自動保存失敗:', error);
            }
        }

        function updateAllDisplays() {
            // 更新難度顯示
            const difficultyNames = {
                'easy': '簡單',
                'medium': '普通', 
                'hard': '困難',
                'boss': '🔥 魔王挑戰 🔥'
            };
            document.getElementById('selectedDifficulty').textContent = difficultyNames[difficulty];
            
            // 更新武器顯示
            const weapon = weapons[equippedWeapon];
            if (weapon) {
                document.getElementById('equippedWeapon').textContent = weapon.name;
            }
            
            // 更新子彈顯示
            const bullet = bulletTypes[equippedBullet];
            if (bullet) {
                document.getElementById('equippedBulletDisplay').textContent = bullet.name;
            }
            
            // 更新商店顯示
            if (document.getElementById('weaponList').style.display !== 'none') {
                updateWeaponShop();
            } else {
                updateBulletShop();
            }
        }

        // 創建子彈
        function createBullet(x, y, angle, color, damage, effect = 'normal') {
            const currentWeapon = weapons[equippedWeapon] || weapons['basic'];
            const currentBullet = bulletTypes[equippedBullet] || bulletTypes['normal'];
            const dynamicDiff = getDynamicDifficulty();
            const finalDamage = damage * currentWeapon.damage * currentBullet.damageMultiplier * dynamicDiff.playerDamageMultiplier;
            
            bullets.push({
                x: x,
                y: y,
                width: effect === 'piercing' ? 6 : 4,
                height: effect === 'piercing' ? 12 : 10,
                speed: currentBullet ? currentBullet.speed : 8,
                damage: finalDamage,
                angle: angle,
                color: color,
                effect: effect,
                trail: [],
                pierced: 0 // 用於穿透子彈計數
            });
        }
        
        // Boss系統 - 擴展BOSS類型
        function spawnBoss() {
            // 魔王挑戰模式和快打旋風模式允許多個Boss，一般模式只允許一個
            if (difficulty !== 'boss' && difficulty !== 'street_fighter' && bosses.length > 0) return;

            let availableBossTypes;
            let bossMultiplier;
            let progressLevel = 1;

            // 魔王挑戰模式 - 動態解鎖Boss類型
            if (difficulty === 'boss') {
                const elapsed = Date.now() - bossTimerStart;
                progressLevel = Math.floor(elapsed / 30000) + 1; // 每30秒升級一次

                // 基礎Boss類型
                availableBossTypes = ['laser', 'missile', 'shield'];

                // 隨時間動態解鎖更強Boss
                if (progressLevel >= 2) availableBossTypes.push('teleport', 'berserker');
                if (progressLevel >= 3) availableBossTypes.push('fortress', 'phantom');
                if (progressLevel >= 4) availableBossTypes.push('dreadnought', 'voidlord');
                if (progressLevel >= 5) availableBossTypes.push('omega', 'nemesis');
                if (progressLevel >= 6) availableBossTypes.push('apocalypse', 'titan');
                if (progressLevel >= 7) availableBossTypes.push('leviathan', 'phoenix');
                if (progressLevel >= 8) availableBossTypes.push('emperor', 'worldeater');
                if (progressLevel >= 9) availableBossTypes.push('cosmos', 'infinity');

                // 隨時間增強的倍率系統
                bossMultiplier = 2.5 + (progressLevel - 1) * 0.8; // 每30秒增加0.8倍強度
            }
            // 快打旋風模式 - 全新的超難Boss
            else if (difficulty === 'street_fighter') {
                availableBossTypes = ['ryu', 'chun_li', 'ken', 'akuma', 'sagat', 'vega', 'balrog', 'bison'];
                bossMultiplier = 5.0; // 快打旋風模式Boss更強
            } else {
                // 原本的Boss系統
                availableBossTypes = ['laser', 'missile', 'shield'];

                if (level >= 5) availableBossTypes.push('teleport', 'berserker');
                if (level >= 10) availableBossTypes.push('fortress', 'phantom');
                if (level >= 15) availableBossTypes.push('dreadnought', 'voidlord');
                if (level >= 20) availableBossTypes.push('omega', 'nemesis');
                if (level >= 25) availableBossTypes.push('apocalypse', 'titan');
                if (level >= 30) availableBossTypes.push('leviathan', 'phoenix');
                if (level >= 35) availableBossTypes.push('emperor', 'worldeater');
                if (level >= 40) availableBossTypes.push('cosmos', 'infinity');

                bossMultiplier = 1;
            }
            
            const bossType = availableBossTypes[Math.floor(Math.random() * availableBossTypes.length)];
            const dynamicDiff = getDynamicDifficulty(); // 使用動態難度
            
            let boss = {
                x: Math.random() * (canvas.width - 200) + 100,
                y: -150,
                width: 150,
                height: 100,
                type: bossType,
                health: Math.ceil(50 * dynamicDiff.enemyHealthMultiplier * (1 + level * 0.1) * bossMultiplier),
                maxHealth: Math.ceil(50 * dynamicDiff.enemyHealthMultiplier * (1 + level * 0.1) * bossMultiplier),
                speed: 2 * dynamicDiff.enemySpeedMultiplier,
                fireRate: difficulty === 'boss' ? 800 : 1000, // 魔王挑戰模式更快攻擊速度
                lastFire: 0,
                moveTimer: 0,
                credits: 300,
                points: 2000,
                pattern: 0
            };
            
            switch (bossType) {
                case 'laser':
                    boss.color = '#ff00ff';
                    boss.name = '激光巨獸';
                    boss.fireRate = 800;
                    break;
                case 'missile':
                    boss.color = '#ff4400';
                    boss.name = '追中彈獸';
                    boss.fireRate = 1200;
                    break;
                case 'shield':
                    boss.color = '#0088ff';
                    boss.name = '護盾守衛';
                    boss.health *= 1.5;
                    boss.maxHealth *= 1.5;
                    boss.shield = 50;
                    boss.maxShield = 50;
                    break;
                case 'teleport':
                    boss.color = '#aa00ff';
                    boss.name = '時空漫遊者';
                    boss.teleportTimer = 0;
                    boss.fireRate = 600;
                    break;
                case 'berserker':
                    boss.color = '#cc0000';
                    boss.name = '狂暴獵手';
                    boss.health *= 1.3;
                    boss.maxHealth *= 1.3;
                    boss.enrageThreshold = boss.maxHealth * 0.3;
                    boss.isEnraged = false;
                    boss.fireRate = 800;
                    break;
                case 'fortress':
                    boss.color = '#666666';
                    boss.name = '鐵壁要塞';
                    boss.width = 200;
                    boss.height = 120;
                    boss.health *= 2;
                    boss.maxHealth *= 2;
                    boss.armor = Math.ceil(20 * dynamicDiff.enemyHealthMultiplier);
                    boss.turrets = 4;
                    boss.fireRate = 400;
                    break;
                case 'phantom':
                    boss.color = '#440088';
                    boss.name = '幻影主軸';
                    boss.phaseTimer = 0;
                    boss.isPhased = false;
                    boss.phaseDuration = 3000;
                    boss.fireRate = 500;
                    break;
                case 'dreadnought':
                    boss.color = '#ff4400';
                    boss.name = '無畏戰艦';
                    boss.width = 180;
                    boss.height = 100;
                    boss.health *= 2.5;
                    boss.maxHealth *= 2.5;
                    boss.canShootMissiles = true;
                    boss.missileTimer = 0;
                    boss.fireRate = 600;
                    break;
                case 'voidlord':
                    boss.color = '#330066';
                    boss.name = '虛空領主';
                    boss.health *= 1.8;
                    boss.maxHealth *= 1.8;
                    boss.voidBeamTimer = 0;
                    boss.summonTimer = 0;
                    boss.fireRate = 700;
                    break;
                case 'omega':
                    boss.color = '#ffaa00';
                    boss.name = '終極機甲';
                    boss.width = 220;
                    boss.height = 140;
                    boss.health *= 3;
                    boss.maxHealth *= 3;
                    boss.shield = Math.ceil(30 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.weaponSystems = ['laser', 'missile', 'beam'];
                    boss.systemCooldowns = {laser: 0, missile: 0, beam: 0};
                    boss.fireRate = 300;
                    break;
                case 'nemesis':
                    boss.color = '#ff0088';
                    boss.name = '致命天敵';
                    boss.width = 160;
                    boss.height = 100;
                    boss.health *= 2.2;
                    boss.maxHealth *= 2.2;
                    boss.shield = Math.ceil(25 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.abilities = ['teleport', 'multishot', 'shield_regen', 'time_slow'];
                    boss.abilityTimer = 0;
                    boss.fireRate = 400;
                    break;
                case 'apocalypse':
                    boss.color = '#660000';
                    boss.name = '末日審判';
                    boss.width = 300;
                    boss.height = 180;
                    boss.health *= 4;
                    boss.maxHealth *= 4;
                    boss.shield = Math.ceil(50 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.phases = ['normal', 'rage', 'final'];
                    boss.currentPhase = 0;
                    boss.fireRate = 250;
                    break;
                case 'titan':
                    boss.color = '#cc6600';
                    boss.name = '泰坦巨獸';
                    boss.width = 250;
                    boss.height = 200;
                    boss.health *= 5;
                    boss.maxHealth *= 5;
                    boss.armor = Math.ceil(40 * dynamicDiff.enemyHealthMultiplier);
                    boss.groundSlam = true;
                    boss.slamTimer = 0;
                    boss.fireRate = 1000;
                    break;
                case 'leviathan':
                    boss.color = '#004488';
                    boss.name = '深淵利維坦';
                    boss.width = 320;
                    boss.height = 150;
                    boss.health *= 6;
                    boss.maxHealth *= 6;
                    boss.tentacles = 6;
                    boss.tentacleAttack = true;
                    boss.whirlpool = true;
                    boss.fireRate = 400;
                    break;
                case 'phoenix':
                    boss.color = '#ff6600';
                    boss.name = '不死火鳳';
                    boss.width = 180;
                    boss.height = 120;
                    boss.health *= 3;
                    boss.maxHealth *= 3;
                    boss.canRevive = true;
                    boss.reviveTimer = 0;
                    boss.fireTrail = true;
                    boss.burnAura = true;
                    boss.fireRate = 500;
                    break;
                case 'emperor':
                    boss.color = '#aa0088';
                    boss.name = '星域皇帝';
                    boss.width = 280;
                    boss.height = 200;
                    boss.health *= 7;
                    boss.maxHealth *= 7;
                    boss.shield = Math.ceil(100 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.commandAura = true;
                    boss.royalGuard = true;
                    boss.fireRate = 200;
                    break;
                case 'worldeater':
                    boss.color = '#220022';
                    boss.name = '世界吞噬者';
                    boss.width = 400;
                    boss.height = 250;
                    boss.health *= 10;
                    boss.maxHealth *= 10;
                    boss.devourAttack = true;
                    boss.realityWarp = true;
                    boss.darkMatter = true;
                    boss.fireRate = 300;
                    break;
                case 'cosmos':
                    boss.color = '#8800ff';
                    boss.name = '宇宙意志';
                    boss.width = 350;
                    boss.height = 300;
                    boss.health *= 12;
                    boss.maxHealth *= 12;
                    boss.shield = Math.ceil(200 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.cosmicPower = true;
                    boss.starforge = true;
                    boss.timeControl = true;
                    boss.fireRate = 150;
                    break;
                case 'infinity':
                    boss.color = '#ffffff';
                    boss.name = '無限存在';
                    boss.width = 500;
                    boss.height = 400;
                    boss.health *= 20;
                    boss.maxHealth *= 20;
                    boss.shield = Math.ceil(500 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    boss.infiniteRegeneration = true;
                    boss.omnipresence = true;
                    boss.realityControl = true;
                    boss.fireRate = 100;
                    break;
                
                // 快打旋風模式專屬Boss
                case 'ryu':
                    boss.color = '#ffffff';
                    boss.name = '隆 (RYU)';
                    boss.width = 120;
                    boss.height = 100;
                    boss.health *= 8;
                    boss.maxHealth *= 8;
                    boss.hadokenCharge = 0;
                    boss.shoryukenReady = true;
                    boss.fireRate = 300;
                    boss.teleportTimer = 0;
                    break;
                    
                case 'chun_li':
                    boss.color = '#0088ff';
                    boss.name = '春麗 (CHUN-LI)';
                    boss.width = 110;
                    boss.height = 95;
                    boss.health *= 7;
                    boss.maxHealth *= 7;
                    boss.kikokenReady = true;
                    boss.spinningBirdKick = false;
                    boss.fireRate = 200;
                    boss.speed *= 1.5;
                    break;
                    
                case 'ken':
                    boss.color = '#ffaa00';
                    boss.name = '肯 (KEN)';
                    boss.width = 120;
                    boss.height = 100;
                    boss.health *= 8;
                    boss.maxHealth *= 8;
                    boss.flameHadoken = true;
                    boss.dragonPunch = true;
                    boss.fireRate = 350;
                    boss.rushMode = false;
                    break;
                    
                case 'akuma':
                    boss.color = '#440000';
                    boss.name = '豪鬼 (AKUMA)';
                    boss.width = 130;
                    boss.height = 110;
                    boss.health *= 12;
                    boss.maxHealth *= 12;
                    boss.ragingDemon = 0;
                    boss.airFireball = true;
                    boss.fireRate = 150;
                    boss.teleportMaster = true;
                    boss.darkHadoken = true;
                    break;
                    
                case 'sagat':
                    boss.color = '#ff8800';
                    boss.name = '沙卡特 (SAGAT)';
                    boss.width = 140;
                    boss.height = 120;
                    boss.health *= 10;
                    boss.maxHealth *= 10;
                    boss.tigerShot = true;
                    boss.tigerUppercut = true;
                    boss.fireRate = 400;
                    boss.range = 600;
                    break;
                    
                case 'vega':
                    boss.color = '#8800ff';
                    boss.name = '維加 (VEGA)';
                    boss.width = 115;
                    boss.height = 100;
                    boss.health *= 6;
                    boss.maxHealth *= 6;
                    boss.clawAttack = true;
                    boss.wallJump = true;
                    boss.fireRate = 250;
                    boss.speed *= 2;
                    boss.agility = 5;
                    break;
                    
                case 'balrog':
                    boss.color = '#0044aa';
                    boss.name = '巴洛克 (BALROG)';
                    boss.width = 130;
                    boss.height = 110;
                    boss.health *= 11;
                    boss.maxHealth *= 11;
                    boss.dashPunch = true;
                    boss.headbutt = true;
                    boss.fireRate = 500;
                    boss.armor = Math.ceil(50 * dynamicDiff.enemyHealthMultiplier);
                    break;
                    
                case 'bison':
                    boss.color = '#cc0000';
                    boss.name = '拜森 (M.BISON)';
                    boss.width = 150;
                    boss.height = 120;
                    boss.health *= 15;
                    boss.maxHealth *= 15;
                    boss.psychoPower = true;
                    boss.scissorKick = true;
                    boss.teleport = true;
                    boss.fireRate = 200;
                    boss.finalBoss = true;
                    boss.shield = Math.ceil(100 * dynamicDiff.enemyHealthMultiplier);
                    boss.maxShield = boss.shield;
                    break;
            }
            
            bosses.push(boss);
        }
        
        // 敵人射擊系統
        function enemyFire(enemy) {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const enemyCenterX = enemy.x + enemy.width / 2;
            const enemyCenterY = enemy.y + enemy.height / 2;
            
            // 檢查射程
            if (enemy.range) {
                const distance = Math.sqrt(Math.pow(playerCenterX - enemyCenterX, 2) + Math.pow(playerCenterY - enemyCenterY, 2));
                if (distance > enemy.range) return;
            }
            
            switch (enemy.type) {
                case 'sniper':
                    // 狙擊手 - 精準射擊
                    const sniperAngle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX);
                    createEnemyBullet(enemyCenterX, enemyCenterY + 20, sniperAngle, '#00ff88', 'sniper');
                    break;
                    
                case 'destroyer':
                    // 毀滅者 - 多發散射
                    for (let i = 0; i < enemy.multiShot; i++) {
                        const angle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX) + (i - 1) * 0.3;
                        createEnemyBullet(enemyCenterX + (i - 1) * 15, enemyCenterY + 30, angle, '#ff4400', 'destroyer');
                    }
                    break;
                    
                case 'nemesis':
                    // 天敵 - 追蹤彈
                    const nemesisAngle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX);
                    createEnemyBullet(enemyCenterX, enemyCenterY + 30, nemesisAngle, '#ff0088', 'homing');
                    break;
                    
                case 'reaper':
                    // 死神 - 鐮刀攻擊
                    if (enemy.scytheAttack) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX) + (i - 1) * 0.5;
                            createEnemyBullet(enemyCenterX, enemyCenterY + 20, angle, '#000000', 'scythe');
                        }
                    }
                    break;
                    
                case 'overlord':
                    // 統治者 - 能量球
                    const overlordAngle = Math.atan2(playerCenterY - enemyCenterY, playerCenterX - enemyCenterX);
                    createEnemyBullet(enemyCenterX, enemyCenterY + 30, overlordAngle, '#6600cc', 'energy');
                    break;
            }
        }
        
        // 創建敵人子彈
        function createEnemyBullet(x, y, angle, color, type) {
            const bullet = {
                x: x - 3,
                y: y,
                width: 6,
                height: 8,
                speed: type === 'sniper' ? 6 : type === 'scythe' ? 5 : 4,
                angle: angle,
                color: color,
                type: type,
                damage: type === 'sniper' ? 20 : type === 'destroyer' ? 15 : type === 'scythe' ? 18 : 12,
                isEnemyBullet: true
            };
            
            if (type === 'homing') {
                bullet.homingStrength = 0.05;
                bullet.speed = 3;
            }
            
            bossBullets.push(bullet); // 使用現有的bossBullets陣列
        }

        // Boss射擊系統
        function bossFire(boss) {
            const now = Date.now();
            if (now - boss.lastFire < boss.fireRate) return;
            
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const bossCenterX = boss.x + boss.width / 2;
            const bossCenterY = boss.y + boss.height / 2;
            
            switch (boss.type) {
                case 'laser':
                    // 激光掃射
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        const spread = (i - 2) * 0.3;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle + spread, '#ff00ff', 'laser');
                    }
                    break;
                case 'missile':
                    // 追蹤飛彈
                    const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                    for (let i = 0; i < 3; i++) {
                        createBossBullet(bossCenterX + (i - 1) * 30, bossCenterY + 50, angle, '#ff4400', 'missile');
                    }
                    break;
                case 'shield':
                    // 環形攻擊
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4) + (now * 0.005);
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, '#0088ff', 'ring');
                    }
                    break;
                case 'teleport':
                    // 隨機射擊
                    for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        createBossBullet(bossCenterX + Math.random() * 60 - 30, bossCenterY + 50, angle, '#aa00ff', 'chaos');
                    }
                    break;
                case 'berserker':
                    // 狂暴攻擊 - 狂暴狀態下攻擊更強
                    const shotCount = boss.isEnraged ? 12 : 6;
                    const spread = boss.isEnraged ? 0.4 : 0.2;
                    for (let i = 0; i < shotCount; i++) {
                        const baseAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        const angle = baseAngle + (i - shotCount/2) * spread;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, boss.isEnraged ? '#ff6666' : '#cc0000', 'berserker');
                    }
                    break;
                case 'fortress':
                    // 多炮台攻擊
                    for (let i = 0; i < boss.turrets; i++) {
                        const turretX = bossCenterX + (i - boss.turrets/2 + 0.5) * 50;
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - turretX);
                        createBossBullet(turretX, bossCenterY + 60, angle, '#888888', 'turret');
                    }
                    break;
                case 'phantom':
                    // 幻影攻擊 - 只有非相位狀態下才攻擊
                    if (!boss.isPhased) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#880088', 'phantom');
                        }
                    }
                    break;
                case 'dreadnought':
                    // 無畏戰艦 - 主炮和導彈
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (i - 2) * 0.15;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff6600', 'cannon');
                    }
                    // 導彈攻擊
                    if (boss.canShootMissiles) {
                        boss.missileTimer += now - boss.lastFire;
                        if (boss.missileTimer > 2000) {
                            for (let i = 0; i < 3; i++) {
                                createBossBullet(bossCenterX + (i - 1) * 60, bossCenterY + 30, 0, '#ff4400', 'missile');
                            }
                            boss.missileTimer = 0;
                        }
                    }
                    break;
                case 'voidlord':
                    // 虛空領主 - 虛空光束和普通攻擊
                    boss.voidBeamTimer += now - boss.lastFire;
                    if (boss.voidBeamTimer > 4000) {
                        // 虛空光束
                        const beamAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        for (let i = 0; i < 12; i++) {
                            createBossBullet(bossCenterX, bossCenterY + 50, beamAngle + (i - 6) * 0.05, '#330066', 'voidbeam');
                        }
                        boss.voidBeamTimer = 0;
                    } else {
                        // 普通攻擊
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3) + (now * 0.003);
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#6600cc', 'void');
                        }
                    }
                    break;
                case 'omega':
                    // 終極機甲 - 多種武器系統
                    boss.weaponSystems.forEach(system => {
                        boss.systemCooldowns[system] += now - boss.lastFire;
                    });
                    
                    if (boss.systemCooldowns.laser > 1000) {
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI / 5) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY + 70, angle, '#ffff00', 'omegalaser');
                        }
                        boss.systemCooldowns.laser = 0;
                    }
                    
                    if (boss.systemCooldowns.missile > 1500) {
                        for (let i = 0; i < 6; i++) {
                            createBossBullet(bossCenterX + (i - 2.5) * 30, bossCenterY + 50, 0, '#ff6600', 'omegamissile');
                        }
                        boss.systemCooldowns.missile = 0;
                    }
                    
                    if (boss.systemCooldowns.beam > 3000) {
                        const beamAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        for (let i = 0; i < 20; i++) {
                            createBossBullet(bossCenterX, bossCenterY + 70, beamAngle + (i - 10) * 0.03, '#ffaa00', 'omegabeam');
                        }
                        boss.systemCooldowns.beam = 0;
                    }
                    break;
                case 'nemesis':
                    // 致命天敵 - 隨機能力攻擊
                    const randomPattern = Math.floor(Math.random() * 4);
                    
                    switch (randomPattern) {
                        case 0:
                            // 追蹤彈雨
                            for (let i = 0; i < 8; i++) {
                                const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (Math.random() - 0.5) * 0.8;
                                createBossBullet(bossCenterX + (Math.random() - 0.5) * 80, bossCenterY + 50, angle, '#ff0088', 'nemesishoming');
                            }
                            break;
                        case 1:
                            // 全方位攻擊
                            for (let i = 0; i < 16; i++) {
                                const angle = (i * Math.PI / 8);
                                createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff0088', 'nemesisring');
                            }
                            break;
                        case 2:
                            // 集中攻擊
                            const targetAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                            for (let i = 0; i < 12; i++) {
                                createBossBullet(bossCenterX, bossCenterY + 50, targetAngle + (i - 5.5) * 0.1, '#ff0088', 'nemesisbeam');
                            }
                            break;
                        case 3:
                            // 時間緩慢攻擊
                            for (let i = 0; i < 6; i++) {
                                const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (i - 2.5) * 0.3;
                                createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff0088', 'timeslow');
                            }
                            break;
                    }
                    break;
                case 'apocalypse':
                    // 末日審判 - 根據階段不同攻擊
                    const healthPercent = boss.health / boss.maxHealth;
                    
                    if (healthPercent > 0.66) {
                        // 第一階段
                        for (let i = 0; i < 20; i++) {
                            const angle = (i * Math.PI / 10) + (now * 0.005);
                            createBossBullet(bossCenterX, bossCenterY + 90, angle, '#660000', 'apocalypse1');
                        }
                    } else if (healthPercent > 0.33) {
                        // 第二階段
                        boss.currentPhase = 1;
                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            createBossBullet(bossCenterX + (Math.random() - 0.5) * 200, bossCenterY + 90, angle, '#990000', 'apocalypse2');
                        }
                    } else {
                        // 最終階段
                        boss.currentPhase = 2;
                        for (let i = 0; i < 24; i++) {
                            const angle = (i * Math.PI / 12) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY + 90, angle, '#cc0000', 'apocalypsefinal');
                        }
                    }
                    break;
                case 'titan':
                    // 泰坦巨獸 - 重型攻擊
                    for (let i = 0; i < 8; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (i - 3.5) * 0.2;
                        createBossBullet(bossCenterX, bossCenterY + 100, angle, '#cc6600', 'titan');
                    }
                    
                    // 地面震擊
                    if (boss.groundSlam) {
                        boss.slamTimer += now - boss.lastFire;
                        if (boss.slamTimer > 5000) {
                            // 震波攻擊
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
                                createBossBullet(bossCenterX + Math.cos(angle) * 60, bossCenterY + Math.sin(angle) * 60, angle + Math.PI, '#cc6600', 'shockwave');
                            }
                            boss.slamTimer = 0;
                        }
                    }
                    break;
                case 'leviathan':
                    // 深淵利維坦 - 觸手攻擊
                    for (let i = 0; i < boss.tentacles; i++) {
                        const tentacleAngle = (i * Math.PI * 2 / boss.tentacles) + (now * 0.01);
                        const tentacleX = bossCenterX + Math.cos(tentacleAngle) * 100;
                        const tentacleY = bossCenterY + Math.sin(tentacleAngle) * 50;
                        
                        const angle = Math.atan2(playerCenterY - tentacleY, playerCenterX - tentacleX);
                        createBossBullet(tentacleX, tentacleY, angle, '#004488', 'tentacle');
                    }
                    
                    // 漩渦攻擊
                    if (boss.whirlpool && Math.random() < 0.3) {
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * Math.PI / 6) + (now * 0.02);
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#0066aa', 'whirlpool');
                        }
                    }
                    break;
                case 'phoenix':
                    // 不死火鳳 - 火焰攻擊
                    for (let i = 0; i < 10; i++) {
                        const angle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX) + (Math.random() - 0.5) * 1.0;
                        createBossBullet(bossCenterX, bossCenterY + 50, angle, '#ff6600', 'firebird');
                    }
                    
                    // 火焰軌跡
                    if (boss.fireTrail) {
                        for (let i = 0; i < 5; i++) {
                            createBossBullet(bossCenterX + (Math.random() - 0.5) * boss.width, bossCenterY + boss.height, Math.PI/2, '#ff4400', 'firetrail');
                        }
                    }
                    break;
                case 'emperor':
                    // 星域皇帝 - 皇家攻擊
                    for (let i = 0; i < 16; i++) {
                        const angle = (i * Math.PI / 8) + (now * 0.005);
                        const radius = 80 + Math.sin(now * 0.01) * 20;
                        createBossBullet(bossCenterX + Math.cos(angle) * radius, bossCenterY + Math.sin(angle) * radius, angle + Math.PI, '#aa0088', 'royal');
                    }
                    
                    // 皇家護衛召喚
                    if (boss.royalGuard && Math.random() < 0.1) {
                        for (let i = 0; i < 2; i++) {
                            const summon = {
                                x: bossCenterX + (i - 0.5) * 200,
                                y: bossCenterY + 100,
                                width: 40,
                                height: 40,
                                speed: 2,
                                health: 10,
                                maxHealth: 10,
                                color: '#cc66aa',
                                points: 200,
                                credits: 25,
                                type: 'royalguard'
                            };
                            enemies.push(summon);
                        }
                    }
                    break;
                case 'worldeater':
                    // 世界吞噬者 - 毀滅攻擊
                    for (let i = 0; i < 32; i++) {
                        const angle = (i * Math.PI / 16) + (now * 0.003);
                        createBossBullet(bossCenterX, bossCenterY + 125, angle, '#220022', 'devour');
                    }
                    
                    // 現實扭曲
                    if (boss.realityWarp && Math.random() < 0.2) {
                        for (let i = 0; i < 8; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            createBossBullet(Math.random() * canvas.width, bossCenterY + 50, angle, '#440044', 'warp');
                        }
                    }
                    break;
                case 'cosmos':
                    // 宇宙意志 - 宇宙級攻擊
                    for (let i = 0; i < 40; i++) {
                        const angle = (i * Math.PI / 20) + (now * 0.008);
                        const radius = 120 + Math.cos(now * 0.02 + i) * 40;
                        createBossBullet(bossCenterX + Math.cos(angle) * radius, bossCenterY + Math.sin(angle) * radius, angle + Math.PI, '#8800ff', 'cosmic');
                    }
                    
                    // 星辰創造
                    if (boss.starforge && Math.random() < 0.15) {
                        for (let i = 0; i < 6; i++) {
                            createBossBullet(bossCenterX + (Math.random() - 0.5) * 300, bossCenterY + (Math.random() - 0.5) * 200, Math.random() * Math.PI * 2, '#ffaa88', 'star');
                        }
                    }
                    break;
                case 'infinity':
                    // 無限存在 - 終極攻擊
                    for (let i = 0; i < 64; i++) {
                        const angle = (i * Math.PI / 32) + (now * 0.01);
                        const wave = Math.sin(now * 0.03 + i * 0.5);
                        const radius = 150 + wave * 60;
                        createBossBullet(bossCenterX + Math.cos(angle) * radius, bossCenterY + Math.sin(angle) * radius, angle + Math.PI + wave, '#ffffff', 'infinity');
                    }
                    
                    // 現實控制
                    if (boss.realityControl && Math.random() < 0.1) {
                        for (let i = 0; i < 12; i++) {
                            const x = Math.random() * canvas.width;
                            const y = Math.random() * canvas.height * 0.7;
                            const angle = Math.atan2(playerCenterY - y, playerCenterX - x);
                            createBossBullet(x, y, angle, '#ccccff', 'reality');
                        }
                    }
                    break;
                
                // 快打旋風Boss攻擊模式
                case 'ryu':
                    // 隆的波動拳
                    if (boss.hadokenCharge < 3) {
                        createBossBullet(bossCenterX, bossCenterY + 50, Math.PI/2, '#0099ff', 'hadoken');
                        boss.hadokenCharge++;
                    } else {
                        // 升龍拳 - 向上發射的多重攻擊
                        for (let i = 0; i < 5; i++) {
                            createBossBullet(bossCenterX + (i-2) * 10, bossCenterY, -Math.PI/2 + (i-2) * 0.2, '#ffaa00', 'shoryuken');
                        }
                        boss.hadokenCharge = 0;
                    }
                    
                    // 瞬移攻擊
                    if (now - boss.teleportTimer > 5000) {
                        boss.x = Math.random() * (canvas.width - boss.width);
                        boss.teleportTimer = now;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4);
                            createBossBullet(bossCenterX, bossCenterY, angle, '#ffffff', 'energy');
                        }
                    }
                    break;
                    
                case 'chun_li':
                    // 春麗的氣功拳
                    if (boss.kikokenReady) {
                        for (let i = 0; i < 3; i++) {
                            createBossBullet(bossCenterX + (i-1) * 20, bossCenterY + 50, Math.PI/2 + (i-1) * 0.3, '#0088ff', 'kikoken');
                        }
                        boss.kikokenReady = false;
                        setTimeout(() => boss.kikokenReady = true, 2000);
                    }
                    
                    // 旋風腿 - 圓形攻擊
                    if (Math.random() < 0.3) {
                        boss.spinningBirdKick = true;
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * Math.PI / 6) + (now * 0.01);
                            createBossBullet(bossCenterX, bossCenterY, angle, '#00aaff', 'spinning');
                        }
                    }
                    break;
                    
                case 'ken':
                    // 肯的火焰波動拳
                    if (boss.flameHadoken) {
                        createBossBullet(bossCenterX, bossCenterY + 50, Math.PI/2, '#ff4400', 'flamehadoken');
                        // 火焰擴散
                        for (let i = 0; i < 3; i++) {
                            createBossBullet(bossCenterX + (i-1) * 30, bossCenterY + 70, Math.PI/2 + (i-1) * 0.4, '#ff6600', 'flame');
                        }
                    }
                    
                    // 疾風模式
                    if (Math.random() < 0.2) {
                        boss.rushMode = true;
                        boss.speed *= 2;
                        for (let i = 0; i < 6; i++) {
                            setTimeout(() => {
                                createBossBullet(bossCenterX, bossCenterY + 40, Math.PI/2, '#ffaa00', 'rush');
                            }, i * 100);
                        }
                        setTimeout(() => {
                            boss.rushMode = false;
                            boss.speed /= 2;
                        }, 1000);
                    }
                    break;
                    
                case 'akuma':
                    // 豪鬼的暗黑波動拳
                    if (boss.darkHadoken) {
                        createBossBullet(bossCenterX, bossCenterY + 50, Math.PI/2, '#440000', 'darkhadoken');
                        // 追蹤彈
                        const playerAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        createBossBullet(bossCenterX, bossCenterY + 50, playerAngle, '#660000', 'tracking');
                    }
                    
                    // 瞬獄殺 - 終極攻擊
                    if (boss.ragingDemon < 100) {
                        boss.ragingDemon += 2;
                    } else {
                        // 發動瞬獄殺
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 50 + Math.random() * 100;
                            createBossBullet(
                                bossCenterX + Math.cos(angle) * distance,
                                bossCenterY + Math.sin(angle) * distance,
                                angle + Math.PI,
                                '#aa0000',
                                'ragingdemon'
                            );
                        }
                        boss.ragingDemon = 0;
                    }
                    
                    // 空中火球
                    if (boss.airFireball && Math.random() < 0.4) {
                        createBossBullet(bossCenterX - 50, bossCenterY, Math.PI/2 + 0.5, '#ff0000', 'airfireball');
                        createBossBullet(bossCenterX + 50, bossCenterY, Math.PI/2 - 0.5, '#ff0000', 'airfireball');
                    }
                    break;
                    
                case 'sagat':
                    // 沙卡特的老虎射擊
                    if (boss.tigerShot) {
                        createBossBullet(bossCenterX, bossCenterY + 50, Math.PI/2, '#ff8800', 'tigershot');
                        // 高低老虎射擊
                        if (Math.random() < 0.5) {
                            createBossBullet(bossCenterX, bossCenterY + 30, Math.PI/2 - 0.3, '#ff8800', 'tigershot');
                            createBossBullet(bossCenterX, bossCenterY + 70, Math.PI/2 + 0.3, '#ff8800', 'tigershot');
                        }
                    }
                    
                    // 老虎升擊
                    if (boss.tigerUppercut && Math.random() < 0.3) {
                        for (let i = 0; i < 4; i++) {
                            createBossBullet(bossCenterX + (i-1.5) * 15, bossCenterY, -Math.PI/2, '#ffaa00', 'tigeruppercut');
                        }
                    }
                    break;
                    
                case 'vega':
                    // 維加的爪攻擊 - 快速移動攻擊
                    if (boss.clawAttack) {
                        // 快速移動到玩家附近
                        const moveToX = playerCenterX + (Math.random() - 0.5) * 100;
                        const moveToY = Math.max(50, Math.min(300, playerCenterY - 50));
                        boss.x = moveToX - boss.width / 2;
                        boss.y = moveToY;
                        
                        // 爪攻擊
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + (now * 0.05);
                            createBossBullet(bossCenterX, bossCenterY, angle, '#8800ff', 'claw');
                        }
                    }
                    
                    // 牆跳攻擊
                    if (boss.wallJump && Math.random() < 0.25) {
                        boss.x = Math.random() < 0.5 ? 0 : canvas.width - boss.width;
                        createBossBullet(bossCenterX, bossCenterY, Math.PI/2, '#aa44ff', 'walljump');
                    }
                    break;
                    
                case 'balrog':
                    // 巴洛克的衝刺拳
                    if (boss.dashPunch) {
                        // 衝向玩家
                        const playerAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
                        for (let i = 0; i < 3; i++) {
                            createBossBullet(
                                bossCenterX,
                                bossCenterY + 50,
                                playerAngle + (i-1) * 0.2,
                                '#0044aa',
                                'dashpunch'
                            );
                        }
                    }
                    
                    // 頭槌攻擊
                    if (boss.headbutt && Math.random() < 0.4) {
                        createBossBullet(bossCenterX, bossCenterY, Math.PI/2, '#0066cc', 'headbutt');
                        // 衝擊波
                        for (let i = 0; i < 6; i++) {
                            const angle = Math.PI/2 + (i-2.5) * 0.3;
                            createBossBullet(bossCenterX, bossCenterY + 40, angle, '#0088ff', 'shockwave');
                        }
                    }
                    break;
                    
                case 'bison':
                    // 拜森的精神力攻擊
                    if (boss.psychoPower) {
                        // 精神力波
                        for (let i = 0; i < 5; i++) {
                            const angle = Math.PI/2 + (i-2) * 0.4;
                            createBossBullet(bossCenterX, bossCenterY + 50, angle, '#cc0000', 'psychopower');
                        }
                        
                        // 精神風暴
                        if (Math.random() < 0.3) {
                            for (let i = 0; i < 16; i++) {
                                const angle = (i * Math.PI / 8) + (now * 0.02);
                                const radius = 80 + Math.sin(now * 0.01 + i) * 20;
                                createBossBullet(
                                    bossCenterX + Math.cos(angle) * radius,
                                    bossCenterY + Math.sin(angle) * radius,
                                    angle + Math.PI,
                                    '#ff0000',
                                    'psychostorm'
                                );
                            }
                        }
                    }
                    
                    // 剪刀腳
                    if (boss.scissorKick && Math.random() < 0.35) {
                        // 快速移動攻擊
                        boss.x = playerCenterX - boss.width / 2;
                        for (let i = 0; i < 4; i++) {
                            createBossBullet(bossCenterX + (i-1.5) * 25, bossCenterY + 50, Math.PI/2, '#aa0000', 'scissor');
                        }
                    }
                    
                    // 瞬移攻擊（最終Boss特權）
                    if (boss.teleport && Math.random() < 0.2) {
                        boss.x = Math.random() * (canvas.width - boss.width);
                        boss.y = Math.random() * 200 + 50;
                        // 瞬移後爆發攻擊
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * Math.PI / 6);
                            createBossBullet(bossCenterX, bossCenterY, angle, '#ff4400', 'teleportattack');
                        }
                    }
                    break;
            }
            
            boss.lastFire = now;
        }
        
        // 創建Boss子彈
        function createBossBullet(x, y, angle, color, type) {
            bossBullets.push({
                x: x,
                y: y,
                width: 8,
                height: 8,
                speed: type === 'missile' ? 4 : 3,
                angle: angle,
                color: color,
                type: type,
                damage: 15
            });
        }
        
        // 動態難度系統 - 根據武器等級和遊戲等級調整
        function getDynamicDifficulty() {
            const baseDiff = difficultySettings[difficulty];
            const weaponTier = getWeaponTier(equippedWeapon);
            const levelMultiplier = 1 + (level * 0.02); // 每級增加2%難度
            const weaponMultiplier = 1 + (weaponTier * 0.1); // 每武器階級增加10%難度
            
            return {
                enemySpeedMultiplier: baseDiff.enemySpeedMultiplier * levelMultiplier * weaponMultiplier,
                enemyHealthMultiplier: baseDiff.enemyHealthMultiplier * levelMultiplier * weaponMultiplier,
                enemySpawnRate: baseDiff.enemySpawnRate * (1 + level * 0.03), // 生成率增加更明顯
                playerDamageMultiplier: baseDiff.playerDamageMultiplier,
                creditMultiplier: baseDiff.creditMultiplier
            };
        }
        
        // 獲取武器階級
        function getWeaponTier(weaponId) {
            const weaponTiers = {
                'basic': 0,
                'rapid': 1,
                'heavy': 2,
                'spread': 3,
                'piercing': 4,
                'elemental': 5
            };
            return weaponTiers[weaponId] || 0;
        }

        // 生成敵人 - 擴展版本
        function spawnEnemy() {
            // 根據等級解鎖不同敵人類型
            let availableTypes = ['basic', 'fast', 'heavy'];
            
            if (level >= 3) availableTypes.push('Thornspine');
            if (level >= 5) availableTypes.push('bomber', 'assassin');
            if (level >= 8) availableTypes.push('tank', 'sniper');
            if (level >= 12) availableTypes.push('phantom', 'berserker');
            if (level >= 16) availableTypes.push('destroyer', 'voidwalker');
            if (level >= 20) availableTypes.push('nemesis', 'guardian');
            if (level >= 25) availableTypes.push('reaper', 'titan');
            if (level >= 30) availableTypes.push('overlord', 'phoenix');
            
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const dynamicDiff = getDynamicDifficulty();
            
            let enemy = {
                x: Math.random() * (canvas.width - 40),
                y: -40,
                type: type
            };
            
            switch (type) {
                case 'basic':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.speed = (2 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(2 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff4444';
                    enemy.points = 100;
                    enemy.credits = 15;
                    break;
                case 'fast':
                    enemy.width = 30;
                    enemy.height = 30;
                    enemy.speed = (4 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(1 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#44ff44';
                    enemy.points = 150;
                    enemy.credits = 20;
                    break;
                case 'heavy':
                    enemy.width = 60;
                    enemy.height = 60;
                    enemy.speed = (1 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(5 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#4444ff';
                    enemy.points = 300;
                    enemy.credits = 35;
                    break;
                case 'Thornspine':
                    enemy.width = 80;
                    enemy.height = 80;
                    enemy.speed = (1.5 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(8 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ffffff';
                    enemy.points = 500;
                    enemy.credits = 60;
                    break;
                case 'bomber':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.speed = (1.8 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(4 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff8800';
                    enemy.points = 250;
                    enemy.credits = 35;
                    enemy.explodeOnDeath = true;
                    enemy.explosionRadius = 60;
                    break;
                case 'assassin':
                    enemy.width = 25;
                    enemy.height = 25;
                    enemy.speed = (6 + level * 0.3) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(1.5 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#8800ff';
                    enemy.points = 200;
                    enemy.credits = 30;
                    enemy.zigzagPattern = true;
                    enemy.moveTimer = 0;
                    break;
                case 'tank':
                    enemy.width = 70;
                    enemy.height = 70;
                    enemy.speed = (1 + level * 0.08) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(15 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#666666';
                    enemy.points = 400;
                    enemy.credits = 50;
                    enemy.armor = Math.ceil(3 * dynamicDiff.enemyHealthMultiplier);
                    break;
                case 'sniper':
                    enemy.width = 45;
                    enemy.height = 45;
                    enemy.speed = (2.5 + level * 0.15) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(6 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#00ff88';
                    enemy.points = 350;
                    enemy.credits = 45;
                    enemy.canShoot = true;
                    enemy.fireRate = 2000;
                    enemy.lastFire = 0;
                    enemy.range = 400;
                    break;
                case 'phantom':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.speed = (3 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(7 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#aa00aa';
                    enemy.points = 450;
                    enemy.credits = 55;
                    enemy.phaseTimer = 0;
                    enemy.isPhased = false;
                    enemy.phaseDuration = 2000;
                    break;
                case 'berserker':
                    enemy.width = 55;
                    enemy.height = 55;
                    enemy.speed = (2.5 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(12 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff0000';
                    enemy.points = 500;
                    enemy.credits = 65;
                    enemy.enrageThreshold = Math.ceil(4 * dynamicDiff.enemyHealthMultiplier);
                    enemy.isEnraged = false;
                    break;
                case 'destroyer':
                    enemy.width = 90;
                    enemy.height = 70;
                    enemy.speed = (1.5 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(20 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff4400';
                    enemy.points = 700;
                    enemy.credits = 85;
                    enemy.canShoot = true;
                    enemy.fireRate = 1500;
                    enemy.lastFire = 0;
                    enemy.multiShot = 3;
                    break;
                case 'voidwalker':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.speed = (3.5 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(10 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#330066';
                    enemy.points = 600;
                    enemy.credits = 75;
                    enemy.teleportTimer = 0;
                    enemy.canTeleport = true;
                    enemy.teleportCooldown = 3000;
                    break;
                case 'nemesis':
                    enemy.width = 85;
                    enemy.height = 65;
                    enemy.speed = (2.8 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(25 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff0088';
                    enemy.points = 1000;
                    enemy.credits = 120;
                    enemy.shield = Math.ceil(8 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxShield = enemy.shield;
                    enemy.canShoot = true;
                    enemy.fireRate = 1200;
                    enemy.lastFire = 0;
                    break;
                case 'guardian':
                    enemy.width = 100;
                    enemy.height = 80;
                    enemy.speed = (1.2 + level * 0.1) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(35 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#00aaff';
                    enemy.points = 1200;
                    enemy.credits = 150;
                    enemy.shield = Math.ceil(15 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxShield = enemy.shield;
                    enemy.shieldRegen = 0.5;
                    enemy.healingAura = true;
                    enemy.auraRadius = 100;
                    break;
                case 'reaper':
                    enemy.width = 60;
                    enemy.height = 80;
                    enemy.speed = (4 + level * 0.25) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(18 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#000000';
                    enemy.points = 1500;
                    enemy.credits = 180;
                    enemy.canShoot = true;
                    enemy.fireRate = 800;
                    enemy.lastFire = 0;
                    enemy.scytheAttack = true;
                    enemy.drainLife = true;
                    break;
                case 'titan':
                    enemy.width = 150;
                    enemy.height = 120;
                    enemy.speed = (0.8 + level * 0.05) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(60 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#cc6600';
                    enemy.points = 2000;
                    enemy.credits = 250;
                    enemy.armor = Math.ceil(10 * dynamicDiff.enemyHealthMultiplier);
                    enemy.canShoot = true;
                    enemy.fireRate = 2000;
                    enemy.lastFire = 0;
                    enemy.groundSlam = true;
                    break;
                case 'overlord':
                    enemy.width = 120;
                    enemy.height = 90;
                    enemy.speed = (2 + level * 0.15) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(40 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#6600cc';
                    enemy.points = 2500;
                    enemy.credits = 300;
                    enemy.canSummon = true;
                    enemy.summonTimer = 0;
                    enemy.summonCooldown = 5000;
                    enemy.canShoot = true;
                    enemy.fireRate = 1000;
                    enemy.lastFire = 0;
                    break;
                case 'phoenix':
                    enemy.width = 75;
                    enemy.height = 75;
                    enemy.speed = (3.5 + level * 0.2) * dynamicDiff.enemySpeedMultiplier;
                    enemy.health = Math.ceil(30 * dynamicDiff.enemyHealthMultiplier);
                    enemy.maxHealth = enemy.health;
                    enemy.color = '#ff6600';
                    enemy.points = 3000;
                    enemy.credits = 400;
                    enemy.canRevive = true;
                    enemy.reviveTimer = 0;
                    enemy.reviveHealth = Math.ceil(15 * dynamicDiff.enemyHealthMultiplier);
                    enemy.fireTrail = true;
                    enemy.burnDamage = true;
                    break;
            }
            
            enemies.push(enemy);
        }
        
        // 生成道具
        function spawnPowerup(x, y, isBoss = false) {
            let dropChance = 0.6;
            if (difficulty === 'boss') {
                dropChance = isBoss ? 1.0 : 0.9;
            }
            
            if (Math.random() < dropChance) { // 增加道具掉落機率到60%
                const types = ['health', 'maxhealth']; // 只保留補血和增加血量上限
                const weights = [0.8, 0.2]; // 補血80%機率，增加血量上限20%機率
                
                // 根據權重選擇道具類型
                let selectedType;
                if (difficulty === 'boss') {
                    selectedType = Math.random() < 0.9 ? 'health' : 'maxhealth';
                } else {
                    selectedType = Math.random() < 0.8 ? 'health' : 'maxhealth';
                }
                
                let dropCount = 1;
                if (difficulty === 'boss' && isBoss) {
                    dropCount = Math.floor(Math.random() * 3) + 2;
                }
                
                for (let i = 0; i < dropCount; i++) {
                    powerups.push({
                        x: x + (Math.random() - 0.5) * 60,
                        y: y + (Math.random() - 0.5) * 40,
                        width: 25,
                        height: 25,
                        type: selectedType,
                        speed: 2 + Math.random(),
                        rotation: 0
                    });
                }
            }
        }
        
        // 創建粒子效果
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // 爆炸效果
        function createExplosion(x, y) {
            // 對附近敵人造成傷害
            enemies.forEach((enemy, index) => {
                const dx = (enemy.x + enemy.width/2) - x;
                const dy = (enemy.y + enemy.height/2) - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) { // 爆炸範圍
                    const damage = Math.max(1, Math.ceil((80 - distance) / 10));
                    enemy.health -= damage;
                    createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff4400', 3);
                    
                    if (enemy.health <= 0) {
                        score += enemy.points;
                        const dynamicDiff = getDynamicDifficulty();
                        const creditReward = Math.ceil(enemy.credits * dynamicDiff.creditMultiplier);
                        credits += creditReward;

                        // 獲得經驗值
                        const expReward = Math.ceil(enemy.points * 0.5);
                        gainExperience(expReward);

                        updateCreditsDisplay();
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ffff00', 8);
                        spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        enemies.splice(index, 1);
                    }
                }
            });
            
            // 對玩家造成傷害
            const playerDx = (player.x + player.width/2) - x;
            const playerDy = (player.y + player.height/2) - y;
            const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
            
            if (playerDistance < 60) {
                const damage = Math.max(5, Math.ceil((60 - playerDistance) / 6));
                
                // 檢查大絕招護盾效果
                if (!(ultimateActive && ultimateType === 'shield')) {
                    health -= damage;
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 8);
                } else {
                    // 護盾效果，顯示藍色粒子效果
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#0088ff', 8);
                }
            }
            
            // 爆炸視覺效果
            createParticles(x, y, '#ff6600', 20);
            createParticles(x, y, '#ffaa00', 15);
            createParticles(x, y, '#ff0000', 10);
        }
        
        // 更新遊戲狀態
        function update(deltaTime) {
            if (gameState !== 'playing') return;
            
            // 更新魔王模式計時器
            updateBossTimer();
            
            // 更新大絕招狀態
            updateUltimateStatus();
            
            // 長按射擊
            if (keys['Space']) {
                shoot();
            }
            
            // 更新玩家位置
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.x = Math.max(0, player.x - player.speed);
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                player.x = Math.min(canvas.width - player.width, player.x + player.speed);
            }
            if (keys['ArrowUp'] || keys['KeyW']) {
                player.y = Math.max(0, player.y - player.speed);
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                player.y = Math.min(canvas.height - player.height, player.y + player.speed);
            }
            
            // 檢查勝利條件
            if (player.powerLevel >= 100) {
                gameState = 'victory';
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalLevel').textContent = level;
                document.getElementById('gameOver').querySelector('h2').textContent = '🏆 恭喜通關！ 🏆';
                document.getElementById('gameOver').querySelector('h2').style.color = '#00ff00';
                document.getElementById('gameOver').style.display = 'block';
                return;
            }
            
            // 更新星星
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            
            // 更新子彈
            bullets = bullets.filter(bullet => {
                // 更新軌跡
                bullet.trail.push({x: bullet.x, y: bullet.y});
                if (bullet.trail.length > 5) {
                    bullet.trail.shift();
                }

                if (bullet.angle) {
                    bullet.x += Math.sin(bullet.angle) * bullet.speed;
                    bullet.y -= Math.cos(bullet.angle) * bullet.speed;
                } else {
                    bullet.y -= bullet.speed;
                }

                return bullet.y > -50 && bullet.x > -50 && bullet.x < canvas.width + 50;
            });

            // 更新Boss
            bosses.forEach(boss => {
                boss.moveTimer += deltaTime;
                
                // Boss移動邏輯
                if (boss.y < 50) {
                    // 時間減緩效果
                    const speedMultiplier = (ultimateActive && ultimateType === 'time_slow') ? 0.3 : 1;
                    boss.y += boss.speed * speedMultiplier;
                } else {
                    // 到達位置後開始橫向移動
                    boss.x += Math.sin(boss.moveTimer * 0.002) * boss.speed;
                    boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
                    
                    // 特殊移動模式
                    if (boss.type === 'teleport') {
                        boss.teleportTimer += deltaTime;
                        if (boss.teleportTimer > 3000) { // 每3秒瞬移
                            boss.x = Math.random() * (canvas.width - boss.width);
                            boss.y = Math.random() * 100 + 50;
                            boss.teleportTimer = 0;
                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, boss.color, 10);
                        }
                    }
                }
                
                // Boss射擊
                bossFire(boss);
            });

            // 更新Boss子彈
            bossBullets = bossBullets.filter((bullet, bulletIndex) => {
                if (bullet.type === 'missile' && !bullet.isReflected) {
                    // 追蹤飛彈（只有非反彈子彈才追蹤玩家）
                    const dx = (player.x + player.width/2) - bullet.x;
                    const dy = (player.y + player.height/2) - bullet.y;
                    const angle = Math.atan2(dy, dx);
                    bullet.x += Math.cos(angle) * bullet.speed;
                    bullet.y += Math.sin(angle) * bullet.speed;
                } else if (bullet.isReflected) {
                    // 反彈子彈使用新的方向和速度
                    if (bullet.dx !== undefined && bullet.dy !== undefined) {
                        bullet.x += bullet.dx;
                        bullet.y += bullet.dy;
                    } else {
                        // 使用角度移動
                        bullet.x += Math.cos(bullet.angle) * bullet.speed;
                        bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    }

                    // 檢查反彈子彈與敵人的碰撞
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        if (bullet.x < enemy.x + enemy.width &&
                            bullet.x + bullet.width > enemy.x &&
                            bullet.y < enemy.y + enemy.height &&
                            bullet.y + bullet.height > enemy.y) {

                            enemy.health -= bullet.damage;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, bullet.color, 8);

                            if (enemy.health <= 0) {
                                enemies.splice(i, 1);
                                score += enemy.points * 2; // 反彈擊殺雙倍分數
                                credits += enemy.credits * 2;

                                // 獲得經驗值（反彈擊殺有額外獎勵）
                                const expReward = Math.ceil(enemy.points * 1.0); // 經驗值為點數的100%
                                gainExperience(expReward);

                                updateCreditsDisplay();
                            }

                            // 移除子彈
                            return false;
                        }
                    }

                    // 檢查反彈子彈與BOSS的碰撞
                    for (let i = bosses.length - 1; i >= 0; i--) {
                        const boss = bosses[i];
                        if (bullet.x < boss.x + boss.width &&
                            bullet.x + bullet.width > boss.x &&
                            bullet.y < boss.y + boss.height &&
                            bullet.y + bullet.height > boss.y) {

                            // 先扣護盾（如果有的話）
                            if (boss.shield && boss.shield > 0) {
                                const shieldDamage = Math.min(bullet.damage, boss.shield);
                                boss.shield -= shieldDamage;
                                const remainingDamage = bullet.damage - shieldDamage;
                                if (remainingDamage > 0) {
                                    boss.health -= remainingDamage;
                                }
                            } else {
                                boss.health -= bullet.damage;
                            }

                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, bullet.color, 12);

                            if (boss.health <= 0) {
                                bosses.splice(i, 1);
                                score += boss.points * 3; // 反彈擊殺BOSS三倍分數
                                credits += boss.credits * 3;
                                updateCreditsDisplay();
                            }

                            // 移除子彈
                            return false;
                        }
                    }
                } else {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                }

                return bullet.x > -50 && bullet.x < canvas.width + 50 &&
                       bullet.y > -50 && bullet.y < canvas.height + 50;
            });
            
            // 更新敵人和特殊能力
            enemies.forEach((enemy, enemyIndex) => {
                // 基本移動
                // 時間減緩效果
                const speedMultiplier = (ultimateActive && ultimateType === 'time_slow') ? 0.3 : 1;
                enemy.y += enemy.speed * speedMultiplier;
                
                // 特殊能力處理
                switch (enemy.type) {
                    case 'assassin':
                        // 刺客 - Z字型移動
                        if (enemy.zigzagPattern) {
                            enemy.moveTimer += deltaTime;
                            enemy.x += Math.sin(enemy.moveTimer * 0.005) * 3;
                            enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
                        }
                        break;
                        
                    case 'phantom':
                        // 幻影 - 定期進入相位狀態
                        enemy.phaseTimer += deltaTime;
                        if (enemy.phaseTimer > enemy.phaseDuration) {
                            enemy.isPhased = !enemy.isPhased;
                            enemy.phaseTimer = 0;
                            if (enemy.isPhased) {
                                createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#aa00aa', 8);
                            }
                        }
                        break;
                        
                    case 'berserker':
                        // 狂戰士 - 低血量時狂暴
                        if (enemy.health <= enemy.enrageThreshold && !enemy.isEnraged) {
                            enemy.isEnraged = true;
                            enemy.speed *= 1.5;
                            enemy.color = '#ff6666';
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff0000', 15);
                        }
                        break;
                        
                    case 'voidwalker':
                        // 虛空行者 - 定期瞬移
                        enemy.teleportTimer += deltaTime;
                        if (enemy.teleportTimer > enemy.teleportCooldown && enemy.canTeleport) {
                            const newX = Math.random() * (canvas.width - enemy.width);
                            const newY = Math.max(enemy.y - 80, 50);
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#330066', 10);
                            enemy.x = newX;
                            enemy.y = newY;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#330066', 10);
                            enemy.teleportTimer = 0;
                        }
                        break;
                        
                    case 'guardian':
                        // 守護者 - 護盾回復和治療光環
                        if (enemy.shield < enemy.maxShield) {
                            enemy.shield = Math.min(enemy.maxShield, enemy.shield + enemy.shieldRegen);
                        }
                        
                        // 治療附近敵人
                        if (enemy.healingAura) {
                            enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy) {
                                    const dx = (otherEnemy.x + otherEnemy.width/2) - (enemy.x + enemy.width/2);
                                    const dy = (otherEnemy.y + otherEnemy.height/2) - (enemy.y + enemy.height/2);
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < enemy.auraRadius && otherEnemy.health < otherEnemy.maxHealth) {
                                        otherEnemy.health = Math.min(otherEnemy.maxHealth, otherEnemy.health + 0.2);
                                        if (Math.random() < 0.1) {
                                            createParticles(otherEnemy.x + otherEnemy.width/2, otherEnemy.y + otherEnemy.height/2, '#00aaff', 2);
                                        }
                                    }
                                }
                            });
                        }
                        break;
                        
                    case 'overlord':
                        // 統治者 - 定期召喚小怪
                        enemy.summonTimer += deltaTime;
                        if (enemy.summonTimer > enemy.summonCooldown && enemies.length < 15) {
                            for (let i = 0; i < 2; i++) {
                                const summon = {
                                    x: enemy.x + Math.random() * enemy.width,
                                    y: enemy.y + enemy.height + 10,
                                    width: 20,
                                    height: 20,
                                    speed: 3,
                                    health: 1,
                                    maxHealth: 1,
                                    color: '#9966cc',
                                    points: 50,
                                    credits: 5,
                                    type: 'summoned'
                                };
                                enemies.push(summon);
                            }
                            enemy.summonTimer = 0;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#6600cc', 12);
                        }
                        break;
                        
                    case 'phoenix':
                        // 鳳凰 - 死亡時復活
                        if (enemy.health <= 0 && enemy.canRevive && enemy.reviveTimer === 0) {
                            enemy.health = enemy.reviveHealth;
                            enemy.canRevive = false; // 只能復活一次
                            enemy.color = '#ffaa66';
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff6600', 20);
                        }
                        
                        // 火焰軌跡
                        if (enemy.fireTrail && Math.random() < 0.3) {
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height, '#ff4400', 2);
                        }
                        break;
                        
                    case 'reaper':
                        // 死神 - 吸血攻擊
                        if (enemy.drainLife && Math.random() < 0.01) {
                            const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                            const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 150) {
                                health -= 1;
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + 0.5);
                                createParticles((enemy.x + player.x)/2 + 25, (enemy.y + player.y)/2 + 25, '#990000', 3);
                            }
                        }
                        break;
                        
                    case 'titan':
                        // 泰坦 - 地面震擊
                        if (enemy.groundSlam && enemy.y > canvas.height * 0.3 && Math.random() < 0.005) {
                            // 震波攻擊
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                createParticles(enemy.x + enemy.width/2 + Math.cos(angle) * 50, 
                                              enemy.y + enemy.height/2 + Math.sin(angle) * 50, '#cc6600', 2);
                            }
                            
                            // 對玩家造成範圍傷害
                            const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                            const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 120) {
                                health -= Math.max(1, Math.ceil((120 - distance) / 20));
                                createParticles(player.x + player.width/2, player.y + player.height/2, '#ff6600', 5);
                            }
                        }
                        break;
                }
                
                // 可射擊敵人的攻擊邏輯
                if (enemy.canShoot && enemy.fireRate) {
                    const now = Date.now();
                    if (now - enemy.lastFire > enemy.fireRate && enemy.y > 0 && enemy.y < canvas.height - 100) {
                        enemyFire(enemy);
                        enemy.lastFire = now;
                    }
                }
            });
            enemies = enemies.filter(enemy => enemy.y < canvas.height + 50);
            
            // 更新道具
            powerups.forEach(powerup => {
                powerup.y += powerup.speed;
                powerup.rotation += 0.1;
            });
            powerups = powerups.filter(powerup => powerup.y < canvas.height + 50);
            
            // 更新粒子
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                return particle.life > 0;
            });
            
            // 碰撞檢測 - 子彈與敵人
            bullets.forEach((bullet, bulletIndex) => {
                let bulletHit = false;
                
                // 與普通敵人的碰撞
                enemies.forEach((enemy, enemyIndex) => {
                    if (!bulletHit && bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        let damage = bullet.damage;
                        let damageBlocked = false;
                        
                        // 處理特殊防護
                        if (enemy.type === 'phantom' && enemy.isPhased) {
                            // 相位狀態下免疫傷害
                            damage = 0;
                            damageBlocked = true;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#aa00aa', 3);
                        } else if (enemy.shield > 0) {
                            // 護盾系統
                            const shieldDamage = Math.min(damage, enemy.shield);
                            enemy.shield -= shieldDamage;
                            damage -= shieldDamage;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#00aaff', 2);
                        } else if (enemy.armor && enemy.armor > 0) {
                            // 護甲系統
                            const armorReduction = Math.min(damage, enemy.armor);
                            enemy.armor -= armorReduction;
                            damage = Math.max(0, damage - armorReduction);
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#888888', 2);
                        }
                        
                        if (!damageBlocked) {
                            enemy.health -= damage;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 3);
                        }
                        
                        if (bullet.effect !== 'piercing') {
                            bulletHit = true;
                        } else {
                            bullet.pierced++;
                            if (bullet.pierced >= 3) bulletHit = true; // 穿透最多3個敵人
                        }
                        
                        if (enemy.health <= 0) {
                            // 爆炸敵人死亡時爆炸
                            if (enemy.explodeOnDeath) {
                                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            }

                            score += enemy.points;
                            const dynamicDiff = getDynamicDifficulty();
                            const creditReward = Math.ceil(enemy.credits * dynamicDiff.creditMultiplier);
                            credits += creditReward;

                            // 獲得經驗值
                            const expReward = Math.ceil(enemy.points * 0.5); // 經驗值為點數的50%
                            gainExperience(expReward);

                            updateCreditsDisplay();
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ffff00', 8);
                            spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(enemyIndex, 1);
                        }
                    }
                });
                
                // 處理敵人傷害（簡化版本）
                
                // 與Boss的碰撞
                bosses.forEach((boss, bossIndex) => {
                    if (!bulletHit && bullet.x < boss.x + boss.width &&
                        bullet.x + bullet.width > boss.x &&
                        bullet.y < boss.y + boss.height &&
                        bullet.y + bullet.height > boss.y) {
                        
                        let damage = bullet.damage;
                        
                        // 護盾Boss的護盾機制
                        if (boss.type === 'shield' && boss.shield > 0) {
                            boss.shield -= damage;
                            if (boss.shield < 0) {
                                boss.health += boss.shield; // 剩餘傷害打到血量
                                boss.shield = 0;
                            }
                        } else {
                            boss.health -= damage;
                        }
                        
                        if (bullet.effect !== 'piercing') {
                            bulletHit = true;
                        }
                        
                        createParticles(boss.x + boss.width/2, boss.y + boss.height/2, boss.color, 5);
                        
                        if (boss.health <= 0) {
                            score += boss.points;
                            const creditReward = Math.ceil(boss.credits * difficultySettings[difficulty].creditMultiplier);
                            credits += creditReward;

                            // 獲得經驗值（Boss擊殺有豐厚獎勵）
                            const expReward = Math.ceil(boss.points * 1.5); // 經驗值為點數的150%
                            gainExperience(expReward);

                            updateCreditsDisplay();
                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, '#ffff00', 15);
                            spawnPowerup(boss.x + boss.width/2, boss.y + boss.height/2, true);
                            bosses.splice(bossIndex, 1);
                        }
                    }
                });
                
                if (bulletHit) {
                    bullets.splice(bulletIndex, 1);
                }
            });
            
            // 碰撞檢測 - 玩家與敵人
            enemies.forEach((enemy, enemyIndex) => {
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    health -= 20;
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 5);
                    enemies.splice(enemyIndex, 1);
                    
                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                        autoSaveGame(); // 遊戲結束時自動保存
                    }
                }
            });

            // 碰撞檢測 - 玩家與Boss子彈
            bossBullets.forEach((bullet, bulletIndex) => {
                if (player.x < bullet.x + bullet.width &&
                    player.x + player.width > bullet.x &&
                    player.y < bullet.y + bullet.height &&
                    player.y + bullet.height > bullet.y) {

                    // 檢查量子力場反彈效果
                    if (ultimateActive && ultimateType === 'quantum_field') {
                        // 反彈子彈，將方向完全反向
                        if (bullet.angle !== undefined) {
                            // 有角度的子彈，反轉角度
                            bullet.angle = bullet.angle + Math.PI;
                        } else {
                            // 直線飛行的子彈，設置反向速度
                            if (bullet.dx && bullet.dy) {
                                bullet.dx = -bullet.dx;
                                bullet.dy = -bullet.dy;
                            } else {
                                // 垂直飛行的子彈，改為向上飛行
                                bullet.dx = 0;
                                bullet.dy = -bullet.speed;
                            }
                        }

                        // 反彈特效和屬性
                        bullet.color = '#00ffff'; // 改變顏色表示反彈
                        bullet.isReflected = true; // 標記為反彈子彈
                        bullet.damage *= 2; // 反彈後傷害加倍

                        // 創造量子力場反彈特效
                        createParticles(player.x + player.width/2, player.y + player.height/2, '#00ffff', 12);

                        // 不移除子彈，讓它反彈
                        return;
                    }
                    // 檢查大絕招護盾效果
                    else if (ultimateActive && ultimateType === 'shield') {
                        // 護盾效果，顯示藍色粒子效果
                        createParticles(player.x + player.width/2, player.y + player.height/2, '#0088ff', 8);
                        bossBullets.splice(bulletIndex, 1);
                        return;
                    } else {
                        health -= bullet.damage;
                        createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 8);
                    }

                    bossBullets.splice(bulletIndex, 1);

                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                        autoSaveGame(); // 遊戲結束時自動保存
                    }
                }
            });

            // 碰撞檢測 - 玩家與Boss
            bosses.forEach((boss, bossIndex) => {
                if (player.x < boss.x + boss.width &&
                    player.x + player.width > boss.x &&
                    player.y < boss.y + boss.height &&
                    player.y + player.height > boss.y) {
                    
                    health -= 35; // Boss碰撞傷害
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff0000', 10);
                    
                    if (health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOver').style.display = 'block';
                        autoSaveGame(); // 遊戲結束時自動保存
                    }
                }
            });
            
            // 碰撞檢測 - 玩家與道具
            powerups.forEach((powerup, powerupIndex) => {
                if (player.x < powerup.x + powerup.width &&
                    player.x + player.width > powerup.x &&
                    player.y < powerup.y + powerup.height &&
                    player.y + player.height > powerup.y) {
                    
                    switch (powerup.type) {
                        case 'health':
                            maxHealth += 30; // 增加最大血量
                            health = Math.min(maxHealth, health + 25);
                            break;
                        case 'maxhealth':
                            maxHealth += 50; // 增加最大血量
                            health = Math.min(maxHealth, health + 30); // 同時回復一些血量
                            break;
                    }
                    
                    createParticles(powerup.x + powerup.width/2, powerup.y + powerup.height/2, '#00c3f4', 5);
                    powerups.splice(powerupIndex, 1);
                }
            });
            
            // 生成敵人 - 根據難度模式調整
            const dynamicDiff = getDynamicDifficulty();
            
            if (difficulty === 'boss') {
                // 魔王挑戰模式 - 動態升級系統
                const elapsed = Date.now() - bossTimerStart;
                const progressLevel = Math.floor(elapsed / 30000) + 1; // 每30秒升級一次

                bossSpawnTimer += deltaTime;
                const bossSpawnInterval = Math.max(2000, 6000 - progressLevel * 200); // 隨時間加快生成
                const maxBosses = Math.min(5, 1 + Math.floor(progressLevel / 3)); // 同時存在更多Boss

                if (bossSpawnTimer > bossSpawnInterval && bosses.length < maxBosses) {
                    spawnBoss();
                    bossSpawnTimer = 0;
                }
            } else if (difficulty === 'street_fighter') {
                // 快打旋風模式 - 快速生成快打旋風Boss
                bossSpawnTimer += deltaTime;
                const bossSpawnInterval = Math.max(2000, 5000 - level * 50); // 更頻繁的快打旋風Boss
                const maxBosses = Math.min(4, 2 + Math.floor(level / 8)); // 可存在更多Boss

                if (bossSpawnTimer > bossSpawnInterval && bosses.length < maxBosses) {
                    spawnBoss();
                    bossSpawnTimer = 0;
                }
            } else {
                // 一般模式 - 生成普通敵人和BOSS
                const baseSpawnRate = 0.015 + level * 0.003;
                const adjustedSpawnRate = baseSpawnRate * dynamicDiff.enemySpawnRate;
                const maxEnemies = Math.min(15, 8 + Math.floor(level / 2)); // 根據等級限制敵人數量
                
                if (Math.random() < adjustedSpawnRate && enemies.length < maxEnemies) {
                    spawnEnemy();
                }

                // Boss生成邏輯 - 提高生成頻率
                bossSpawnTimer += deltaTime;
                const bossSpawnInterval = Math.max(20000, 40000 - level * 1000); // 等級越高，間隔越短
                if (bossSpawnTimer > bossSpawnInterval && bosses.length === 0) {
                    const bossChance = Math.min(0.8, 0.2 + (level * 0.04)); // 最高80%機率
                    if (Math.random() < bossChance) {
                        spawnBoss();
                        bossSpawnTimer = 0;
                    }
                }
            }
            
            // 升級系統已重新實現 - 玩家可以透過擊殺敵人獲得經驗值並升級
            
            // 更新UI
            document.getElementById('health').textContent = `${health}/${maxHealth}`;
            document.getElementById('score').textContent = score;
            updateExperienceDisplay(); // 使用專用函數更新經驗值和等級顯示
        }
        
        function updatePowerupIndicator() {
            const indicator = document.getElementById('powerup-indicator');
            let weaponType = '';
            
            if (player.powerLevel <= 10) {
                weaponType = '基礎武器';
            } else if (player.powerLevel <= 25) {
                const elementTypes = ['1等', '2等', '3等'];
                const typeIndex = Math.floor((player.powerLevel - 11) / 5);
                weaponType = elementTypes[typeIndex] || '元素武器';
            } else if (player.powerLevel <= 50) {
                const energyTypes = ['4等', '5等', '6等'];
                const typeIndex = Math.floor((player.powerLevel - 26) / 8);
                weaponType = energyTypes[typeIndex] || '能量武器';
            } else if (player.powerLevel <= 75) {
                const magicTypes = ['7等', '8等 ', '9等'];
                const typeIndex = Math.floor((player.powerLevel - 51) / 8);
                weaponType = magicTypes[typeIndex] || '魔法武器';
            } else if (player.powerLevel <= 99) {
                const legendaryTypes = ['10等'];
                const typeIndex = Math.floor((player.powerLevel - 76) / 8);
                weaponType = legendaryTypes[typeIndex] || '傳說武器';
            } else if (player.powerLevel === 100) {
                weaponType = '🌟 獲勝 🌟';
            }
            
            let modeText = difficulty === 'boss' ? '🔥 魔王挑戰 🔥' : difficulty;
            let bossCountText = difficulty === 'boss' ? ` | BOSS數量: ${bosses.length}` : '';
            let text = `武器等級: ${player.powerLevel}/100 | ${weaponType} | 射速: ${(1000/player.fireRate).toFixed(1)}/秒 | 難度: ${modeText}${bossCountText}`;
            indicator.textContent = text;
        }
        
        // 繪製遊戲
        function draw() {
            // 清空畫布
            if (difficulty === 'boss') {
                // 魔王挑戰模式 - 黑暗紅色背景
                const pulse = Math.sin(Date.now() * 0.003) * 0.05 + 0.1;
                ctx.fillStyle = `rgba(20, 0, 0, ${pulse})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                // 一般模式 - 深藍色背景
                ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // 繪製星星
            stars.forEach(star => {
                if (difficulty === 'boss') {
                    // 魔王挑戰模式 - 紅色星星
                    ctx.fillStyle = `rgba(255, 100, 100, ${star.brightness})`;
                } else {
                    // 一般模式 - 白色星星
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                }
                ctx.fillRect(star.x, star.y, 2, 2);
            });
            
            if (gameState !== 'playing') return;
            
            // 繪製玩家
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // 繪製玩家細節
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-5, -player.height/2, 10, 20);
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(-15, player.height/2 - 10, 8, 8);
            ctx.fillRect(7, player.height/2 - 10, 8, 8);
            ctx.restore();
            
            // 繪製子彈
            bullets.forEach(bullet => {
                // 繪製軌跡
                if (bullet.trail.length > 1 && bullet.effect !== 'normal') {
                    ctx.strokeStyle = bullet.color + '40';
                    ctx.lineWidth = bullet.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(bullet.trail[0].x + bullet.width/2, bullet.trail[0].y + bullet.height/2);
                    for (let i = 1; i < bullet.trail.length; i++) {
                        ctx.lineTo(bullet.trail[i].x + bullet.width/2, bullet.trail[i].y + bullet.height/2);
                    }
                    ctx.stroke();
                }
                
                // 根據特效類型繪製不同效果
                switch (bullet.effect) {
                    case 'basic':
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                        
                    case 'fire':
                    case 'fireball':
                        // 火焰特效
                        ctx.fillStyle = '#ff3300';
                        ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 火花粒子
                        if (Math.random() < 0.3) {
                            createParticles(bullet.x + bullet.width/2, bullet.y + bullet.height, '#ff6600', 1);
                        }
                        break;
                        
                    case 'ice':
                        // 冰元素特效
                        ctx.shadowColor = '#00aaff';
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // 冰晶效果
                        ctx.strokeStyle = '#aaffff80';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        break;
                        
                    case 'lightning':
                        // 雷電特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 電流效果
                        if (Math.random() < 0.5) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(bullet.x, bullet.y);
                            ctx.lineTo(bullet.x + Math.random() * 10 - 5, bullet.y + bullet.height + 5);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'laser':
                        // 激光特效
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'plasma':
                        // 電漿特效
                        const plasmaTime = Date.now() * 0.01;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 電漿環
                        ctx.strokeStyle = bullet.color + '80';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                               8 + Math.sin(time + bullet.x) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'neutron':
                        // 中子星特效
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'antimatter':
                        // 反物質特效
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 空間扭曲效果
                        ctx.strokeStyle = bullet.color;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'quantum':
                        // 量子特效
                        const quantumPhase = Math.sin(Date.now() * 0.05);
                        ctx.globalAlpha = 0.7 + quantumPhase * 0.3;
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 25;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.globalAlpha = 1.0;
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'singularity':
                        // 黑洞特效
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 30;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 吸取效果
                        for (let i = 0; i < 3; i++) {
                            const radius = 15 + i * 5;
                            ctx.strokeStyle = `rgba(77, 0, 128, ${0.3 - i * 0.1})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'genesis':
                        // 創世之彈特效
                        const genesisColors = ['#ffffff', '#ffff00', '#00ffff', '#ff00ff'];
                        const colorIndex = Math.floor(Date.now() * 0.01) % genesisColors.length;
                        ctx.shadowColor = genesisColors[colorIndex];
                        ctx.shadowBlur = 35;
                        ctx.fillStyle = genesisColors[colorIndex];
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 創世光環
                        for (let i = 0; i < 4; i++) {
                            const radius = 12 + i * 4 + Math.sin(Date.now() * 0.03 + i) * 2;
                            ctx.strokeStyle = `${genesisColors[i]}80`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'energy':
                        // 能量特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 能量光環
                        for (let i = 0; i < 3; i++) {
                            ctx.fillStyle = bullet.color + (60 - i * 20).toString(16);
                            ctx.fillRect(bullet.x - i, bullet.y - i, bullet.width + i*2, bullet.height + i*2);
                        }
                        break;
                        
                    case 'star':
                        // 星爆特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 星光效果
                        ctx.strokeStyle = bullet.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(bullet.x + bullet.width/2, bullet.y - 5);
                        ctx.lineTo(bullet.x + bullet.width/2, bullet.y + bullet.height + 5);
                        ctx.moveTo(bullet.x - 5, bullet.y + bullet.height/2);
                        ctx.lineTo(bullet.x + bullet.width + 5, bullet.y + bullet.height/2);
                        ctx.stroke();
                        break;
                        
                    case 'portal':
                        // 時空扭曲特效
                        const portalTime = Date.now() * 0.02;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 扭曲環
                        for (let i = 0; i < 3; i++) {
                            ctx.strokeStyle = bullet.color + (80 - i * 30).toString(16);
                            ctx.lineWidth = 2 - i * 0.5;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                                   5 + i * 3 + Math.sin(portalTime + i) * 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'comet':
                        // 彗星特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 彗星尾巴
                        const gradient = ctx.createLinearGradient(bullet.x, bullet.y, bullet.x, bullet.y + 20);
                        gradient.addColorStop(0, bullet.color);
                        gradient.addColorStop(1, bullet.color + '00');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(bullet.x - 1, bullet.y + bullet.height, bullet.width + 2, 15);
                        break;
                        
                    case 'dragon':
                        // 龍息特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // 龍火粒子
                        if (Math.random() < 0.4) {
                            createParticles(bullet.x + bullet.width/2, bullet.y + bullet.height, bullet.color, 2);
                        }
                        break;
                        
                    case 'blackhole':
                        // 黑洞特效
                        const blackholeTime = Date.now() * 0.01;
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 重力波效果
                        for (let i = 0; i < 5; i++) {
                            ctx.strokeStyle = `rgba(100, 100, 255, ${(5-i)*0.1})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                                   i * 4 + Math.sin(blackholeTime + i) * 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'cosmic':
                        // 宇宙射線特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 20;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'godray':
                        // 神光射線特效
                        const godrayTime = Date.now() * 0.03;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 神聖光環
                        ctx.strokeStyle = '#ffffff80';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 
                               15 + Math.sin(godrayTime) * 5, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'rainbow':
                        // 彩虹特效
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 彩虹光暈
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 15;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'ultimate':
                        // 終極特效
                        const pulseTime = Date.now() * 0.02;
                        const pulse = Math.sin(pulseTime) * 0.5 + 1;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 脈動光環
                        ctx.strokeStyle = '#ffffff80';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 10 * pulse, 0, Math.PI * 2);
                        ctx.stroke();
                        break;

                    default:
                        // 普通子彈
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // 子彈光暈效果
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        break;
                }
            });
            
            // 繪製敵人
            enemies.forEach(enemy => {
                // 特殊敵人視覺效果
                switch (enemy.type) {
                    case 'phantom':
                        if (enemy.isPhased) {
                            // 相位狀態 - 半透明和閃爍
                            ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                            ctx.shadowColor = enemy.color;
                            ctx.shadowBlur = 10;
                        }
                        break;
                    case 'berserker':
                        if (enemy.isEnraged) {
                            // 狂暴狀態 - 紅色光暈
                            ctx.shadowColor = '#ff0000';
                            ctx.shadowBlur = 15 + Math.sin(Date.now() * 0.02) * 5;
                        }
                        break;
                    case 'voidwalker':
                        // 虛空行者 - 紫色扭曲效果
                        ctx.shadowColor = '#330066';
                        ctx.shadowBlur = 8;
                        break;
                    case 'guardian':
                        // 守護者 - 藍色護盾光環
                        if (enemy.shield > 0) {
                            ctx.strokeStyle = '#00aaff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(enemy.x - 3, enemy.y - 3, enemy.width + 6, enemy.height + 6);
                        }
                        if (enemy.healingAura) {
                            ctx.strokeStyle = '#00ffaa';
                            ctx.lineWidth = 1;
                            const radius = enemy.auraRadius * (0.8 + Math.sin(Date.now() * 0.005) * 0.2);
                            ctx.beginPath();
                            ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'reaper':
                        // 死神 - 黑暗氣息
                        ctx.shadowColor = '#000000';
                        ctx.shadowBlur = 12;
                        if (enemy.drainLife) {
                            // 吸血效果
                            const pulse = Math.sin(Date.now() * 0.01);
                            ctx.fillStyle = `rgba(153, 0, 0, ${0.3 + pulse * 0.2})`;
                            ctx.fillRect(enemy.x - 5, enemy.y - 5, enemy.width + 10, enemy.height + 10);
                        }
                        break;
                    case 'phoenix':
                        // 鳳凰 - 火焰光環
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 15;
                        if (enemy.fireTrail) {
                            const flameRadius = 20 + Math.sin(Date.now() * 0.02) * 5;
                            ctx.strokeStyle = '#ff4400';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, flameRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'titan':
                        // 泰坦 - 震動效果
                        const shake = Math.sin(Date.now() * 0.05) * 2;
                        ctx.translate(shake, shake);
                        ctx.shadowColor = '#cc6600';
                        ctx.shadowBlur = 10;
                        break;
                    case 'overlord':
                        // 統治者 - 威嚴光環
                        ctx.shadowColor = '#6600cc';
                        ctx.shadowBlur = 12;
                        const crownEffect = Math.sin(Date.now() * 0.008) * 3;
                        ctx.fillStyle = '#9966cc';
                        ctx.fillRect(enemy.x + enemy.width/2 - 5, enemy.y - 10 + crownEffect, 10, 8);
                        break;
                    case 'nemesis':
                        // 天敵 - 多重護盾效果
                        if (enemy.shield > 0) {
                            for (let i = 0; i < 3; i++) {
                                ctx.strokeStyle = `rgba(255, 0, 136, ${0.6 - i * 0.2})`;
                                ctx.lineWidth = 2;
                                const radius = 5 + i * 8 + Math.sin(Date.now() * 0.01 + i) * 3;
                                ctx.beginPath();
                                ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, radius, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        break;
                    case 'bomber':
                        // 爆炸敵人 - 閃爍警告
                        if (enemy.health <= enemy.maxHealth * 0.3) {
                            const flash = Math.sin(Date.now() * 0.02) > 0 ? 1 : 0.3;
                            ctx.globalAlpha = flash;
                            ctx.shadowColor = '#ff8800';
                            ctx.shadowBlur = 8;
                        }
                        break;
                    case 'assassin':
                        // 刺客 - 殘影效果
                        for (let i = 0; i < 3; i++) {
                            ctx.globalAlpha = 0.2 - i * 0.05;
                            ctx.fillStyle = enemy.color;
                            ctx.fillRect(enemy.x - i * 5, enemy.y, enemy.width, enemy.height);
                        }
                        ctx.globalAlpha = 1.0;
                        break;
                }
                
                // 繪製敵人本體
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // 重置特效
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
                ctx.setTransform(1, 0, 0, 1, 0, 0); // 重置變換
                
                // 繪製護甲指示器
                if (enemy.armor && enemy.armor > 0) {
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(enemy.x + 2, enemy.y + 2, Math.min(enemy.width - 4, enemy.armor * 2), 3);
                }
                
                // 繪製生命值條在敵人左側
                const healthPercent = enemy.health / enemy.maxHealth;
                const healthBarX = enemy.x - 7;
                const healthBarY = enemy.y;
                const healthBarWidth = 5;
                const healthBarHeight = enemy.height;
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.fillRect(healthBarX, healthBarY + healthBarHeight * (1 - healthPercent), 
                           healthBarWidth, healthBarHeight * healthPercent);
                           
                // 簡化的血量條顯示
            });

            // 繪製Boss
            bosses.forEach(boss => {
                // Boss特殊視覺效果
                switch (boss.type) {
                    case 'berserker':
                        // 狂戰士Boss - 紅色戰鬥光環
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 20 + Math.sin(Date.now() * 0.01) * 10;
                        break;
                    case 'shield':
                        // 護盾Boss - 藍色護盾光環
                        ctx.shadowColor = '#0088ff';
                        ctx.shadowBlur = 15;
                        if (boss.shield > 0) {
                            const shieldRadius = Math.max(boss.width, boss.height) / 2 + 10;
                            ctx.strokeStyle = '#0088ff';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, shieldRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'laser':
                        // 雷射Boss - 紫色能量場
                        ctx.shadowColor = '#8800ff';
                        ctx.shadowBlur = 12;
                        const energyPulse = Math.sin(Date.now() * 0.02);
                        ctx.strokeStyle = `rgba(136, 0, 255, ${0.5 + energyPulse * 0.3})`;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(boss.x - 2, boss.y - 2, boss.width + 4, boss.height + 4);
                        break;
                    case 'missile':
                        // 飛彈Boss - 橙色爆炸氣息
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 18;
                        // 飛彈發射器效果
                        const missileGlow = Math.sin(Date.now() * 0.015) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 102, 0, ${missileGlow * 0.3})`;
                        ctx.fillRect(boss.x - 5, boss.y - 5, boss.width + 10, boss.height + 10);
                        break;
                    case 'teleport':
                        // 傳送Boss - 紫色傳送能量
                        ctx.shadowColor = '#cc00ff';
                        ctx.shadowBlur = 15;
                        if (boss.isTeleporting) {
                            ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.03) * 0.3;
                            for (let i = 0; i < 5; i++) {
                                const offset = i * 3;
                                ctx.strokeStyle = `rgba(204, 0, 255, ${0.8 - i * 0.15})`;
                                ctx.lineWidth = 2;
                                ctx.strokeRect(boss.x - offset, boss.y - offset, boss.width + offset * 2, boss.height + offset * 2);
                            }
                        }
                        break;
                    case 'split':
                        // 分裂Boss - 綠色分裂能量
                        ctx.shadowColor = '#00ff44';
                        ctx.shadowBlur = 10;
                        if (boss.canSplit) {
                            const splitEffect = Math.sin(Date.now() * 0.025);
                            ctx.strokeStyle = `rgba(0, 255, 68, ${0.6 + splitEffect * 0.4})`;
                            ctx.lineWidth = 1;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(boss.x, boss.y, boss.width, boss.height);
                            ctx.setLineDash([]);
                        }
                        break;
                    case 'heal':
                        // 治療Boss - 綠色治療光環
                        ctx.shadowColor = '#00aa44';
                        ctx.shadowBlur = 12;
                        const healPulse = Math.sin(Date.now() * 0.01);
                        const healRadius = 40 + healPulse * 10;
                        ctx.strokeStyle = `rgba(0, 170, 68, ${0.4 + healPulse * 0.2})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, healRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'armor':
                        // 裝甲Boss - 金屬光澤
                        ctx.shadowColor = '#888888';
                        ctx.shadowBlur = 8;
                        if (boss.armor > 0) {
                            ctx.fillStyle = 'rgba(136, 136, 136, 0.3)';
                            ctx.fillRect(boss.x - 2, boss.y - 2, boss.width + 4, boss.height + 4);
                        }
                        break;
                    case 'speed':
                        // 速度Boss - 青色速度軌跡
                        ctx.shadowColor = '#00aaaa';
                        ctx.shadowBlur = 10;
                        for (let i = 0; i < 4; i++) {
                            ctx.globalAlpha = 0.3 - i * 0.07;
                            ctx.fillStyle = boss.color;
                            ctx.fillRect(boss.x - i * 8, boss.y, boss.width, boss.height);
                        }
                        ctx.globalAlpha = 1.0;
                        break;
                    case 'minion':
                        // 召喚Boss - 暗紫色召喚法陣
                        ctx.shadowColor = '#440088';
                        ctx.shadowBlur = 15;
                        const summonEffect = Math.sin(Date.now() * 0.008);
                        ctx.strokeStyle = `rgba(68, 0, 136, ${0.5 + summonEffect * 0.3})`;
                        ctx.lineWidth = 2;
                        const radius = Math.max(boss.width, boss.height) / 2 + 15;
                        ctx.beginPath();
                        ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        // 法陣內圈
                        ctx.beginPath();
                        ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'plasma':
                        // 等離子Boss - 電藍色等離子效果
                        ctx.shadowColor = '#0099ff';
                        ctx.shadowBlur = 25;
                        const plasmaEffect = Math.sin(Date.now() * 0.03);
                        ctx.fillStyle = `rgba(0, 153, 255, ${0.2 + plasmaEffect * 0.15})`;
                        for (let i = 0; i < 3; i++) {
                            const offset = i * 4 + plasmaEffect * 2;
                            ctx.fillRect(boss.x - offset, boss.y - offset, boss.width + offset * 2, boss.height + offset * 2);
                        }
                        break;
                    case 'nightmare':
                        // 夢魘Boss - 黑暗扭曲效果
                        ctx.shadowColor = '#330000';
                        ctx.shadowBlur = 30;
                        const nightmareWave = Math.sin(Date.now() * 0.005);
                        ctx.fillStyle = `rgba(51, 0, 0, ${0.4 + nightmareWave * 0.2})`;
                        for (let i = 0; i < 5; i++) {
                            const waveOffset = Math.sin(Date.now() * 0.02 + i) * 5;
                            ctx.fillRect(boss.x - 10 + waveOffset, boss.y - 10, boss.width + 20, boss.height + 20);
                        }
                        break;
                    case 'infinity':
                        // 無限Boss - 彩虹無限符號效果
                        ctx.shadowColor = '#ffffff';
                        ctx.shadowBlur = 20;
                        const infinityColors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
                        const colorIndex = Math.floor(Date.now() * 0.01) % infinityColors.length;
                        ctx.strokeStyle = infinityColors[colorIndex];
                        ctx.lineWidth = 4;
                        // 無限符號效果
                        const centerX = boss.x + boss.width / 2;
                        const centerY = boss.y + boss.height / 2;
                        ctx.beginPath();
                        for (let t = 0; t < Math.PI * 2; t += 0.1) {
                            const x = centerX + 30 * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                            const y = centerY + 15 * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                            if (t === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        break;
                }
                
                // Boss本體
                ctx.fillStyle = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                
                // Boss邊框
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(boss.x, boss.y, boss.width, boss.height);
                
                // 重置特效
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Boss血量條
                const healthPercent = boss.health / boss.maxHealth;
                const healthBarWidth = boss.width;
                const healthBarHeight = 8;
                const healthBarX = boss.x;
                const healthBarY = boss.y - 15;
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);
                
                // 護盾條（如果有）
                if (boss.type === 'shield' && boss.maxShield) {
                    const shieldPercent = boss.shield / boss.maxShield;
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.8)';
                    ctx.fillRect(healthBarX, healthBarY - 10, healthBarWidth, 4);
                    
                    ctx.fillStyle = 'rgba(0, 200, 255, 0.9)';
                    ctx.fillRect(healthBarX, healthBarY - 10, healthBarWidth * shieldPercent, 4);
                }
                
                // Boss名稱
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(boss.name || 'Boss', boss.x + boss.width/2, boss.y - 25);
            });

            // 繪製Boss子彈和敵人子彈
            bossBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                // 特殊效果
                switch (bullet.type) {
                    case 'missile':
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
                        break;
                    case 'laser':
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 10;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        break;
                    case 'homing':
                        // 追蹤彈特效
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 8;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        ctx.shadowBlur = 0;
                        // 追蹤軌跡
                        ctx.strokeStyle = bullet.color + '60';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                }
            });
            
            // 繪製道具
            powerups.forEach(powerup => {
                ctx.save();
                ctx.translate(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                ctx.rotate(powerup.rotation);
                
                switch (powerup.type) {
                    case 'health':
                        ctx.fillStyle = '#ff4444';
                        break;
                    case 'maxhealth':
                        // 最大血量道具 - 金色
                        ctx.fillStyle = '#ffaa00';
                        // 添加光環效果
                        ctx.shadowColor = '#ffaa00';
                        ctx.shadowBlur = 10;
                        break;
                }
                
                ctx.fillRect(-powerup.width/2, -powerup.height/2, powerup.width, powerup.height);
                
                // 為特殊道具添加額外視覺效果
                if (powerup.type === 'maxhealth') {
                    // 金色十字
                    ctx.strokeStyle = '#ffdd00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-powerup.width/2, 0);
                    ctx.lineTo(powerup.width/2, 0);
                    ctx.moveTo(0, -powerup.height/2);
                    ctx.lineTo(0, powerup.height/2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
            
            // 繪製粒子
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `${particle.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            });
        }
        
        // 遊戲主循環
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // 開始遊戲
        function startGame() {
            gameState = 'playing';
            score = 0;
            level = 1;
            experience = 0; // 重置經驗值
            experienceToNextLevel = 100; // 重置升級所需經驗值

            // 重置基礎血量
            health = 100;
            maxHealth = 100;

            player.x = 375;
            player.y = 500;
            player.powerLevel = 1;
            player.fireRate = weapons[equippedWeapon].fireRate;

            // 應用盔甲效果（這會根據裝備的盔甲調整血量）
            applyArmorEffects();
            
            // 計時模式設置
            if (difficulty === 'boss' || difficulty === 'street_fighter') {
                bossTimerStart = Date.now();
                document.getElementById('bossTimer').style.display = 'block';
                
                // 設置對應的時間限制
                if (difficulty === 'street_fighter') {
                    bossTimeLimit = streetFighterTimeLimit;
                } else {
                    bossTimeLimit = 5 * 60 * 1000; // 魔王挑戰 5分鐘
                }
            } else {
                document.getElementById('bossTimer').style.display = 'none';
            }
            bullets = [];
            enemies = [];
            bosses = [];
            bossBullets = [];
            powerups = [];
            particles = [];
            bossSpawnTimer = 0;
            
            hideAllScreens();
            updatePowerupIndicator();
            updateCreditsDisplay();
            updateExperienceDisplay(); // 更新經驗值顯示
        }
        
        // 重新開始遊戲
        function restartGame() {
            backToMainMenu();
        }
        
        // 自動載入存檔（如果存在）
        function autoLoadGame() {
            try {
                const saveData = localStorage.getItem('cosmosShootingSave');
                if (saveData) {
                    const data = JSON.parse(saveData);

                    // 靜默載入存檔數據（包含等級系統）
                    credits = data.credits || 0;
                    level = data.level || 1; // 載入等級
                    experience = data.experience || 0; // 載入經驗值
                    experienceToNextLevel = data.experienceToNextLevel || 100; // 載入升級所需經驗值
                    maxHealth = data.maxHealth || 100;
                    ownedWeapons = data.ownedWeapons || ['basic'];
                    ownedBullets = data.ownedBullets || ['normal'];
                    ownedArmors = data.ownedArmors || ['none'];
                    ownedUltimates = data.ownedUltimates || ['shield'];
                    equippedWeapon = data.equippedWeapon || 'basic';
                    equippedBullet = data.equippedBullet || 'normal';
                    equippedArmor = data.equippedArmor || 'none';
                    equippedUltimate = data.equippedUltimate || 'shield';
                    difficulty = data.difficulty || 'easy';
                    
                    // 更新UI顯示
                    updateCreditsDisplay();
                    updateExperienceDisplay();
                    updateAllDisplays();
                    
                    // 應用盔甲效果
                    applyArmorEffects();
                }
            } catch (error) {
                console.log('自動載入存檔失敗:', error);
            }
        }

        // 初始化
        initStars();
        updatePowerupIndicator();
        updateCreditsDisplay();
        autoLoadGame(); // 自動載入存檔
        applyArmorEffects(); // 應用盔甲效果
        showWeapons(); // 預設顯示武器頁面
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>